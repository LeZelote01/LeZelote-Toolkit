# Routes API pour le service Pentesting
from fastapi import APIRouter, HTTPException, BackgroundTasks
from typing import Dict, List
import uuid
import asyncio
from datetime import datetime, timedelta

from .models import ScanRequest, ScanResult, Vulnerability, ScanType, ReportRequest
from .scanner import PentestScanner
from .reports import ReportGenerator
from database import get_database

router = APIRouter(prefix="/api/pentesting", tags=["pentesting"])

# Cache des scans en cours et terminés
active_scans: Dict[str, Dict] = {}
completed_scans: Dict[str, ScanResult] = {}

@router.get("/")
async def pentesting_status():
    """Status du service Pentesting"""
    return {
        "status": "operational",
        "service": "Tests de Pénétration",
        "version": "1.0.0-portable",
        "features": {
            "web_scanning": True,
            "owasp_top10": True,
            "ssl_tls_testing": True,
            "port_scanning": True,
            "vulnerability_detection": True,
            "automated_reporting": True
        },
        "scan_types": [
            "web", "owasp", "ssl", "ports", "network"
        ],
        "active_scans": len(active_scans),
        "completed_scans": len(completed_scans)
    }

@router.post("/scan", response_model=Dict)
async def start_scan(scan_request: ScanRequest, background_tasks: BackgroundTasks):
    """Démarre un nouveau scan de pénétration"""
    try:
        # Générer un ID unique pour le scan
        scan_id = str(uuid.uuid4())
        
        # Valider la cible
        if not scan_request.target:
            raise HTTPException(status_code=400, detail="Cible requise")
            
        # Normaliser l'URL cible
        target = scan_request.target
        if not target.startswith(('http://', 'https://')):
            target = f'http://{target}'
            
        # Initialiser le scan
        scan_info = {
            "scan_id": scan_id,
            "target": target,
            "scan_type": scan_request.scan_type,
            "status": "starting",
            "start_time": datetime.now(),
            "options": scan_request.options or {}
        }
        
        active_scans[scan_id] = scan_info
        
        # Démarrer le scan en arrière-plan
        background_tasks.add_task(execute_scan, scan_id, target, scan_request.scan_type, scan_request.options or {})
        
        return {
            "scan_id": scan_id,
            "status": "started",
            "message": f"Scan {scan_request.scan_type} démarré pour {target}",
            "estimated_duration": "2-5 minutes",
            "check_status_url": f"/api/pentesting/scan/{scan_id}/status"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur lors du démarrage du scan: {str(e)}")

@router.get("/scan/{scan_id}/status")
async def get_scan_status(scan_id: str):
    """Récupère le statut d'un scan"""
    
    # Vérifier dans les scans actifs
    if scan_id in active_scans:
        scan_info = active_scans[scan_id]
        duration = (datetime.now() - scan_info["start_time"]).total_seconds()
        
        return {
            "scan_id": scan_id,
            "status": scan_info["status"],
            "target": scan_info["target"],
            "scan_type": scan_info["scan_type"],
            "duration": round(duration, 2),
            "progress": _estimate_progress(scan_info["status"], duration),
            "message": _get_status_message(scan_info["status"])
        }
    
    # Vérifier dans les scans terminés
    elif scan_id in completed_scans:
        scan_result = completed_scans[scan_id]
        
        return {
            "scan_id": scan_id,
            "status": "completed",
            "target": scan_result.target,
            "scan_type": scan_result.scan_type,
            "duration": scan_result.duration,
            "progress": 100,
            "vulnerabilities_count": len(scan_result.vulnerabilities),
            "summary": scan_result.summary
        }
    
    else:
        raise HTTPException(status_code=404, detail="Scan non trouvé")

@router.get("/scan/{scan_id}/results")
async def get_scan_results(scan_id: str):
    """Récupère les résultats détaillés d'un scan"""
    
    if scan_id not in completed_scans:
        if scan_id in active_scans:
            raise HTTPException(status_code=202, detail="Scan en cours, résultats pas encore disponibles")
        else:
            raise HTTPException(status_code=404, detail="Scan non trouvé")
    
    scan_result = completed_scans[scan_id]
    
    return {
        "scan_result": scan_result.dict(),
        "recommendations": _generate_recommendations(scan_result.vulnerabilities),
        "next_steps": _suggest_next_steps(scan_result.vulnerabilities)
    }

@router.post("/scan/{scan_id}/report")
async def generate_report(scan_id: str, report_request: ReportRequest, background_tasks: BackgroundTasks):
    """Génère un rapport de scan"""
    
    if scan_id not in completed_scans:
        raise HTTPException(status_code=404, detail="Scan non trouvé ou non terminé")
    
    scan_result = completed_scans[scan_id]
    
    try:
        # Générer le rapport
        generator = ReportGenerator()
        report_path = await generator.generate_report(
            scan_result=scan_result,
            format=report_request.format,
            template=report_request.template,
            branding=report_request.branding
        )
        
        return {
            "status": "success",
            "report_path": report_path,
            "format": report_request.format,
            "download_url": f"/api/reports/download/{report_path.split('/')[-1]}",
            "message": "Rapport généré avec succès"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur génération rapport: {str(e)}")

@router.get("/scans")
async def list_scans(limit: int = 20, offset: int = 0):
    """Liste les scans récents"""
    
    all_scans = []
    
    # Ajouter les scans actifs
    for scan_id, scan_info in active_scans.items():
        all_scans.append({
            "scan_id": scan_id,
            "target": scan_info["target"],
            "scan_type": scan_info["scan_type"],
            "status": scan_info["status"],
            "start_time": scan_info["start_time"],
            "duration": (datetime.now() - scan_info["start_time"]).total_seconds()
        })
    
    # Ajouter les scans terminés
    for scan_id, scan_result in completed_scans.items():
        all_scans.append({
            "scan_id": scan_id,
            "target": scan_result.target,
            "scan_type": scan_result.scan_type,
            "status": "completed",
            "start_time": scan_result.start_time,
            "duration": scan_result.duration,
            "vulnerabilities_count": len(scan_result.vulnerabilities)
        })
    
    # Trier par date de début (plus récent en premier)
    all_scans.sort(key=lambda x: x["start_time"], reverse=True)
    
    # Pagination
    paginated_scans = all_scans[offset:offset + limit]
    
    return {
        "scans": paginated_scans,
        "total": len(all_scans),
        "limit": limit,
        "offset": offset,
        "active_count": len(active_scans),
        "completed_count": len(completed_scans)
    }

@router.delete("/scan/{scan_id}")
async def delete_scan(scan_id: str):
    """Supprime un scan et ses résultats"""
    
    deleted = False
    
    if scan_id in active_scans:
        del active_scans[scan_id]
        deleted = True
    
    if scan_id in completed_scans:
        del completed_scans[scan_id]
        deleted = True
    
    if not deleted:
        raise HTTPException(status_code=404, detail="Scan non trouvé")
    
    return {"message": f"Scan {scan_id} supprimé avec succès"}

# Fonctions utilitaires privées

async def execute_scan(scan_id: str, target: str, scan_type: ScanType, options: Dict):
    """Exécute le scan en arrière-plan"""
    
    try:
        # Mettre à jour le statut
        active_scans[scan_id]["status"] = "running"
        
        # Exécuter le scan
        async with PentestScanner() as scanner:
            vulnerabilities = await scanner.scan_target(target, scan_type, options)
        
        # Créer le résultat
        end_time = datetime.now()
        start_time = active_scans[scan_id]["start_time"]
        duration = (end_time - start_time).total_seconds()
        
        # Calculer le résumé des vulnérabilités
        summary = {
            "critical": len([v for v in vulnerabilities if v.level.value == "critical"]),
            "high": len([v for v in vulnerabilities if v.level.value == "high"]),
            "medium": len([v for v in vulnerabilities if v.level.value == "medium"]),
            "low": len([v for v in vulnerabilities if v.level.value == "low"]),
            "info": len([v for v in vulnerabilities if v.level.value == "info"]),
            "total": len(vulnerabilities)
        }
        
        scan_result = ScanResult(
            scan_id=scan_id,
            target=target,
            scan_type=scan_type,
            status="completed",
            start_time=start_time,
            end_time=end_time,
            duration=duration,
            vulnerabilities=vulnerabilities,
            summary=summary,
            metadata={
                "scanner_version": "1.0.0",
                "scan_options": options
            }
        )
        
        # Déplacer vers les scans terminés
        completed_scans[scan_id] = scan_result
        del active_scans[scan_id]
        
        # Sauvegarder en base de données si possible
        try:
            db = await get_database()
            await db.save_scan_result(scan_result.dict())
        except:
            pass  # Continuer même si la sauvegarde échoue
            
    except Exception as e:
        # Marquer le scan comme échoué
        active_scans[scan_id]["status"] = "failed"
        active_scans[scan_id]["error"] = str(e)
        print(f"Erreur lors du scan {scan_id}: {e}")

def _estimate_progress(status: str, duration: float) -> int:
    """Estime le pourcentage de progression"""
    if status == "starting":
        return 5
    elif status == "running":
        # Progression basée sur le temps (estimation 3 minutes max)
        return min(95, 10 + int((duration / 180) * 85))
    elif status == "completed":
        return 100
    elif status == "failed":
        return 0
    else:
        return 0

def _get_status_message(status: str) -> str:
    """Messages de statut conviviaux"""
    messages = {
        "starting": "Initialisation du scan...",
        "running": "Scan en cours - Analyse des vulnérabilités...",
        "completed": "Scan terminé avec succès",
        "failed": "Erreur lors du scan"
    }
    return messages.get(status, "Statut inconnu")

def _generate_recommendations(vulnerabilities: List[Vulnerability]) -> List[str]:
    """Génère des recommandations basées sur les vulnérabilités"""
    recommendations = []
    
    critical_count = len([v for v in vulnerabilities if v.level.value == "critical"])
    high_count = len([v for v in vulnerabilities if v.level.value == "high"])
    
    if critical_count > 0:
        recommendations.append(f"🚨 URGENT: {critical_count} vulnérabilitée(s) critiques détectées - correction immédiate requise")
    
    if high_count > 0:
        recommendations.append(f"⚠️ PRIORITÉ: {high_count} vulnérabilités à risque élevé à corriger rapidement")
    
    # Recommandations spécifiques selon les types de vulnérabilités
    vuln_types = [v.owasp_category for v in vulnerabilities if v.owasp_category]
    
    if any("Injection" in vtype for vtype in vuln_types):
        recommendations.append("🔍 Implémenter la validation stricte des entrées et les requêtes préparées")
    
    if any("Cryptographic" in vtype for vtype in vuln_types):
        recommendations.append("🔐 Renforcer la configuration SSL/TLS et le chiffrement des données")
    
    if any("Access Control" in vtype for vtype in vuln_types):
        recommendations.append("🛡️ Réviser les contrôles d'accès et les permissions")
    
    return recommendations

def _suggest_next_steps(vulnerabilities: List[Vulnerability]) -> List[str]:
    """Suggère les prochaines étapes"""
    next_steps = [
        "1. Réviser et prioriser les vulnérabilités par niveau de risque",
        "2. Planifier la correction des vulnérabilités critiques et élevées",
        "3. Tester les corrections dans un environnement de staging",
        "4. Effectuer un nouveau scan pour valider les corrections",
        "5. Mettre à jour la documentation de sécurité"
    ]
    
    if vulnerabilities:
        next_steps.append("6. Considérer un audit de sécurité complémentaire si nécessaire")
    
    return next_steps