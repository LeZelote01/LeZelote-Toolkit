# Routes API pour le service Pentesting
from fastapi import APIRouter, HTTPException, BackgroundTasks
from typing import Dict, List
import uuid
import asyncio
from datetime import datetime, timedelta

from .models import ScanRequest, ScanResult, Vulnerability, ScanType, ReportRequest
from .scanner import PentestScanner
from .reports import ReportGenerator
from database import get_database

router = APIRouter(prefix="/api/pentesting", tags=["pentesting"])

# Cache des scans en cours et termin√©s
active_scans: Dict[str, Dict] = {}
completed_scans: Dict[str, ScanResult] = {}

@router.get("/")
async def pentesting_status():
    """Status du service Pentesting"""
    return {
        "status": "operational",
        "service": "Tests de P√©n√©tration",
        "version": "1.0.0-portable",
        "features": {
            "web_scanning": True,
            "owasp_top10": True,
            "ssl_tls_testing": True,
            "port_scanning": True,
            "vulnerability_detection": True,
            "automated_reporting": True
        },
        "scan_types": [
            "web", "owasp", "ssl", "ports", "network"
        ],
        "active_scans": len(active_scans),
        "completed_scans": len(completed_scans)
    }

@router.post("/scan", response_model=Dict)
async def start_scan(scan_request: ScanRequest, background_tasks: BackgroundTasks):
    """D√©marre un nouveau scan de p√©n√©tration"""
    try:
        # G√©n√©rer un ID unique pour le scan
        scan_id = str(uuid.uuid4())
        
        # Valider la cible
        if not scan_request.target:
            raise HTTPException(status_code=400, detail="Cible requise")
            
        # Normaliser l'URL cible
        target = scan_request.target
        if not target.startswith(('http://', 'https://')):
            target = f'http://{target}'
            
        # Initialiser le scan
        scan_info = {
            "scan_id": scan_id,
            "target": target,
            "scan_type": scan_request.scan_type,
            "status": "starting",
            "start_time": datetime.now(),
            "options": scan_request.options or {}
        }
        
        active_scans[scan_id] = scan_info
        
        # D√©marrer le scan en arri√®re-plan
        background_tasks.add_task(execute_scan, scan_id, target, scan_request.scan_type, scan_request.options or {})
        
        return {
            "scan_id": scan_id,
            "status": "started",
            "message": f"Scan {scan_request.scan_type} d√©marr√© pour {target}",
            "estimated_duration": "2-5 minutes",
            "check_status_url": f"/api/pentesting/scan/{scan_id}/status"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur lors du d√©marrage du scan: {str(e)}")

@router.get("/scan/{scan_id}/status")
async def get_scan_status(scan_id: str):
    """R√©cup√®re le statut d'un scan"""
    
    # V√©rifier dans les scans actifs
    if scan_id in active_scans:
        scan_info = active_scans[scan_id]
        duration = (datetime.now() - scan_info["start_time"]).total_seconds()
        
        return {
            "scan_id": scan_id,
            "status": scan_info["status"],
            "target": scan_info["target"],
            "scan_type": scan_info["scan_type"],
            "duration": round(duration, 2),
            "progress": _estimate_progress(scan_info["status"], duration),
            "message": _get_status_message(scan_info["status"])
        }
    
    # V√©rifier dans les scans termin√©s
    elif scan_id in completed_scans:
        scan_result = completed_scans[scan_id]
        
        return {
            "scan_id": scan_id,
            "status": "completed",
            "target": scan_result.target,
            "scan_type": scan_result.scan_type,
            "duration": scan_result.duration,
            "progress": 100,
            "vulnerabilities_count": len(scan_result.vulnerabilities),
            "summary": scan_result.summary
        }
    
    else:
        raise HTTPException(status_code=404, detail="Scan non trouv√©")

@router.get("/scan/{scan_id}/results")
async def get_scan_results(scan_id: str):
    """R√©cup√®re les r√©sultats d√©taill√©s d'un scan"""
    
    if scan_id not in completed_scans:
        if scan_id in active_scans:
            raise HTTPException(status_code=202, detail="Scan en cours, r√©sultats pas encore disponibles")
        else:
            raise HTTPException(status_code=404, detail="Scan non trouv√©")
    
    scan_result = completed_scans[scan_id]
    
    return {
        "scan_result": scan_result.dict(),
        "recommendations": _generate_recommendations(scan_result.vulnerabilities),
        "next_steps": _suggest_next_steps(scan_result.vulnerabilities)
    }

@router.post("/scan/{scan_id}/report")
async def generate_report(scan_id: str, report_request: ReportRequest, background_tasks: BackgroundTasks):
    """G√©n√®re un rapport de scan"""
    
    if scan_id not in completed_scans:
        raise HTTPException(status_code=404, detail="Scan non trouv√© ou non termin√©")
    
    scan_result = completed_scans[scan_id]
    
    try:
        # G√©n√©rer le rapport
        generator = ReportGenerator()
        report_path = await generator.generate_report(
            scan_result=scan_result,
            format=report_request.format,
            template=report_request.template,
            branding=report_request.branding
        )
        
        return {
            "status": "success",
            "report_path": report_path,
            "format": report_request.format,
            "download_url": f"/api/reports/download/{report_path.split('/')[-1]}",
            "message": "Rapport g√©n√©r√© avec succ√®s"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur g√©n√©ration rapport: {str(e)}")

@router.get("/scans")
async def list_scans(limit: int = 20, offset: int = 0):
    """Liste les scans r√©cents"""
    
    all_scans = []
    
    # Ajouter les scans actifs
    for scan_id, scan_info in active_scans.items():
        all_scans.append({
            "scan_id": scan_id,
            "target": scan_info["target"],
            "scan_type": scan_info["scan_type"],
            "status": scan_info["status"],
            "start_time": scan_info["start_time"],
            "duration": (datetime.now() - scan_info["start_time"]).total_seconds()
        })
    
    # Ajouter les scans termin√©s
    for scan_id, scan_result in completed_scans.items():
        all_scans.append({
            "scan_id": scan_id,
            "target": scan_result.target,
            "scan_type": scan_result.scan_type,
            "status": "completed",
            "start_time": scan_result.start_time,
            "duration": scan_result.duration,
            "vulnerabilities_count": len(scan_result.vulnerabilities)
        })
    
    # Trier par date de d√©but (plus r√©cent en premier)
    all_scans.sort(key=lambda x: x["start_time"], reverse=True)
    
    # Pagination
    paginated_scans = all_scans[offset:offset + limit]
    
    return {
        "scans": paginated_scans,
        "total": len(all_scans),
        "limit": limit,
        "offset": offset,
        "active_count": len(active_scans),
        "completed_count": len(completed_scans)
    }

@router.delete("/scan/{scan_id}")
async def delete_scan(scan_id: str):
    """Supprime un scan et ses r√©sultats"""
    
    deleted = False
    
    if scan_id in active_scans:
        del active_scans[scan_id]
        deleted = True
    
    if scan_id in completed_scans:
        del completed_scans[scan_id]
        deleted = True
    
    if not deleted:
        raise HTTPException(status_code=404, detail="Scan non trouv√©")
    
    return {"message": f"Scan {scan_id} supprim√© avec succ√®s"}

# Fonctions utilitaires priv√©es

async def execute_scan(scan_id: str, target: str, scan_type: ScanType, options: Dict):
    """Ex√©cute le scan en arri√®re-plan"""
    
    try:
        # Mettre √† jour le statut
        active_scans[scan_id]["status"] = "running"
        
        # Ex√©cuter le scan
        async with PentestScanner() as scanner:
            vulnerabilities = await scanner.scan_target(target, scan_type, options)
        
        # Cr√©er le r√©sultat
        end_time = datetime.now()
        start_time = active_scans[scan_id]["start_time"]
        duration = (end_time - start_time).total_seconds()
        
        # Calculer le r√©sum√© des vuln√©rabilit√©s
        summary = {
            "critical": len([v for v in vulnerabilities if v.level.value == "critical"]),
            "high": len([v for v in vulnerabilities if v.level.value == "high"]),
            "medium": len([v for v in vulnerabilities if v.level.value == "medium"]),
            "low": len([v for v in vulnerabilities if v.level.value == "low"]),
            "info": len([v for v in vulnerabilities if v.level.value == "info"]),
            "total": len(vulnerabilities)
        }
        
        scan_result = ScanResult(
            scan_id=scan_id,
            target=target,
            scan_type=scan_type,
            status="completed",
            start_time=start_time,
            end_time=end_time,
            duration=duration,
            vulnerabilities=vulnerabilities,
            summary=summary,
            metadata={
                "scanner_version": "1.0.0",
                "scan_options": options
            }
        )
        
        # D√©placer vers les scans termin√©s
        completed_scans[scan_id] = scan_result
        del active_scans[scan_id]
        
        # Sauvegarder en base de donn√©es si possible
        try:
            db = await get_database()
            await db.save_scan_result(scan_result.dict())
        except:
            pass  # Continuer m√™me si la sauvegarde √©choue
            
    except Exception as e:
        # Marquer le scan comme √©chou√©
        active_scans[scan_id]["status"] = "failed"
        active_scans[scan_id]["error"] = str(e)
        print(f"Erreur lors du scan {scan_id}: {e}")

def _estimate_progress(status: str, duration: float) -> int:
    """Estime le pourcentage de progression"""
    if status == "starting":
        return 5
    elif status == "running":
        # Progression bas√©e sur le temps (estimation 3 minutes max)
        return min(95, 10 + int((duration / 180) * 85))
    elif status == "completed":
        return 100
    elif status == "failed":
        return 0
    else:
        return 0

def _get_status_message(status: str) -> str:
    """Messages de statut conviviaux"""
    messages = {
        "starting": "Initialisation du scan...",
        "running": "Scan en cours - Analyse des vuln√©rabilit√©s...",
        "completed": "Scan termin√© avec succ√®s",
        "failed": "Erreur lors du scan"
    }
    return messages.get(status, "Statut inconnu")

def _generate_recommendations(vulnerabilities: List[Vulnerability]) -> List[str]:
    """G√©n√®re des recommandations bas√©es sur les vuln√©rabilit√©s"""
    recommendations = []
    
    critical_count = len([v for v in vulnerabilities if v.level.value == "critical"])
    high_count = len([v for v in vulnerabilities if v.level.value == "high"])
    
    if critical_count > 0:
        recommendations.append(f"üö® URGENT: {critical_count} vuln√©rabilit√©e(s) critiques d√©tect√©es - correction imm√©diate requise")
    
    if high_count > 0:
        recommendations.append(f"‚ö†Ô∏è PRIORIT√â: {high_count} vuln√©rabilit√©s √† risque √©lev√© √† corriger rapidement")
    
    # Recommandations sp√©cifiques selon les types de vuln√©rabilit√©s
    vuln_types = [v.owasp_category for v in vulnerabilities if v.owasp_category]
    
    if any("Injection" in vtype for vtype in vuln_types):
        recommendations.append("üîç Impl√©menter la validation stricte des entr√©es et les requ√™tes pr√©par√©es")
    
    if any("Cryptographic" in vtype for vtype in vuln_types):
        recommendations.append("üîê Renforcer la configuration SSL/TLS et le chiffrement des donn√©es")
    
    if any("Access Control" in vtype for vtype in vuln_types):
        recommendations.append("üõ°Ô∏è R√©viser les contr√¥les d'acc√®s et les permissions")
    
    return recommendations

def _suggest_next_steps(vulnerabilities: List[Vulnerability]) -> List[str]:
    """Sugg√®re les prochaines √©tapes"""
    next_steps = [
        "1. R√©viser et prioriser les vuln√©rabilit√©s par niveau de risque",
        "2. Planifier la correction des vuln√©rabilit√©s critiques et √©lev√©es",
        "3. Tester les corrections dans un environnement de staging",
        "4. Effectuer un nouveau scan pour valider les corrections",
        "5. Mettre √† jour la documentation de s√©curit√©"
    ]
    
    if vulnerabilities:
        next_steps.append("6. Consid√©rer un audit de s√©curit√© compl√©mentaire si n√©cessaire")
    
    return next_steps