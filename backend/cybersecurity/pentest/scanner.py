# Scanner de vulnérabilités pour pentesting
import asyncio
import aiohttp
import re
import socket
import ssl
import subprocess
import json
from datetime import datetime
from typing import List, Dict, Any
from urllib.parse import urlparse, urljoin
from .models import Vulnerability, VulnerabilityLevel, ScanType

class PentestScanner:
    """Scanner principal pour les tests de pénétration"""
    
    def __init__(self):
        self.session = None
        
    async def __aenter__(self):
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=30),
            headers={'User-Agent': 'CyberSec Toolkit Pro 2025'}
        )
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    async def scan_target(self, target: str, scan_type: ScanType, options: Dict = None) -> List[Vulnerability]:
        """Lance un scan selon le type"""
        if options is None:
            options = {}
            
        vulnerabilities = []
        
        if scan_type == ScanType.WEB or scan_type == ScanType.OWASP:
            vulnerabilities.extend(await self._scan_web_vulnerabilities(target, options))
            
        if scan_type == ScanType.SSL:
            vulnerabilities.extend(await self._scan_ssl_vulnerabilities(target, options))
            
        if scan_type == ScanType.PORTS:
            vulnerabilities.extend(await self._scan_port_vulnerabilities(target, options))
            
        if scan_type == ScanType.NETWORK:
            vulnerabilities.extend(await self._scan_network_vulnerabilities(target, options))
            
        return vulnerabilities

    async def _scan_web_vulnerabilities(self, target: str, options: Dict) -> List[Vulnerability]:
        """Scan des vulnérabilités web OWASP Top 10"""
        vulnerabilities = []
        
        if not self.session:
            return vulnerabilities
            
        try:
            # Test 1: SQL Injection
            vulnerabilities.extend(await self._test_sql_injection(target))
            
            # Test 2: XSS (Cross-Site Scripting)
            vulnerabilities.extend(await self._test_xss(target))
            
            # Test 3: Headers de sécurité manquants
            vulnerabilities.extend(await self._test_security_headers(target))
            
            # Test 4: HTTPS et configuration SSL
            vulnerabilities.extend(await self._test_https_config(target))
            
            # Test 5: Information Disclosure
            vulnerabilities.extend(await self._test_information_disclosure(target))
            
        except Exception as e:
            print(f"Erreur lors du scan web: {e}")
            
        return vulnerabilities

    async def _test_sql_injection(self, target: str) -> List[Vulnerability]:
        """Test d'injection SQL"""
        vulnerabilities = []
        sql_payloads = [
            "' OR '1'='1",
            "' UNION SELECT NULL--",
            "'; DROP TABLE users--",
            "' OR 1=1#"
        ]
        
        try:
            # Tester sur différents paramètres
            test_params = ['id', 'user', 'search', 'q', 'name']
            
            for param in test_params:
                for payload in sql_payloads:
                    test_url = f"{target}?{param}={payload}"
                    
                    try:
                        async with self.session.get(test_url) as response:
                            content = await response.text()
                            
                            # Détection d'erreurs SQL
                            sql_errors = [
                                "mysql_fetch_array",
                                "ORA-01756",
                                "Microsoft OLE DB",
                                "SQLServer JDBC Driver",
                                "PostgreSQL query failed",
                                "sqlite3.OperationalError"
                            ]
                            
                            if any(error.lower() in content.lower() for error in sql_errors):
                                vulnerabilities.append(Vulnerability(
                                    id=f"sqli_{param}_{len(vulnerabilities)}",
                                    title="Injection SQL Détectée",
                                    description=f"Vulnérabilité d'injection SQL détectée sur le paramètre '{param}'",
                                    level=VulnerabilityLevel.HIGH,
                                    url=test_url,
                                    request=f"GET {test_url}",
                                    remediation="Utiliser des requêtes préparées et valider les entrées utilisateur",
                                    owasp_category="A03:2021 – Injection",
                                    references=[
                                        "https://owasp.org/Top10/A03_2021-Injection/",
                                        "https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"
                                    ]
                                ))
                                break
                                
                    except Exception as e:
                        continue
                        
        except Exception as e:
            print(f"Erreur test SQL injection: {e}")
            
        return vulnerabilities

    async def _test_xss(self, target: str) -> List[Vulnerability]:
        """Test de Cross-Site Scripting"""
        vulnerabilities = []
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "'\"><script>alert('XSS')</script>"
        ]
        
        try:
            test_params = ['q', 'search', 'name', 'comment', 'message']
            
            for param in test_params:
                for payload in xss_payloads:
                    test_url = f"{target}?{param}={payload}"
                    
                    try:
                        async with self.session.get(test_url) as response:
                            content = await response.text()
                            
                            # Détection de XSS réfléchi
                            if payload in content and response.headers.get('content-type', '').startswith('text/html'):
                                vulnerabilities.append(Vulnerability(
                                    id=f"xss_{param}_{len(vulnerabilities)}",
                                    title="Cross-Site Scripting (XSS) Réfléchi",
                                    description=f"Vulnérabilité XSS réfléchie détectée sur le paramètre '{param}'",
                                    level=VulnerabilityLevel.HIGH,
                                    url=test_url,
                                    request=f"GET {test_url}",
                                    remediation="Encoder les sorties, valider les entrées et implémenter CSP",
                                    owasp_category="A03:2021 – Injection",
                                    references=[
                                        "https://owasp.org/www-community/attacks/xss/",
                                        "https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"
                                    ]
                                ))
                                break
                                
                    except Exception as e:
                        continue
                        
        except Exception as e:
            print(f"Erreur test XSS: {e}")
            
        return vulnerabilities

    async def _test_security_headers(self, target: str) -> List[Vulnerability]:
        """Test des headers de sécurité"""
        vulnerabilities = []
        
        try:
            async with self.session.get(target) as response:
                headers = response.headers
                
                # Headers de sécurité critiques
                security_headers = {
                    'X-Frame-Options': {
                        'level': VulnerabilityLevel.MEDIUM,
                        'description': 'Header X-Frame-Options manquant - risque de Clickjacking'
                    },
                    'X-Content-Type-Options': {
                        'level': VulnerabilityLevel.LOW,
                        'description': 'Header X-Content-Type-Options manquant - risque de MIME sniffing'
                    },
                    'X-XSS-Protection': {
                        'level': VulnerabilityLevel.LOW,
                        'description': 'Header X-XSS-Protection manquant - protection XSS désactivée'
                    },
                    'Strict-Transport-Security': {
                        'level': VulnerabilityLevel.HIGH if target.startswith('https') else VulnerabilityLevel.INFO,
                        'description': 'Header HSTS manquant - risque de downgrade attack'
                    },
                    'Content-Security-Policy': {
                        'level': VulnerabilityLevel.MEDIUM,
                        'description': 'Content Security Policy manquante - risque XSS et injection de contenu'
                    }
                }
                
                for header, config in security_headers.items():
                    if header not in headers:
                        vulnerabilities.append(Vulnerability(
                            id=f"missing_header_{header.lower().replace('-', '_')}",
                            title=f"Header de Sécurité Manquant: {header}",
                            description=config['description'],
                            level=config['level'],
                            url=target,
                            remediation=f"Ajouter le header {header} avec une valeur appropriée",
                            owasp_category="A05:2021 – Security Misconfiguration",
                            references=[
                                "https://owasp.org/www-project-secure-headers/",
                                f"https://developer.mozilla.org/docs/Web/HTTP/Headers/{header}"
                            ]
                        ))
                        
        except Exception as e:
            print(f"Erreur test headers: {e}")
            
        return vulnerabilities

    async def _test_https_config(self, target: str) -> List[Vulnerability]:
        """Test de la configuration HTTPS/SSL"""
        vulnerabilities = []
        
        if not target.startswith('https://'):
            vulnerabilities.append(Vulnerability(
                id="http_only",
                title="Site Non Chiffré (HTTP)",
                description="Le site n'utilise pas HTTPS - les données sont transmises en clair",
                level=VulnerabilityLevel.HIGH,
                url=target,
                remediation="Implémenter HTTPS avec un certificat SSL/TLS valide et rediriger HTTP vers HTTPS",
                owasp_category="A02:2021 – Cryptographic Failures",
                references=[
                    "https://owasp.org/www-project-transport-layer-protection-cheat-sheet/",
                    "https://letsencrypt.org/"
                ]
            ))
            return vulnerabilities
            
        # Test supplémentaire pour HTTPS
        try:
            parsed = urlparse(target)
            hostname = parsed.hostname
            port = parsed.port or 443
            
            context = ssl.create_default_context()
            
            with socket.create_connection((hostname, port), timeout=10) as sock:
                with context.wrap_socket(sock, server_hostname=hostname) as ssock:
                    cert = ssock.getpeercert()
                    
                    # Vérifier l'expiration du certificat
                    not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    days_until_expiry = (not_after - datetime.now()).days
                    
                    if days_until_expiry < 30:
                        level = VulnerabilityLevel.CRITICAL if days_until_expiry < 0 else VulnerabilityLevel.HIGH
                        vulnerabilities.append(Vulnerability(
                            id="cert_expiry",
                            title="Certificat SSL Expiré ou Proche de l'Expiration",
                            description=f"Le certificat SSL expire {'dans' if days_until_expiry > 0 else 'depuis'} {abs(days_until_expiry)} jours",
                            level=level,
                            url=target,
                            remediation="Renouveler le certificat SSL avant expiration",
                            owasp_category="A02:2021 – Cryptographic Failures"
                        ))
                        
        except Exception as e:
            print(f"Erreur test HTTPS: {e}")
            
        return vulnerabilities

    async def _test_information_disclosure(self, target: str) -> List[Vulnerability]:
        """Test de divulgation d'informations"""
        vulnerabilities = []
        
        # Fichiers sensibles à tester
        sensitive_files = [
            '/robots.txt',
            '/.env',
            '/backup.sql',
            '/config.php',
            '/.git/config',
            '/admin',
            '/phpinfo.php',
            '/.htaccess',
            '/sitemap.xml'
        ]
        
        try:
            base_url = target.rstrip('/')
            
            for file_path in sensitive_files:
                test_url = base_url + file_path
                
                try:
                    async with self.session.get(test_url) as response:
                        if response.status == 200:
                            content = await response.text()
                            
                            # Détecter le type de divulgation
                            if file_path == '/.env' and ('password' in content.lower() or 'secret' in content.lower()):
                                vulnerabilities.append(Vulnerability(
                                    id=f"info_disclosure_{file_path.replace('/', '_').replace('.', '')}",
                                    title="Fichier .env Accessible",
                                    description="Le fichier .env contenant des informations sensibles est accessible publiquement",
                                    level=VulnerabilityLevel.CRITICAL,
                                    url=test_url,
                                    remediation="Déplacer le fichier .env hors du répertoire web et configurer le serveur",
                                    owasp_category="A01:2021 – Broken Access Control"
                                ))
                            elif file_path == '/.git/config':
                                vulnerabilities.append(Vulnerability(
                                    id="git_exposure",
                                    title="Répertoire .git Exposé",
                                    description="Le répertoire .git est accessible, révélant le code source et l'historique",
                                    level=VulnerabilityLevel.HIGH,
                                    url=test_url,
                                    remediation="Bloquer l'accès au répertoire .git via la configuration serveur",
                                    owasp_category="A01:2021 – Broken Access Control"
                                ))
                            elif 'phpinfo()' in content:
                                vulnerabilities.append(Vulnerability(
                                    id="phpinfo_exposure",
                                    title="Page phpinfo() Exposée",
                                    description="La page phpinfo() révèle des informations sensibles sur la configuration du serveur",
                                    level=VulnerabilityLevel.MEDIUM,
                                    url=test_url,
                                    remediation="Supprimer la page phpinfo() de l'environnement de production",
                                    owasp_category="A05:2021 – Security Misconfiguration"
                                ))
                                
                except Exception as e:
                    continue
                    
        except Exception as e:
            print(f"Erreur test information disclosure: {e}")
            
        return vulnerabilities

    async def _scan_ssl_vulnerabilities(self, target: str, options: Dict) -> List[Vulnerability]:
        """Scan spécialisé SSL/TLS"""
        # Implementation simplifiée - dans un vrai projet, utiliser des outils comme SSLyze
        return []

    async def _scan_port_vulnerabilities(self, target: str, options: Dict) -> List[Vulnerability]:
        """Scan des ports (simulation simple)"""
        vulnerabilities = []
        
        try:
            parsed = urlparse(target if target.startswith('http') else f'http://{target}')
            hostname = parsed.hostname or target
            
            # Ports communs à scanner
            common_ports = [21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 1433, 3306, 3389, 5432, 6379]
            
            open_ports = []
            for port in common_ports:
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(1)
                    result = sock.connect_ex((hostname, port))
                    sock.close()
                    
                    if result == 0:
                        open_ports.append(port)
                except:
                    continue
            
            if len(open_ports) > 5:  # Beaucoup de ports ouverts
                vulnerabilities.append(Vulnerability(
                    id="many_open_ports",
                    title="Nombreux Ports Ouverts",
                    description=f"Ports ouverts détectés: {', '.join(map(str, open_ports))}",
                    level=VulnerabilityLevel.MEDIUM,
                    url=f"{hostname}:{','.join(map(str, open_ports))}",
                    remediation="Fermer les ports non nécessaires et configurer un firewall",
                    owasp_category="A05:2021 – Security Misconfiguration"
                ))
                
        except Exception as e:
            print(f"Erreur scan ports: {e}")
            
        return vulnerabilities

    async def _scan_network_vulnerabilities(self, target: str, options: Dict) -> List[Vulnerability]:
        """Scan réseau basique"""
        # Implementation basique - dans un vrai projet, intégrer Nmap
        return []