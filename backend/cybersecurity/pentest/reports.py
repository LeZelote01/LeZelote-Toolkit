# Générateur de rapports pour le service Pentesting
import os
import json
from datetime import datetime
from pathlib import Path
from typing import Dict, Optional
from reportlab.lib.pagesizes import A4
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib import colors
from reportlab.lib.enums import TA_CENTER, TA_LEFT, TA_RIGHT

from .models import ScanResult, VulnerabilityLevel

class ReportGenerator:
    """Générateur de rapports de pentest"""
    
    def __init__(self):
        self.styles = getSampleStyleSheet()
        self._setup_custom_styles()
        
    def _setup_custom_styles(self):
        """Configure les styles personnalisés"""
        # Style titre principal
        self.styles.add(ParagraphStyle(
            name='MainTitle',
            parent=self.styles['Heading1'],
            fontSize=24,
            textColor=colors.darkblue,
            alignment=TA_CENTER,
            spaceAfter=30
        ))
        
        # Style sous-titre
        self.styles.add(ParagraphStyle(
            name='SubTitle',
            parent=self.styles['Heading2'],
            fontSize=16,
            textColor=colors.darkred,
            spaceAfter=20
        ))
        
        # Style vulnérabilité critique
        self.styles.add(ParagraphStyle(
            name='Critical',
            parent=self.styles['Normal'],
            textColor=colors.red,
            fontSize=12,
            leftIndent=20
        ))
        
        # Style vulnérabilité élevée
        self.styles.add(ParagraphStyle(
            name='High',
            parent=self.styles['Normal'],
            textColor=colors.orange,
            fontSize=12,
            leftIndent=20
        ))

    async def generate_report(
        self, 
        scan_result: ScanResult, 
        format: str = "pdf",
        template: str = "standard",
        branding: Optional[Dict[str, str]] = None
    ) -> str:
        """Génère un rapport de scan"""
        
        # Créer le dossier reports s'il n'existe pas
        reports_dir = Path("/app/portable/reports")
        reports_dir.mkdir(parents=True, exist_ok=True)
        
        # Nom du fichier
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"pentest_report_{scan_result.scan_id[:8]}_{timestamp}"
        
        if format.lower() == "pdf":
            return await self._generate_pdf_report(scan_result, reports_dir / f"{filename}.pdf", template, branding)
        elif format.lower() == "html":
            return await self._generate_html_report(scan_result, reports_dir / f"{filename}.html", template, branding)
        elif format.lower() == "json":
            return await self._generate_json_report(scan_result, reports_dir / f"{filename}.json")
        else:
            raise ValueError(f"Format de rapport non supporté: {format}")

    async def _generate_pdf_report(
        self, 
        scan_result: ScanResult, 
        output_path: Path,
        template: str,
        branding: Optional[Dict[str, str]]
    ) -> str:
        """Génère un rapport PDF"""
        
        doc = SimpleDocTemplate(
            str(output_path),
            pagesize=A4,
            topMargin=0.5*inch,
            bottomMargin=0.5*inch,
            leftMargin=0.5*inch,
            rightMargin=0.5*inch
        )
        
        story = []
        
        # En-tête avec branding
        story.extend(self._create_header(scan_result, branding))
        
        # Résumé exécutif
        story.extend(self._create_executive_summary(scan_result))
        
        # Détails techniques
        story.extend(self._create_technical_details(scan_result))
        
        # Vulnérabilités détaillées
        story.extend(self._create_vulnerabilities_section(scan_result))
        
        # Recommandations
        story.extend(self._create_recommendations_section(scan_result))
        
        # Annexes
        story.extend(self._create_appendices(scan_result))
        
        # Générer le PDF
        doc.build(story)
        
        return str(output_path)

    def _create_header(self, scan_result: ScanResult, branding: Optional[Dict[str, str]]) -> list:
        """Crée l'en-tête du rapport"""
        elements = []
        
        # Titre principal
        company_name = branding.get("company_name", "CyberSec Toolkit Pro 2025") if branding else "CyberSec Toolkit Pro 2025"
        elements.append(Paragraph(f"<b>{company_name}</b>", self.styles['MainTitle']))
        
        # Sous-titre
        elements.append(Paragraph("RAPPORT DE TEST DE PÉNÉTRATION", self.styles['SubTitle']))
        
        # Informations du scan
        scan_info = [
            ["Cible:", scan_result.target],
            ["Type de scan:", scan_result.scan_type.value.upper()],
            ["Date du scan:", scan_result.start_time.strftime("%d/%m/%Y %H:%M")],
            ["Durée:", f"{scan_result.duration:.1f} secondes" if scan_result.duration else "N/A"],
            ["ID du scan:", scan_result.scan_id[:8]]
        ]
        
        info_table = Table(scan_info, colWidths=[2*inch, 4*inch])
        info_table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), colors.lightgrey),
            ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 6),
            ('GRID', (0, 0), (-1, -1), 1, colors.black)
        ]))
        
        elements.append(info_table)
        elements.append(Spacer(1, 20))
        
        return elements

    def _create_executive_summary(self, scan_result: ScanResult) -> list:
        """Crée le résumé exécutif"""
        elements = []
        
        elements.append(Paragraph("RÉSUMÉ EXÉCUTIF", self.styles['Heading1']))
        
        # Résumé des vulnérabilités
        summary = scan_result.summary
        total_vulns = summary.get('total', 0)
        
        if total_vulns == 0:
            summary_text = """
            <b>RÉSULTAT POSITIF:</b> Aucune vulnérabilité critique n'a été détectée lors de ce scan de pénétration.
            Cependant, il est recommandé de maintenir une surveillance continue et d'effectuer des tests réguliers.
            """
        else:
            critical = summary.get('critical', 0)
            high = summary.get('high', 0)
            medium = summary.get('medium', 0)
            low = summary.get('low', 0)
            
            risk_level = "CRITIQUE" if critical > 0 else "ÉLEVÉ" if high > 0 else "MOYEN" if medium > 0 else "FAIBLE"
            
            summary_text = f"""
            <b>NIVEAU DE RISQUE: {risk_level}</b><br/><br/>
            
            Ce rapport présente les résultats du test de pénétration effectué sur <b>{scan_result.target}</b>.
            Au total, <b>{total_vulns}</b> vulnérabilités ont été identifiées:<br/><br/>
            
            • <b><font color="red">Critiques: {critical}</font></b><br/>
            • <b><font color="orange">Élevées: {high}</font></b><br/>
            • <b>Moyennes: {medium}</b><br/>
            • <b>Faibles: {low}</b><br/><br/>
            
            {"<b>ACTION IMMÉDIATE REQUISE</b> pour les vulnérabilités critiques." if critical > 0 else ""}
            """
        
        elements.append(Paragraph(summary_text, self.styles['Normal']))
        elements.append(Spacer(1, 20))
        
        return elements

    def _create_technical_details(self, scan_result: ScanResult) -> list:
        """Crée la section des détails techniques"""
        elements = []
        
        elements.append(Paragraph("DÉTAILS TECHNIQUES", self.styles['Heading1']))
        
        # Méthodologie
        methodology_text = f"""
        <b>Type de scan:</b> {scan_result.scan_type.value.upper()}<br/>
        <b>Approche:</b> Test de pénétration automatisé avec CyberSec Toolkit Pro 2025<br/>
        <b>Standards:</b> OWASP Top 10, NIST Cybersecurity Framework<br/>
        <b>Outils:</b> Scanner intégré avec détection avancée des vulnérabilités
        """
        
        elements.append(Paragraph(methodology_text, self.styles['Normal']))
        elements.append(Spacer(1, 15))
        
        # Chronologie
        if scan_result.start_time and scan_result.end_time:
            timeline_data = [
                ["Début du scan", scan_result.start_time.strftime("%d/%m/%Y %H:%M:%S")],
                ["Fin du scan", scan_result.end_time.strftime("%d/%m/%Y %H:%M:%S")],
                ["Durée totale", f"{scan_result.duration:.1f} secondes"]
            ]
            
            timeline_table = Table(timeline_data, colWidths=[2*inch, 3*inch])
            timeline_table.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (0, -1), colors.lightblue),
                ('TEXTCOLOR', (0, 0), (-1, -1), colors.black),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
                ('FONTSIZE', (0, 0), (-1, -1), 9),
                ('GRID', (0, 0), (-1, -1), 1, colors.black)
            ]))
            
            elements.append(Paragraph("<b>Chronologie du scan:</b>", self.styles['Normal']))
            elements.append(timeline_table)
            elements.append(Spacer(1, 20))
        
        return elements

    def _create_vulnerabilities_section(self, scan_result: ScanResult) -> list:
        """Crée la section des vulnérabilités"""
        elements = []
        
        elements.append(Paragraph("VULNÉRABILITÉS DÉTECTÉES", self.styles['Heading1']))
        
        if not scan_result.vulnerabilities:
            elements.append(Paragraph("Aucune vulnérabilité détectée.", self.styles['Normal']))
            return elements
        
        # Grouper par niveau de sévérité
        vulns_by_level = {
            'critical': [v for v in scan_result.vulnerabilities if v.level == VulnerabilityLevel.CRITICAL],
            'high': [v for v in scan_result.vulnerabilities if v.level == VulnerabilityLevel.HIGH],
            'medium': [v for v in scan_result.vulnerabilities if v.level == VulnerabilityLevel.MEDIUM],
            'low': [v for v in scan_result.vulnerabilities if v.level == VulnerabilityLevel.LOW],
            'info': [v for v in scan_result.vulnerabilities if v.level == VulnerabilityLevel.INFO]
        }
        
        level_names = {
            'critical': 'CRITIQUES',
            'high': 'ÉLEVÉES', 
            'medium': 'MOYENNES',
            'low': 'FAIBLES',
            'info': 'INFORMATIVES'
        }
        
        level_colors = {
            'critical': colors.red,
            'high': colors.orange,
            'medium': colors.yellow,
            'low': colors.lightblue,
            'info': colors.lightgrey
        }
        
        for level, vulns in vulns_by_level.items():
            if not vulns:
                continue
                
            # Titre de section
            elements.append(Paragraph(
                f"<font color='{level_colors[level]}'>{level_names[level]} ({len(vulns)})</font>", 
                self.styles['Heading2']
            ))
            
            # Détailler chaque vulnérabilité
            for i, vuln in enumerate(vulns, 1):
                elements.append(Paragraph(f"<b>{i}. {vuln.title}</b>", self.styles['Heading3']))
                elements.append(Paragraph(f"<b>Description:</b> {vuln.description}", self.styles['Normal']))
                
                if vuln.url:
                    elements.append(Paragraph(f"<b>URL affectée:</b> {vuln.url}", self.styles['Normal']))
                
                if vuln.cve_id:
                    elements.append(Paragraph(f"<b>CVE:</b> {vuln.cve_id}", self.styles['Normal']))
                
                if vuln.cvss_score:
                    elements.append(Paragraph(f"<b>Score CVSS:</b> {vuln.cvss_score}", self.styles['Normal']))
                
                if vuln.owasp_category:
                    elements.append(Paragraph(f"<b>Catégorie OWASP:</b> {vuln.owasp_category}", self.styles['Normal']))
                
                elements.append(Paragraph(f"<b>Remédiation:</b> {vuln.remediation}", self.styles['Normal']))
                
                if vuln.references:
                    refs_text = "<br/>".join([f"• {ref}" for ref in vuln.references])
                    elements.append(Paragraph(f"<b>Références:</b><br/>{refs_text}", self.styles['Normal']))
                
                elements.append(Spacer(1, 15))
        
        return elements

    def _create_recommendations_section(self, scan_result: ScanResult) -> list:
        """Crée la section des recommandations"""
        elements = []
        
        elements.append(Paragraph("RECOMMANDATIONS", self.styles['Heading1']))
        
        if not scan_result.vulnerabilities:
            recommendations_text = """
            <b>Maintenir le niveau de sécurité:</b><br/>
            • Continuer les tests de pénétration réguliers<br/>
            • Maintenir les systèmes à jour<br/>
            • Surveiller les nouvelles vulnérabilités<br/>
            • Former l'équipe aux bonnes pratiques de sécurité
            """
        else:
            critical_count = len([v for v in scan_result.vulnerabilities if v.level == VulnerabilityLevel.CRITICAL])
            high_count = len([v for v in scan_result.vulnerabilities if v.level == VulnerabilityLevel.HIGH])
            
            recommendations_text = f"""
            <b>Actions prioritaires:</b><br/>
            {"• <font color='red'>URGENT: Corriger les " + str(critical_count) + " vulnérabilités critiques immédiatement</font><br/>" if critical_count > 0 else ""}
            {"• <font color='orange'>Traiter les " + str(high_count) + " vulnérabilités élevées dans les 7 jours</font><br/>" if high_count > 0 else ""}
            • Planifier la correction des vulnérabilités moyennes et faibles<br/>
            • Effectuer un nouveau scan après les corrections<br/>
            • Mettre en place une surveillance continue<br/>
            • Réviser les procédures de développement sécurisé
            """
        
        elements.append(Paragraph(recommendations_text, self.styles['Normal']))
        elements.append(Spacer(1, 20))
        
        return elements

    def _create_appendices(self, scan_result: ScanResult) -> list:
        """Crée les annexes"""
        elements = []
        
        elements.append(Paragraph("ANNEXES", self.styles['Heading1']))
        
        # Métadonnées du scan
        if scan_result.metadata:
            elements.append(Paragraph("Informations techniques:", self.styles['Heading2']))
            
            for key, value in scan_result.metadata.items():
                elements.append(Paragraph(f"<b>{key}:</b> {value}", self.styles['Normal']))
        
        # Footer
        elements.append(Spacer(1, 30))
        elements.append(Paragraph(
            f"Rapport généré par CyberSec Toolkit Pro 2025 le {datetime.now().strftime('%d/%m/%Y à %H:%M')}",
            self.styles['Normal']
        ))
        
        return elements

    async def _generate_html_report(self, scan_result: ScanResult, output_path: Path, template: str, branding: Optional[Dict[str, str]]) -> str:
        """Génère un rapport HTML"""
        
        company_name = branding.get("company_name", "CyberSec Toolkit Pro 2025") if branding else "CyberSec Toolkit Pro 2025"
        
        html_content = f"""
        <!DOCTYPE html>
        <html lang="fr">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Rapport de Test de Pénétration - {scan_result.target}</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; line-height: 1.6; }}
                .header {{ text-align: center; border-bottom: 2px solid #333; padding-bottom: 20px; }}
                .critical {{ color: #d32f2f; font-weight: bold; }}
                .high {{ color: #f57c00; font-weight: bold; }}
                .medium {{ color: #fbc02d; font-weight: bold; }}
                .low {{ color: #1976d2; }}
                .info {{ color: #666; }}
                table {{ border-collapse: collapse; width: 100%; margin: 20px 0; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
            </style>
        </head>
        <body>
            <div class="header">
                <h1>{company_name}</h1>
                <h2>RAPPORT DE TEST DE PÉNÉTRATION</h2>
                <p>Cible: {scan_result.target} | Date: {scan_result.start_time.strftime('%d/%m/%Y %H:%M')}</p>
            </div>
            
            <h2>Résumé des Vulnérabilités</h2>
            <table>
                <tr><th>Niveau</th><th>Nombre</th></tr>
                <tr><td class="critical">Critiques</td><td>{scan_result.summary.get('critical', 0)}</td></tr>
                <tr><td class="high">Élevées</td><td>{scan_result.summary.get('high', 0)}</td></tr>
                <tr><td class="medium">Moyennes</td><td>{scan_result.summary.get('medium', 0)}</td></tr>
                <tr><td class="low">Faibles</td><td>{scan_result.summary.get('low', 0)}</td></tr>
                <tr><td class="info">Info</td><td>{scan_result.summary.get('info', 0)}</td></tr>
            </table>
        """
        
        # Ajouter les vulnérabilités détaillées
        if scan_result.vulnerabilities:
            html_content += "<h2>Vulnérabilités Détectées</h2>"
            
            for vuln in scan_result.vulnerabilities:
                level_class = vuln.level.value
                html_content += f"""
                <div style="margin: 20px 0; border-left: 4px solid {'#d32f2f' if level_class == 'critical' else '#f57c00' if level_class == 'high' else '#fbc02d' if level_class == 'medium' else '#1976d2'}; padding-left: 15px;">
                    <h3 class="{level_class}">{vuln.title}</h3>
                    <p><strong>Niveau:</strong> <span class="{level_class}">{vuln.level.value.upper()}</span></p>
                    <p><strong>Description:</strong> {vuln.description}</p>
                    {f'<p><strong>URL:</strong> {vuln.url}</p>' if vuln.url else ''}
                    <p><strong>Remédiation:</strong> {vuln.remediation}</p>
                </div>
                """
        
        html_content += f"""
            <footer style="margin-top: 50px; border-top: 1px solid #ccc; padding-top: 20px; text-align: center; color: #666;">
                Rapport généré par CyberSec Toolkit Pro 2025 le {datetime.now().strftime('%d/%m/%Y à %H:%M')}
            </footer>
        </body>
        </html>
        """
        
        # Écrire le fichier HTML
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        return str(output_path)

    async def _generate_json_report(self, scan_result: ScanResult, output_path: Path) -> str:
        """Génère un rapport JSON"""
        
        report_data = {
            "report_metadata": {
                "generated_at": datetime.now().isoformat(),
                "generator": "CyberSec Toolkit Pro 2025",
                "version": "1.0.0"
            },
            "scan_result": scan_result.dict()
        }
        
        # Écrire le fichier JSON
        with open(output_path, 'w', encoding='utf-8') as f:
            json.dump(report_data, f, indent=2, ensure_ascii=False, default=str)
        
        return str(output_path)