"""
Moteur de gestion des vulnérabilités
CyberSec Toolkit Pro 2025 - PORTABLE
"""
import uuid
import asyncio
from datetime import datetime, date, timedelta
from typing import List, Dict, Any, Optional
import re
from math import floor

from .models import (
    Vulnerability, VulnerabilityRequest, VulnerabilityUpdate, VulnerabilityAsset,
    VulnerabilityStatus, VulnerabilitySeverity, VulnerabilitySource, RiskLevel,
    RemediationAction, RemediationRequest, RemediationStatus, CVSSScore,
    VulnerabilityEvidence, VulnerabilityComment, VulnerabilityReport
)

class VulnerabilityEngine:
    """Moteur principal de gestion des vulnérabilités"""
    
    def __init__(self):
        self.cvss_patterns = self._load_cvss_patterns()
        self.sla_matrix = self._load_sla_matrix()
        self.risk_matrix = self._load_risk_matrix()
    
    def _load_cvss_patterns(self) -> Dict[str, Any]:
        """Charge les patterns CVSS pour le calcul automatique"""
        return {
            "vector_regex": re.compile(r"CVSS:3\.[01]/AV:[NALP]/AC:[LH]/PR:[NLH]/UI:[NR]/S:[UC]/C:[HLN]/I:[HLN]/A:[HLN]"),
            "metrics": {
                "AV": {"N": 0.85, "A": 0.62, "L": 0.55, "P": 0.2},
                "AC": {"L": 0.77, "H": 0.44},
                "PR": {"N": 0.85, "L": 0.62, "H": 0.27},
                "UI": {"N": 0.85, "R": 0.62},
                "S": {"U": 6.42, "C": 7.52},
                "C": {"H": 0.56, "L": 0.22, "N": 0},
                "I": {"H": 0.56, "L": 0.22, "N": 0},
                "A": {"H": 0.56, "L": 0.22, "N": 0}
            }
        }
    
    def _load_sla_matrix(self) -> Dict[str, int]:
        """Matrice SLA par sévérité (en jours)"""
        return {
            "critical": 1,   # 24h
            "high": 7,       # 1 semaine
            "medium": 30,    # 1 mois
            "low": 90,       # 3 mois
            "info": 180      # 6 mois
        }
    
    def _load_risk_matrix(self) -> Dict[str, Dict[str, str]]:
        """Matrice de calcul du risque business"""
        return {
            "critical": {"high": "critical", "medium": "critical", "low": "high"},
            "high": {"high": "critical", "medium": "high", "low": "medium"},
            "medium": {"high": "high", "medium": "medium", "low": "low"},
            "low": {"high": "medium", "medium": "low", "low": "acceptable"},
            "info": {"high": "low", "medium": "acceptable", "low": "acceptable"}
        }
    
    async def create_vulnerability(self, request: VulnerabilityRequest) -> Vulnerability:
        """Crée une nouvelle vulnérabilité"""
        vuln_id = str(uuid.uuid4())
        
        # Convertir les assets
        affected_assets = []
        for asset_data in request.affected_assets:
            asset = VulnerabilityAsset(
                id=asset_data.get("id", str(uuid.uuid4())),
                name=asset_data.get("name", "Unknown Asset"),
                type=asset_data.get("type", "unknown"),
                location=asset_data.get("location"),
                owner=asset_data.get("owner"),
                criticality=asset_data.get("criticality", "medium")
            )
            affected_assets.append(asset)
        
        # Calculer CVSS si fourni
        cvss_score = None
        if request.cvss_vector:
            cvss_score = await self._calculate_cvss_score(request.cvss_vector)
        
        # Déterminer le niveau de risque business
        risk_level = await self._calculate_business_risk(
            request.severity, 
            affected_assets, 
            cvss_score
        )
        
        # Calculer la date SLA
        sla_due_date = await self._calculate_sla_date(request.severity)
        
        # Créer la vulnérabilité
        vulnerability = Vulnerability(
            id=vuln_id,
            title=request.title,
            description=request.description,
            severity=request.severity,
            source=request.source,
            vulnerability_type=request.vulnerability_type,
            technical_details=request.technical_details,
            affected_assets=affected_assets,
            reproduction_steps=request.reproduction_steps,
            cvss=cvss_score,
            risk_level=risk_level,
            cwe_id=request.cwe_id,
            owasp_category=request.owasp_category,
            tags=request.tags,
            references=request.references,
            reported_by=request.reported_by,
            sla_due_date=sla_due_date,
            last_modified_by=request.reported_by,
            remediation_priority=await self._calculate_remediation_priority(request.severity, risk_level)
        )
        
        # Générer des actions de remédiation automatiques
        auto_actions = await self._generate_auto_remediation_actions(vulnerability)
        vulnerability.remediation_actions.extend(auto_actions)
        
        return vulnerability
    
    async def update_vulnerability(self, vuln_id: str, update: VulnerabilityUpdate, current_vuln: Vulnerability) -> Vulnerability:
        """Met à jour une vulnérabilité"""
        
        # Créer une copie de la vulnérabilité actuelle
        updated_vuln = current_vuln.copy(deep=True)
        updated_vuln.updated_at = datetime.now()
        updated_vuln.last_modified_by = update.updated_by
        
        # Appliquer les mises à jour
        if update.status is not None:
            old_status = updated_vuln.status
            updated_vuln.status = update.status
            
            # Ajouter un commentaire pour le changement de statut
            status_comment = VulnerabilityComment(
                id=str(uuid.uuid4()),
                author=update.updated_by,
                content=f"Statut changé de {old_status.value} à {update.status.value}",
                type="status_change"
            )
            updated_vuln.comments.append(status_comment)
            
            # Marquer comme fermée si statut final
            if update.status in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]:
                updated_vuln.closed_date = datetime.now()
        
        if update.assigned_to is not None:
            updated_vuln.assigned_to = update.assigned_to
            
        if update.severity is not None:
            updated_vuln.severity = update.severity
            # Recalculer SLA et priorité
            updated_vuln.sla_due_date = await self._calculate_sla_date(update.severity)
            updated_vuln.remediation_priority = await self._calculate_remediation_priority(
                update.severity, updated_vuln.risk_level
            )
            
        if update.remediation_priority is not None:
            updated_vuln.remediation_priority = update.remediation_priority
            
        if update.sla_due_date is not None:
            updated_vuln.sla_due_date = update.sla_due_date
            
        if update.tags is not None:
            updated_vuln.tags = update.tags
        
        return updated_vuln
    
    async def add_remediation_action(self, vuln_id: str, request: RemediationRequest) -> RemediationAction:
        """Ajoute une action de remédiation"""
        
        action = RemediationAction(
            id=str(uuid.uuid4()),
            title=request.title,
            description=request.description,
            type=request.type,
            priority=request.priority,
            estimated_effort=request.estimated_effort,
            assigned_to=request.assigned_to,
            due_date=request.due_date
        )
        
        return action
    
    async def add_evidence(self, vuln_id: str, evidence_data: Dict[str, Any]) -> VulnerabilityEvidence:
        """Ajoute une preuve à une vulnérabilité"""
        
        evidence = VulnerabilityEvidence(
            id=str(uuid.uuid4()),
            type=evidence_data.get("type", "manual"),
            description=evidence_data.get("description", ""),
            file_path=evidence_data.get("file_path"),
            content=evidence_data.get("content"),
            created_by=evidence_data.get("created_by", "system")
        )
        
        return evidence
    
    async def add_comment(self, vuln_id: str, comment_data: Dict[str, Any]) -> VulnerabilityComment:
        """Ajoute un commentaire à une vulnérabilité"""
        
        comment = VulnerabilityComment(
            id=str(uuid.uuid4()),
            author=comment_data.get("author", "anonymous"),
            content=comment_data.get("content", ""),
            type=comment_data.get("type", "comment"),
            is_internal=comment_data.get("is_internal", True)
        )
        
        return comment
    
    async def search_vulnerabilities(self, search_request: Dict[str, Any], all_vulns: List[Vulnerability]) -> List[Vulnerability]:
        """Recherche des vulnérabilités selon les critères"""
        
        filtered_vulns = all_vulns.copy()
        
        # Filtre par terme de recherche
        if search_request.get("query"):
            query = search_request["query"].lower()
            filtered_vulns = [
                v for v in filtered_vulns
                if query in v.title.lower() or query in v.description.lower()
                or query in v.technical_details.lower()
            ]
        
        # Filtre par sévérité
        if search_request.get("severity"):
            severities = search_request["severity"]
            filtered_vulns = [v for v in filtered_vulns if v.severity in severities]
        
        # Filtre par statut
        if search_request.get("status"):
            statuses = search_request["status"]
            filtered_vulns = [v for v in filtered_vulns if v.status in statuses]
        
        # Filtre par source
        if search_request.get("source"):
            sources = search_request["source"]
            filtered_vulns = [v for v in filtered_vulns if v.source in sources]
        
        # Filtre par assigné
        if search_request.get("assigned_to"):
            assigned_to = search_request["assigned_to"]
            filtered_vulns = [v for v in filtered_vulns if v.assigned_to == assigned_to]
        
        # Filtre par tags
        if search_request.get("tags"):
            tags = set(search_request["tags"])
            filtered_vulns = [
                v for v in filtered_vulns 
                if tags.intersection(set(v.tags))
            ]
        
        # Filtre par dates
        if search_request.get("date_from"):
            date_from = search_request["date_from"]
            filtered_vulns = [v for v in filtered_vulns if v.discovered_date.date() >= date_from]
            
        if search_request.get("date_to"):
            date_to = search_request["date_to"]
            filtered_vulns = [v for v in filtered_vulns if v.discovered_date.date() <= date_to]
        
        # Filtre par asset
        if search_request.get("asset_id"):
            asset_id = search_request["asset_id"]
            filtered_vulns = [
                v for v in filtered_vulns 
                if any(asset.id == asset_id for asset in v.affected_assets)
            ]
        
        # Filtre vulnérabilités en retard
        if search_request.get("overdue_only"):
            today = date.today()
            filtered_vulns = [
                v for v in filtered_vulns 
                if v.sla_due_date and v.sla_due_date < today and v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]
            ]
        
        # Tri par date de découverte (plus récent en premier)
        filtered_vulns.sort(key=lambda x: x.discovered_date, reverse=True)
        
        # Pagination
        offset = search_request.get("offset", 0)
        limit = search_request.get("limit", 50)
        
        return filtered_vulns[offset:offset + limit]
    
    async def generate_vulnerability_report(self, vulnerabilities: List[Vulnerability]) -> VulnerabilityReport:
        """Génère un rapport de gestion des vulnérabilités"""
        
        report_id = str(uuid.uuid4())
        
        # Calculer les métriques
        total_vulns = len(vulnerabilities)
        
        # Par sévérité
        by_severity = {}
        for severity in VulnerabilitySeverity:
            by_severity[severity.value] = len([v for v in vulnerabilities if v.severity == severity])
        
        # Par statut
        by_status = {}
        for status in VulnerabilityStatus:
            by_status[status.value] = len([v for v in vulnerabilities if v.status == status])
        
        # Par source
        by_source = {}
        for source in VulnerabilitySource:
            by_source[source.value] = len([v for v in vulnerabilities if v.source == source])
        
        # Métriques temporelles
        thirty_days_ago = datetime.now() - timedelta(days=30)
        new_last_30 = len([v for v in vulnerabilities if v.discovered_date >= thirty_days_ago])
        closed_last_30 = len([
            v for v in vulnerabilities 
            if v.closed_date and v.closed_date >= thirty_days_ago
        ])
        
        # Temps moyen de remédiation
        closed_vulns = [v for v in vulnerabilities if v.closed_date]
        avg_time = None
        if closed_vulns:
            total_days = sum(
                (v.closed_date - v.discovered_date).days 
                for v in closed_vulns
            )
            avg_time = total_days / len(closed_vulns)
        
        # SLA et risques
        today = date.today()
        overdue = len([
            v for v in vulnerabilities 
            if v.sla_due_date and v.sla_due_date < today 
            and v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]
        ])
        
        critical_open = len([
            v for v in vulnerabilities 
            if v.severity == VulnerabilitySeverity.CRITICAL 
            and v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]
        ])
        
        high_open = len([
            v for v in vulnerabilities 
            if v.severity == VulnerabilitySeverity.HIGH 
            and v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]
        ])
        
        # Générer recommandations
        recommendations = await self._generate_report_recommendations(
            vulnerabilities, critical_open, high_open, overdue
        )
        
        # Créer le rapport
        report = VulnerabilityReport(
            id=report_id,
            title=f"Rapport de Gestion des Vulnérabilités - {datetime.now().strftime('%Y-%m-%d')}",
            generated_by="vulnerability_management_engine",
            total_vulnerabilities=total_vulns,
            vulnerabilities_by_severity=by_severity,
            vulnerabilities_by_status=by_status,
            vulnerabilities_by_source=by_source,
            new_vulnerabilities_last_30_days=new_last_30,
            closed_vulnerabilities_last_30_days=closed_last_30,
            average_time_to_remediation=avg_time,
            overdue_vulnerabilities=overdue,
            critical_open_vulnerabilities=critical_open,
            high_open_vulnerabilities=high_open,
            recommendations=recommendations,
            vulnerability_details=[v.dict() for v in vulnerabilities[:100]]  # Limiter à 100 pour le rapport
        )
        
        return report
    
    # Méthodes utilitaires privées
    
    async def _calculate_cvss_score(self, vector_string: str) -> Optional[CVSSScore]:
        """Calcule le score CVSS depuis le vecteur"""
        try:
            if not self.cvss_patterns["vector_regex"].match(vector_string):
                return None
            
            # Extraction simple du score de base (implémentation basique)
            # Dans une vraie application, utiliser une librairie CVSS complète
            
            base_score = 5.0  # Score par défaut pour la démonstration
            
            return CVSSScore(
                version="3.1",
                vector_string=vector_string,
                base_score=base_score,
                exploitability=2.5,
                impact=2.5
            )
            
        except Exception as e:
            print(f"Erreur calcul CVSS: {e}")
            return None
    
    async def _calculate_business_risk(self, severity: VulnerabilitySeverity, assets: List[VulnerabilityAsset], cvss: Optional[CVSSScore]) -> RiskLevel:
        """Calcule le niveau de risque business"""
        
        # Déterminer la criticité max des assets
        asset_criticality = "low"
        if assets:
            criticalities = [asset.criticality for asset in assets]
            if "critical" in criticalities:
                asset_criticality = "high"
            elif "high" in criticalities:
                asset_criticality = "medium"
            elif "medium" in criticalities:
                asset_criticality = "medium"
        
        # Utiliser la matrice de risque
        risk_mapping = self.risk_matrix.get(severity.value, {})
        risk_level = risk_mapping.get(asset_criticality, "low")
        
        return RiskLevel(risk_level)
    
    async def _calculate_sla_date(self, severity: VulnerabilitySeverity) -> date:
        """Calcule la date d'échéance SLA"""
        days = self.sla_matrix.get(severity.value, 90)
        return date.today() + timedelta(days=days)
    
    async def _calculate_remediation_priority(self, severity: VulnerabilitySeverity, risk_level: RiskLevel) -> int:
        """Calcule la priorité de remédiation (1=urgent, 5=low)"""
        priority_matrix = {
            ("critical", "critical"): 1,
            ("critical", "high"): 1,
            ("high", "critical"): 1,
            ("high", "high"): 2,
            ("medium", "high"): 2,
            ("medium", "medium"): 3,
            ("low", "medium"): 4,
            ("low", "low"): 5,
            ("info", "acceptable"): 5
        }
        
        return priority_matrix.get((severity.value, risk_level.value), 3)
    
    async def _generate_auto_remediation_actions(self, vulnerability: Vulnerability) -> List[RemediationAction]:
        """Génère des actions de remédiation automatiques"""
        actions = []
        
        # Actions basées sur le type de vulnérabilité
        if "injection" in vulnerability.vulnerability_type.lower():
            actions.append(RemediationAction(
                id=str(uuid.uuid4()),
                title="Implémenter la validation des entrées",
                description="Valider et encoder toutes les entrées utilisateur",
                type="code_fix",
                priority=1
            ))
            actions.append(RemediationAction(
                id=str(uuid.uuid4()),
                title="Utiliser des requêtes préparées",
                description="Remplacer les requêtes SQL dynamiques par des requêtes préparées",
                type="code_fix",
                priority=1
            ))
        
        if "xss" in vulnerability.vulnerability_type.lower():
            actions.append(RemediationAction(
                id=str(uuid.uuid4()),
                title="Implémenter l'encodage des sorties",
                description="Encoder toutes les sorties vers le navigateur",
                type="code_fix",
                priority=1
            ))
            actions.append(RemediationAction(
                id=str(uuid.uuid4()),
                title="Configurer Content Security Policy",
                description="Implémenter une CSP stricte",
                type="config_change",
                priority=2
            ))
        
        if vulnerability.severity == VulnerabilitySeverity.CRITICAL:
            actions.append(RemediationAction(
                id=str(uuid.uuid4()),
                title="Revue de sécurité immédiate",
                description="Effectuer une revue de sécurité complète du composant affecté",
                type="review",
                priority=1
            ))
        
        return actions
    
    async def _generate_report_recommendations(self, vulnerabilities: List[Vulnerability], critical_open: int, high_open: int, overdue: int) -> List[str]:
        """Génère des recommandations pour le rapport"""
        recommendations = []
        
        if critical_open > 0:
            recommendations.append(f"🚨 URGENT: {critical_open} vulnérabilités critiques ouvertes nécessitent une attention immédiate")
        
        if high_open > 5:
            recommendations.append(f"⚠️ PRIORITÉ: {high_open} vulnérabilités à risque élevé à traiter rapidement")
        
        if overdue > 0:
            recommendations.append(f"📅 SLA: {overdue} vulnérabilités dépassent leur SLA - révision des processus requise")
        
        # Analyse des tendances
        total_open = len([v for v in vulnerabilities if v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]])
        if total_open > 50:
            recommendations.append("📈 Volume élevé de vulnérabilités ouvertes - envisager l'augmentation des ressources")
        
        # Recommandations par source
        pentest_vulns = len([v for v in vulnerabilities if v.source == VulnerabilitySource.PENTEST])
        if pentest_vulns > total_open * 0.5:
            recommendations.append("🔍 Forte proportion de vulnérabilités détectées en pentest - renforcer les contrôles préventifs")
        
        # Recommandations générales
        recommendations.extend([
            "📋 Mettre à jour régulièrement l'inventaire des assets critiques",
            "🔄 Réviser les SLA selon la criticité business des assets",
            "📚 Former les équipes de développement sur les pratiques de sécurité",
            "🤖 Considérer l'automatisation des tests de sécurité"
        ])
        
        return recommendations