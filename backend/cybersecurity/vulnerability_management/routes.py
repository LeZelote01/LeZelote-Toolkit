"""
Routes API pour le service Vulnerability Management
CyberSec Toolkit Pro 2025 - PORTABLE
"""
from fastapi import APIRouter, HTTPException, BackgroundTasks, Query
from typing import List, Dict, Any, Optional
import uuid
from datetime import datetime, date

from .models import (
    Vulnerability, VulnerabilityRequest, VulnerabilityUpdate, VulnerabilitySearchRequest,
    RemediationRequest, VulnerabilityStatus, VulnerabilitySeverity, VulnerabilitySource,
    RemediationStatus, VulnerabilityReport
)
from .vulnerability_engine import VulnerabilityEngine
from database import get_database

router = APIRouter(prefix="/api/vulnerability-management", tags=["vulnerability-management"])

# Instance du moteur de gestion des vulnérabilités
vuln_engine = VulnerabilityEngine()

# Cache des vulnérabilités actives
active_vulnerabilities: Dict[str, Vulnerability] = {}


@router.get("/")
async def vulnerability_management_status():
    """Status du service Vulnerability Management"""
    return {
        "status": "operational",
        "service": "Vulnerability Management",
        "version": "1.0.0-portable",
        "features": {
            "vulnerability_lifecycle": True,
            "cvss_scoring": True,
            "sla_management": True,
            "remediation_tracking": True,
            "risk_assessment": True,
            "automated_workflows": True,
            "reporting": True,
            "integration_ready": True
        },
        "supported_sources": [source.value for source in VulnerabilitySource],
        "severity_levels": [sev.value for sev in VulnerabilitySeverity],
        "status_workflow": [status.value for status in VulnerabilityStatus],
        "active_vulnerabilities": len(active_vulnerabilities),
        "critical_open": len([v for v in active_vulnerabilities.values() 
                            if v.severity == VulnerabilitySeverity.CRITICAL 
                            and v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]]),
        "overdue_vulnerabilities": _count_overdue_vulnerabilities()
    }


@router.post("/vulnerability")
async def create_vulnerability(vuln_request: VulnerabilityRequest, background_tasks: BackgroundTasks):
    """Crée une nouvelle vulnérabilité"""
    try:
        # Créer la vulnérabilité
        vulnerability = await vuln_engine.create_vulnerability(vuln_request)
        
        # Stocker en cache
        active_vulnerabilities[vulnerability.id] = vulnerability
        
        # Sauvegarder en base en arrière-plan
        background_tasks.add_task(save_vulnerability_to_db, vulnerability)
        
        return {
            "status": "success",
            "message": f"Vulnérabilité '{vulnerability.title}' créée avec succès",
            "vulnerability": {
                "id": vulnerability.id,
                "title": vulnerability.title,
                "severity": vulnerability.severity.value,
                "status": vulnerability.status.value,
                "risk_level": vulnerability.risk_level.value,
                "sla_due_date": vulnerability.sla_due_date.isoformat() if vulnerability.sla_due_date else None,
                "remediation_actions_count": len(vulnerability.remediation_actions),
                "affected_assets_count": len(vulnerability.affected_assets)
            },
            "next_steps": [
                "1. Assigner la vulnérabilité à un responsable",
                "2. Valider les actions de remédiation proposées",
                "3. Planifier les corrections selon la priorité",
                "4. Suivre l'avancement via le tableau de bord"
            ],
            "recommendations": _generate_initial_recommendations(vulnerability)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur création vulnérabilité: {str(e)}")


@router.get("/vulnerability/{vuln_id}")
async def get_vulnerability(vuln_id: str):
    """Récupère les détails d'une vulnérabilité"""
    if vuln_id not in active_vulnerabilities:
        raise HTTPException(status_code=404, detail="Vulnérabilité non trouvée")
    
    vulnerability = active_vulnerabilities[vuln_id]
    
    # Calculer des métriques additionnelles
    days_open = (datetime.now() - vulnerability.discovered_date).days
    days_until_sla = None
    if vulnerability.sla_due_date:
        days_until_sla = (vulnerability.sla_due_date - date.today()).days
    
    completed_actions = len([a for a in vulnerability.remediation_actions 
                           if a.status == RemediationStatus.COMPLETED])
    
    return {
        "vulnerability": vulnerability.dict(),
        "metrics": {
            "days_open": days_open,
            "days_until_sla_breach": days_until_sla,
            "is_overdue": days_until_sla is not None and days_until_sla < 0,
            "remediation_progress": f"{completed_actions}/{len(vulnerability.remediation_actions)}",
            "completion_percentage": int((completed_actions / len(vulnerability.remediation_actions)) * 100) if vulnerability.remediation_actions else 0
        },
        "timeline": _build_vulnerability_timeline(vulnerability),
        "related_vulnerabilities": _find_related_vulnerabilities(vulnerability)
    }


@router.put("/vulnerability/{vuln_id}")
async def update_vulnerability(vuln_id: str, update_request: VulnerabilityUpdate):
    """Met à jour une vulnérabilité"""
    if vuln_id not in active_vulnerabilities:
        raise HTTPException(status_code=404, detail="Vulnérabilité non trouvée")
    
    try:
        current_vuln = active_vulnerabilities[vuln_id]
        updated_vuln = await vuln_engine.update_vulnerability(vuln_id, update_request, current_vuln)
        
        # Mettre à jour le cache
        active_vulnerabilities[vuln_id] = updated_vuln
        
        return {
            "status": "success",
            "message": "Vulnérabilité mise à jour avec succès",
            "updated_fields": {
                "status": updated_vuln.status.value,
                "assigned_to": updated_vuln.assigned_to,
                "severity": updated_vuln.severity.value,
                "last_modified": updated_vuln.updated_at.isoformat()
            },
            "recommendations": _generate_update_recommendations(updated_vuln, update_request)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur mise à jour vulnérabilité: {str(e)}")


@router.post("/vulnerability/{vuln_id}/remediation")
async def add_remediation_action(vuln_id: str, remediation_request: RemediationRequest):
    """Ajoute une action de remédiation"""
    if vuln_id not in active_vulnerabilities:
        raise HTTPException(status_code=404, detail="Vulnérabilité non trouvée")
    
    try:
        vulnerability = active_vulnerabilities[vuln_id]
        
        # Créer l'action
        action = await vuln_engine.add_remediation_action(vuln_id, remediation_request)
        
        # Ajouter à la vulnérabilité
        vulnerability.remediation_actions.append(action)
        vulnerability.updated_at = datetime.now()
        vulnerability.last_modified_by = remediation_request.assigned_to or "system"
        
        return {
            "status": "success",
            "message": f"Action de remédiation '{action.title}' ajoutée",
            "action": {
                "id": action.id,
                "title": action.title,
                "type": action.type,
                "priority": action.priority,
                "status": action.status.value,
                "assigned_to": action.assigned_to,
                "due_date": action.due_date.isoformat() if action.due_date else None
            },
            "total_actions": len(vulnerability.remediation_actions)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur ajout action remédiation: {str(e)}")


@router.put("/vulnerability/{vuln_id}/remediation/{action_id}")
async def update_remediation_action(vuln_id: str, action_id: str, action_update: Dict[str, Any]):
    """Met à jour une action de remédiation"""
    if vuln_id not in active_vulnerabilities:
        raise HTTPException(status_code=404, detail="Vulnérabilité non trouvée")
    
    vulnerability = active_vulnerabilities[vuln_id]
    
    # Trouver l'action
    action = None
    for a in vulnerability.remediation_actions:
        if a.id == action_id:
            action = a
            break
    
    if not action:
        raise HTTPException(status_code=404, detail="Action de remédiation non trouvée")
    
    try:
        # Mettre à jour l'action
        old_status = action.status
        
        if "status" in action_update:
            action.status = RemediationStatus(action_update["status"])
            
        if "assigned_to" in action_update:
            action.assigned_to = action_update["assigned_to"]
            
        if "due_date" in action_update:
            action.due_date = datetime.fromisoformat(action_update["due_date"]).date()
            
        if "verification_notes" in action_update:
            action.verification_notes = action_update["verification_notes"]
        
        # Marquer comme terminé si statut completed
        if action.status == RemediationStatus.COMPLETED and old_status != RemediationStatus.COMPLETED:
            action.completed_date = datetime.now()
        
        # Mettre à jour la vulnérabilité
        vulnerability.updated_at = datetime.now()
        vulnerability.last_modified_by = action_update.get("updated_by", "system")
        
        return {
            "status": "success",
            "message": f"Action '{action.title}' mise à jour",
            "action_status": action.status.value,
            "completed": action.status == RemediationStatus.COMPLETED,
            "next_actions": _suggest_next_remediation_steps(vulnerability)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur mise à jour action: {str(e)}")


@router.post("/vulnerability/{vuln_id}/evidence")
async def add_evidence(vuln_id: str, evidence_data: Dict[str, Any]):
    """Ajoute une preuve à une vulnérabilité"""
    if vuln_id not in active_vulnerabilities:
        raise HTTPException(status_code=404, detail="Vulnérabilité non trouvée")
    
    try:
        vulnerability = active_vulnerabilities[vuln_id]
        
        # Créer la preuve
        evidence = await vuln_engine.add_evidence(vuln_id, evidence_data)
        
        # Ajouter à la vulnérabilité
        vulnerability.evidence.append(evidence)
        vulnerability.updated_at = datetime.now()
        
        return {
            "status": "success",
            "message": f"Preuve '{evidence.description}' ajoutée",
            "evidence": {
                "id": evidence.id,
                "type": evidence.type,
                "description": evidence.description,
                "created_at": evidence.created_at.isoformat(),
                "created_by": evidence.created_by
            },
            "total_evidence": len(vulnerability.evidence)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur ajout preuve: {str(e)}")


@router.post("/vulnerability/{vuln_id}/comment")
async def add_comment(vuln_id: str, comment_data: Dict[str, Any]):
    """Ajoute un commentaire à une vulnérabilité"""
    if vuln_id not in active_vulnerabilities:
        raise HTTPException(status_code=404, detail="Vulnérabilité non trouvée")
    
    try:
        vulnerability = active_vulnerabilities[vuln_id]
        
        # Créer le commentaire
        comment = await vuln_engine.add_comment(vuln_id, comment_data)
        
        # Ajouter à la vulnérabilité
        vulnerability.comments.append(comment)
        vulnerability.updated_at = datetime.now()
        
        return {
            "status": "success",
            "message": "Commentaire ajouté",
            "comment": {
                "id": comment.id,
                "author": comment.author,
                "content": comment.content,
                "created_at": comment.created_at.isoformat(),
                "type": comment.type
            },
            "total_comments": len(vulnerability.comments)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur ajout commentaire: {str(e)}")


@router.post("/search")
async def search_vulnerabilities(search_request: VulnerabilitySearchRequest):
    """Recherche des vulnérabilités"""
    try:
        # Convertir la requête en dictionnaire
        search_dict = search_request.dict()
        
        # Effectuer la recherche
        results = await vuln_engine.search_vulnerabilities(search_dict, list(active_vulnerabilities.values()))
        
        # Préparer la réponse
        vulnerability_summaries = []
        for vuln in results:
            days_until_sla = None
            if vuln.sla_due_date:
                days_until_sla = (vuln.sla_due_date - date.today()).days
            
            vulnerability_summaries.append({
                "id": vuln.id,
                "title": vuln.title,
                "severity": vuln.severity.value,
                "status": vuln.status.value,
                "risk_level": vuln.risk_level.value,
                "source": vuln.source.value,
                "assigned_to": vuln.assigned_to,
                "discovered_date": vuln.discovered_date.isoformat(),
                "sla_due_date": vuln.sla_due_date.isoformat() if vuln.sla_due_date else None,
                "days_until_sla": days_until_sla,
                "is_overdue": days_until_sla is not None and days_until_sla < 0,
                "affected_assets_count": len(vuln.affected_assets),
                "remediation_actions_count": len(vuln.remediation_actions),
                "tags": vuln.tags
            })
        
        return {
            "vulnerabilities": vulnerability_summaries,
            "total_results": len(results),
            "search_criteria": {
                "query": search_request.query,
                "severity": search_request.severity,
                "status": search_request.status,
                "overdue_only": search_request.overdue_only
            },
            "summary": _generate_search_summary(results)
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur recherche vulnérabilités: {str(e)}")


@router.get("/vulnerabilities")
async def list_vulnerabilities(
    severity: Optional[str] = Query(None, description="Filtrer par sévérité"),
    status: Optional[str] = Query(None, description="Filtrer par statut"),
    assigned_to: Optional[str] = Query(None, description="Filtrer par assigné"),
    overdue: bool = Query(False, description="Vulnérabilités en retard uniquement"),
    limit: int = Query(50, description="Nombre max de résultats", le=500),
    offset: int = Query(0, description="Offset pour pagination", ge=0)
):
    """Liste les vulnérabilités avec filtres"""
    
    vulnerabilities_list = list(active_vulnerabilities.values())
    
    # Appliquer les filtres
    if severity:
        try:
            sev_filter = VulnerabilitySeverity(severity)
            vulnerabilities_list = [v for v in vulnerabilities_list if v.severity == sev_filter]
        except ValueError:
            pass
    
    if status:
        try:
            status_filter = VulnerabilityStatus(status)
            vulnerabilities_list = [v for v in vulnerabilities_list if v.status == status_filter]
        except ValueError:
            pass
    
    if assigned_to:
        vulnerabilities_list = [v for v in vulnerabilities_list if v.assigned_to == assigned_to]
    
    if overdue:
        today = date.today()
        vulnerabilities_list = [
            v for v in vulnerabilities_list 
            if v.sla_due_date and v.sla_due_date < today 
            and v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]
        ]
    
    # Tri par sévérité puis date
    severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3, "info": 4}
    vulnerabilities_list.sort(key=lambda x: (severity_order.get(x.severity.value, 5), x.discovered_date), reverse=True)
    
    # Pagination
    total = len(vulnerabilities_list)
    paginated_list = vulnerabilities_list[offset:offset + limit]
    
    # Construire la réponse
    vulnerability_summaries = []
    for vuln in paginated_list:
        days_until_sla = None
        if vuln.sla_due_date:
            days_until_sla = (vuln.sla_due_date - date.today()).days
        
        vulnerability_summaries.append({
            "id": vuln.id,
            "title": vuln.title,
            "severity": vuln.severity.value,
            "status": vuln.status.value,
            "risk_level": vuln.risk_level.value,
            "assigned_to": vuln.assigned_to,
            "discovered_date": vuln.discovered_date.isoformat(),
            "days_until_sla": days_until_sla,
            "is_overdue": days_until_sla is not None and days_until_sla < 0,
            "affected_assets_count": len(vuln.affected_assets),
            "remediation_progress": f"{len([a for a in vuln.remediation_actions if a.status == RemediationStatus.COMPLETED])}/{len(vuln.remediation_actions)}"
        })
    
    return {
        "vulnerabilities": vulnerability_summaries,
        "pagination": {
            "total": total,
            "limit": limit,
            "offset": offset,
            "has_more": offset + limit < total
        },
        "filters_applied": {
            "severity": severity,
            "status": status,
            "assigned_to": assigned_to,
            "overdue_only": overdue
        },
        "summary": _generate_list_summary(vulnerabilities_list)
    }


@router.get("/dashboard")
async def get_vulnerability_dashboard():
    """Tableau de bord des vulnérabilités"""
    
    all_vulns = list(active_vulnerabilities.values())
    today = date.today()
    
    # Métriques globales
    total_vulns = len(all_vulns)
    open_vulns = len([v for v in all_vulns if v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]])
    
    # Par sévérité
    by_severity = {}
    for severity in VulnerabilitySeverity:
        count = len([v for v in all_vulns if v.severity == severity])
        open_count = len([v for v in all_vulns if v.severity == severity 
                         and v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]])
        by_severity[severity.value] = {"total": count, "open": open_count}
    
    # Par statut
    by_status = {}
    for status in VulnerabilityStatus:
        by_status[status.value] = len([v for v in all_vulns if v.status == status])
    
    # SLA et échéances
    overdue_count = 0
    due_soon_count = 0  # Dans les 7 prochains jours
    
    for vuln in all_vulns:
        if vuln.sla_due_date and vuln.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]:
            days_until_due = (vuln.sla_due_date - today).days
            if days_until_due < 0:
                overdue_count += 1
            elif days_until_due <= 7:
                due_soon_count += 1
    
    # Top assignés
    assignee_counts = {}
    for vuln in all_vulns:
        if vuln.assigned_to and vuln.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]:
            assignee_counts[vuln.assigned_to] = assignee_counts.get(vuln.assigned_to, 0) + 1
    
    top_assignees = sorted(assignee_counts.items(), key=lambda x: x[1], reverse=True)[:5]
    
    # Assets les plus affectés
    asset_counts = {}
    for vuln in all_vulns:
        for asset in vuln.affected_assets:
            if vuln.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]:
                asset_counts[asset.name] = asset_counts.get(asset.name, 0) + 1
    
    top_assets = sorted(asset_counts.items(), key=lambda x: x[1], reverse=True)[:5]
    
    return {
        "overview": {
            "total_vulnerabilities": total_vulns,
            "open_vulnerabilities": open_vulns,
            "closure_rate": f"{((total_vulns - open_vulns) / total_vulns * 100):.1f}%" if total_vulns > 0 else "0%",
            "overdue_vulnerabilities": overdue_count,
            "due_soon_vulnerabilities": due_soon_count
        },
        "by_severity": by_severity,
        "by_status": by_status,
        "sla_metrics": {
            "overdue": overdue_count,
            "due_within_7_days": due_soon_count,
            "sla_breach_rate": f"{(overdue_count / open_vulns * 100):.1f}%" if open_vulns > 0 else "0%"
        },
        "top_assignees": [{"name": name, "open_count": count} for name, count in top_assignees],
        "most_affected_assets": [{"name": name, "vulnerability_count": count} for name, count in top_assets],
        "priority_actions": _generate_priority_actions(all_vulns, overdue_count, due_soon_count),
        "recommendations": _generate_dashboard_recommendations(all_vulns)
    }


@router.post("/report")
async def generate_vulnerability_report(include_closed: bool = False, format: str = "json"):
    """Génère un rapport de gestion des vulnérabilités"""
    
    try:
        vulnerabilities = list(active_vulnerabilities.values())
        
        if not include_closed:
            vulnerabilities = [v for v in vulnerabilities 
                             if v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]]
        
        # Générer le rapport
        report = await vuln_engine.generate_vulnerability_report(vulnerabilities)
        
        if format.lower() == "json":
            return {
                "status": "success",
                "message": "Rapport généré avec succès",
                "report": report.dict(),
                "export_options": {
                    "pdf": f"/reports/vulnerability/{report.id}.pdf",
                    "html": f"/reports/vulnerability/{report.id}.html",
                    "csv": f"/reports/vulnerability/{report.id}.csv"
                }
            }
        
        return {
            "status": "success",
            "message": f"Rapport généré au format {format}",
            "report_id": report.id,
            "download_url": f"/reports/vulnerability/{report.id}.{format}"
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Erreur génération rapport: {str(e)}")


@router.get("/statistics")
async def get_vulnerability_statistics():
    """Statistiques détaillées des vulnérabilités"""
    
    all_vulns = list(active_vulnerabilities.values())
    
    if not all_vulns:
        return {
            "total_vulnerabilities": 0,
            "statistics": {},
            "message": "Aucune vulnérabilité à analyser"
        }
    
    # Calculs statistiques
    stats = {
        "total": len(all_vulns),
        "by_severity": {sev.value: len([v for v in all_vulns if v.severity == sev]) for sev in VulnerabilitySeverity},
        "by_status": {status.value: len([v for v in all_vulns if v.status == status]) for status in VulnerabilityStatus},
        "by_source": {source.value: len([v for v in all_vulns if v.source == source]) for source in VulnerabilitySource}
    }
    
    # Métriques temporelles
    closed_vulns = [v for v in all_vulns if v.closed_date]
    if closed_vulns:
        avg_resolution_time = sum((v.closed_date - v.discovered_date).days for v in closed_vulns) / len(closed_vulns)
        stats["average_resolution_days"] = round(avg_resolution_time, 1)
    
    # SLA metrics
    today = date.today()
    overdue = len([v for v in all_vulns if v.sla_due_date and v.sla_due_date < today 
                  and v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]])
    stats["overdue_count"] = overdue
    
    return {
        "total_vulnerabilities": len(all_vulns),
        "statistics": stats,
        "trends": _calculate_vulnerability_trends(all_vulns),
        "performance_indicators": _calculate_kpis(all_vulns)
    }


# Fonctions utilitaires

async def save_vulnerability_to_db(vulnerability: Vulnerability):
    """Sauvegarde une vulnérabilité en base de données"""
    try:
        db = await get_database()
        collection = await db.get_collection("vulnerabilities")
        await collection.insert_one(vulnerability.dict())
    except Exception as e:
        print(f"Erreur sauvegarde vulnérabilité {vulnerability.id}: {e}")


def _count_overdue_vulnerabilities() -> int:
    """Compte les vulnérabilités en retard"""
    today = date.today()
    return len([
        v for v in active_vulnerabilities.values()
        if v.sla_due_date and v.sla_due_date < today 
        and v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]
    ])


def _generate_initial_recommendations(vulnerability: Vulnerability) -> List[str]:
    """Génère des recommandations initiales"""
    recommendations = []
    
    if vulnerability.severity in [VulnerabilitySeverity.CRITICAL, VulnerabilitySeverity.HIGH]:
        recommendations.append("🚨 Vulnérabilité haute priorité - assignation immédiate requise")
        recommendations.append("📞 Notifier l'équipe de sécurité et la direction")
    
    if vulnerability.affected_assets:
        recommendations.append(f"🎯 {len(vulnerability.affected_assets)} asset(s) affecté(s) - évaluer l'impact business")
    
    if vulnerability.remediation_actions:
        recommendations.append(f"🔧 {len(vulnerability.remediation_actions)} actions de remédiation générées automatiquement")
    
    recommendations.extend([
        "📋 Valider les détails techniques avec l'équipe concernée",
        "⏱️ Respecter le SLA selon la sévérité de la vulnérabilité",
        "📝 Documenter toute investigation complémentaire"
    ])
    
    return recommendations


def _generate_update_recommendations(vulnerability: Vulnerability, update: VulnerabilityUpdate) -> List[str]:
    """Génère des recommandations après mise à jour"""
    recommendations = []
    
    if update.status and update.status in [VulnerabilityStatus.ASSIGNED, VulnerabilityStatus.IN_PROGRESS]:
        recommendations.append("📅 Planifier les actions de remédiation selon les échéances")
        recommendations.append("📊 Suivre le progrès régulièrement")
    
    if update.status == VulnerabilityStatus.TESTING:
        recommendations.append("🧪 Valider que toutes les corrections ont été appliquées")
        recommendations.append("🔍 Effectuer des tests de régression")
    
    if update.status in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]:
        recommendations.append("✅ Vulnérabilité résolue - documenter les leçons apprises")
        recommendations.append("🔄 Considérer des mesures préventives similaires")
    
    return recommendations


def _build_vulnerability_timeline(vulnerability: Vulnerability) -> List[Dict[str, Any]]:
    """Construit la timeline d'une vulnérabilité"""
    timeline = []
    
    # Découverte
    timeline.append({
        "date": vulnerability.discovered_date.isoformat(),
        "event": "discovery",
        "description": f"Vulnérabilité découverte via {vulnerability.source.value}",
        "actor": vulnerability.reported_by
    })
    
    # Commentaires avec changements de statut
    for comment in sorted(vulnerability.comments, key=lambda x: x.created_at):
        timeline.append({
            "date": comment.created_at.isoformat(),
            "event": comment.type,
            "description": comment.content,
            "actor": comment.author
        })
    
    # Actions de remédiation terminées
    for action in vulnerability.remediation_actions:
        if action.completed_date:
            timeline.append({
                "date": action.completed_date.isoformat(),
                "event": "remediation_completed",
                "description": f"Action terminée: {action.title}",
                "actor": action.assigned_to or "unknown"
            })
    
    # Fermeture
    if vulnerability.closed_date:
        timeline.append({
            "date": vulnerability.closed_date.isoformat(),
            "event": "closure",
            "description": "Vulnérabilité fermée",
            "actor": vulnerability.verified_by or "system"
        })
    
    return sorted(timeline, key=lambda x: x["date"])


def _find_related_vulnerabilities(vulnerability: Vulnerability) -> List[Dict[str, Any]]:
    """Trouve des vulnérabilités similaires"""
    related = []
    
    for other_vuln in active_vulnerabilities.values():
        if other_vuln.id == vulnerability.id:
            continue
        
        # Même type de vulnérabilité
        if other_vuln.vulnerability_type == vulnerability.vulnerability_type:
            related.append({
                "id": other_vuln.id,
                "title": other_vuln.title,
                "relationship": "same_type",
                "severity": other_vuln.severity.value
            })
        
        # Même asset affecté
        vuln_asset_names = {asset.name for asset in vulnerability.affected_assets}
        other_asset_names = {asset.name for asset in other_vuln.affected_assets}
        
        if vuln_asset_names.intersection(other_asset_names):
            related.append({
                "id": other_vuln.id,
                "title": other_vuln.title,
                "relationship": "same_asset",
                "severity": other_vuln.severity.value
            })
    
    return related[:5]  # Limiter à 5 résultats


def _suggest_next_remediation_steps(vulnerability: Vulnerability) -> List[str]:
    """Suggère les prochaines étapes de remédiation"""
    completed_actions = [a for a in vulnerability.remediation_actions if a.status == RemediationStatus.COMPLETED]
    pending_actions = [a for a in vulnerability.remediation_actions if a.status != RemediationStatus.COMPLETED]
    
    steps = []
    
    if pending_actions:
        priority_actions = sorted(pending_actions, key=lambda x: x.priority)
        next_action = priority_actions[0]
        steps.append(f"Prochaine action prioritaire: {next_action.title}")
        
        if next_action.assigned_to:
            steps.append(f"Contacter {next_action.assigned_to} pour le suivi")
    
    if completed_actions and not pending_actions:
        steps.append("Toutes les actions terminées - effectuer les tests de validation")
        steps.append("Préparer la vérification de fermeture de la vulnérabilité")
    
    return steps


def _generate_search_summary(vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
    """Génère un résumé des résultats de recherche"""
    if not vulnerabilities:
        return {"message": "Aucune vulnérabilité trouvée"}
    
    by_severity = {}
    for sev in VulnerabilitySeverity:
        by_severity[sev.value] = len([v for v in vulnerabilities if v.severity == sev])
    
    overdue_count = 0
    today = date.today()
    for vuln in vulnerabilities:
        if vuln.sla_due_date and vuln.sla_due_date < today and vuln.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]:
            overdue_count += 1
    
    return {
        "total_found": len(vulnerabilities),
        "by_severity": by_severity,
        "overdue_count": overdue_count,
        "most_common_type": _get_most_common_vulnerability_type(vulnerabilities)
    }


def _generate_list_summary(vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
    """Génère un résumé pour la liste des vulnérabilités"""
    return _generate_search_summary(vulnerabilities)


def _generate_priority_actions(vulnerabilities: List[Vulnerability], overdue_count: int, due_soon_count: int) -> List[str]:
    """Génère les actions prioritaires pour le dashboard"""
    actions = []
    
    critical_open = len([v for v in vulnerabilities if v.severity == VulnerabilitySeverity.CRITICAL 
                        and v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]])
    
    if critical_open > 0:
        actions.append(f"🚨 URGENT: Traiter {critical_open} vulnérabilités critiques ouvertes")
    
    if overdue_count > 0:
        actions.append(f"⏰ SLA: {overdue_count} vulnérabilités dépassent leur échéance")
    
    if due_soon_count > 0:
        actions.append(f"📅 ATTENTION: {due_soon_count} vulnérabilités dues dans 7 jours")
    
    unassigned = len([v for v in vulnerabilities if not v.assigned_to 
                     and v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]])
    
    if unassigned > 0:
        actions.append(f"👤 ASSIGNATION: {unassigned} vulnérabilités non assignées")
    
    return actions


def _generate_dashboard_recommendations(vulnerabilities: List[Vulnerability]) -> List[str]:
    """Génère des recommandations pour le dashboard"""
    recommendations = []
    
    total_open = len([v for v in vulnerabilities if v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]])
    
    if total_open > 50:
        recommendations.append("📈 Volume élevé de vulnérabilités ouvertes - envisager l'augmentation des ressources")
    
    # Analyse des sources
    pentest_count = len([v for v in vulnerabilities if v.source == VulnerabilitySource.PENTEST])
    if pentest_count > total_open * 0.4:
        recommendations.append("🔍 Forte proportion de vulnérabilités en pentest - renforcer les contrôles préventifs")
    
    recommendations.extend([
        "📊 Réviser les SLA selon la criticité business des assets",
        "🤖 Automatiser la création de vulnérabilités depuis les scanners",
        "📚 Former les équipes sur les bonnes pratiques de remédiation",
        "🔄 Mettre en place des revues régulières de vulnérabilités"
    ])
    
    return recommendations


def _get_most_common_vulnerability_type(vulnerabilities: List[Vulnerability]) -> str:
    """Trouve le type de vulnérabilité le plus commun"""
    if not vulnerabilities:
        return "N/A"
    
    type_counts = {}
    for vuln in vulnerabilities:
        type_counts[vuln.vulnerability_type] = type_counts.get(vuln.vulnerability_type, 0) + 1
    
    return max(type_counts, key=type_counts.get) if type_counts else "N/A"


def _calculate_vulnerability_trends(vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
    """Calcule les tendances des vulnérabilités"""
    # Implémentation simplifiée - dans un vrai projet, analyser les données historiques
    return {
        "discovery_trend": "stable",
        "closure_trend": "improving",
        "critical_trend": "decreasing"
    }


def _calculate_kpis(vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
    """Calcule les KPIs"""
    if not vulnerabilities:
        return {}
    
    closed_vulns = [v for v in vulnerabilities if v.closed_date]
    open_vulns = [v for v in vulnerabilities if v.status not in [VulnerabilityStatus.CLOSED, VulnerabilityStatus.VERIFIED]]
    
    return {
        "closure_rate": len(closed_vulns) / len(vulnerabilities) * 100 if vulnerabilities else 0,
        "average_age_open_vulnerabilities": sum((datetime.now() - v.discovered_date).days for v in open_vulns) / len(open_vulns) if open_vulns else 0,
        "critical_open_percentage": len([v for v in open_vulns if v.severity == VulnerabilitySeverity.CRITICAL]) / len(open_vulns) * 100 if open_vulns else 0
    }