#!/usr/bin/env python3
"""
Exploitation CLI Module for Pentest-USB Toolkit
===============================================

Command-line interface for vulnerability exploitation, payload generation,
and attack automation including web, network, and binary exploitation.
"""

import sys
import threading
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path
from datetime import datetime

from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn
from rich.prompt import Prompt, Confirm, IntPrompt
from rich import box

# Add project root to path
project_root = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(project_root))

from interfaces.cli.utils import CLIUtils
from modules.exploitation.web_exploit import WebExploiter
from modules.exploitation.network_exploit import NetworkExploiter
from modules.exploitation.binary_exploit import BinaryExploiter
from modules.exploitation.social_engineer import SocialEngineer
from modules.exploitation.wireless_exploit import WirelessExploiter


class ExploitCLI:
    """Command-line interface for exploitation module."""
    
    def __init__(self):
        """Initialize exploitation CLI."""
        self.console = Console()
        self.utils = CLIUtils()
        
        # Initialize exploitation modules
        self.web_exploiter = WebExploiter()
        self.network_exploiter = NetworkExploiter()
        self.binary_exploiter = BinaryExploiter()
        self.social_engineer = SocialEngineer()
        self.wireless_exploiter = WirelessExploiter()
        
        # CLI state
        self.exploit_results = {}
        self.active_exploits = {}
        self.sessions = {}
        
    def run(self, args: List[str] = None):
        """Main entry point for exploitation CLI."""
        try:
            self._show_banner()
            self._check_authorization()
            
            if args and len(args) > 0:
                # Direct command mode
                self._handle_direct_command(args)
            else:
                # Interactive mode
                self._interactive_mode()
                
        except KeyboardInterrupt:
            self.console.print("\n[yellow]Exploitation module interrupted.[/]")
        except Exception as e:
            self.console.print(f"[red]Error in exploitation module: {e}[/]")
            
    def _show_banner(self):
        """Show exploitation module banner."""
        banner = """
[bold red]⚔️ EXPLOITATION MODULE[/]
[dim]Web Exploitation • Network Attacks • Binary Exploitation • Social Engineering[/]

[bold yellow]⚠️  WARNING: For authorized penetration testing only[/]
"""
        self.console.print(Panel(banner, border_style="red"))
        
    def _check_authorization(self):
        """Verify explicit authorization for exploitation activities."""
        if not Confirm.ask("[red]Do you have explicit written authorization to perform exploitation?[/]"):
            self.console.print("[red]Exploitation module terminated. Authorization required.[/]")
            sys.exit(1)
            
    def _handle_direct_command(self, args: List[str]):
        """Handle direct command execution."""
        if not args:
            return
            
        command = args[0].lower()
        
        if command in ['web', 'webapp']:
            url = args[1] if len(args) > 1 else Prompt.ask("[cyan]Enter target URL")
            vuln_type = args[2] if len(args) > 2 else None
            self._web_exploitation_menu(url, vuln_type)
        elif command in ['network', 'net']:
            target = args[1] if len(args) > 1 else Prompt.ask("[cyan]Enter target host")
            service = args[2] if len(args) > 2 else None
            self._network_exploitation_menu(target, service)
        elif command in ['binary', 'bin']:
            target = args[1] if len(args) > 1 else Prompt.ask("[cyan]Enter target (IP:port)")
            self._binary_exploitation_menu(target)
        elif command in ['social', 'phishing']:
            campaign_type = args[1] if len(args) > 1 else None
            self._social_engineering_menu(campaign_type)
        elif command in ['wireless', 'wifi']:
            interface = args[1] if len(args) > 1 else None
            self._wireless_exploitation_menu(interface)
        elif command in ['payload', 'generate']:
            payload_type = args[1] if len(args) > 1 else None
            self._payload_generation_menu(payload_type)
        elif command in ['sessions', 'shells']:
            self._session_management_menu()
        else:
            self.console.print(f"[red]Unknown exploitation command: {command}[/]")
            self._show_help()
            
    def _interactive_mode(self):
        """Run interactive exploitation mode."""
        while True:
            self._show_menu()
            
            choice = Prompt.ask(
                "\n[bold cyan]Select exploitation option[/]",
                choices=["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"],
                default="0"
            )
            
            if choice == "0":
                break
            elif choice == "1":
                url = Prompt.ask("[cyan]Enter target URL")
                self._web_exploitation_menu(url)
            elif choice == "2":
                target = Prompt.ask("[cyan]Enter target host")
                self._network_exploitation_menu(target)
            elif choice == "3":
                target = Prompt.ask("[cyan]Enter target (IP:port)")
                self._binary_exploitation_menu(target)
            elif choice == "4":
                self._social_engineering_menu()
            elif choice == "5":
                interface = Prompt.ask("[cyan]Enter wireless interface", default="wlan0")
                self._wireless_exploitation_menu(interface)
            elif choice == "6":
                self._payload_generation_menu()
            elif choice == "7":
                self._session_management_menu()
            elif choice == "8":
                self._show_results()
            elif choice == "9":
                self._advanced_options()
                
    def _show_menu(self):
        """Display exploitation menu options."""
        table = Table(title="[bold red]Exploitation Options[/]", box=box.ROUNDED)
        table.add_column("Option", style="bold yellow", justify="center")
        table.add_column("Module", style="bold green")
        table.add_column("Description", style="white")
        
        table.add_row("1", "Web Application Exploitation", "SQL injection, XSS, RCE, etc.")
        table.add_row("2", "Network Service Exploitation", "Service vulnerabilities and exploits")
        table.add_row("3", "Binary Exploitation", "Buffer overflows and binary attacks")
        table.add_row("4", "Social Engineering", "Phishing campaigns and OSINT attacks")
        table.add_row("5", "Wireless Exploitation", "WiFi attacks and wireless hacking")
        table.add_row("", "", "")
        table.add_row("6", "Payload Generation", "Generate custom payloads and shellcode")
        table.add_row("7", "Session Management", "Manage active sessions and shells")
        table.add_row("8", "View Results", "Display exploitation results")
        table.add_row("9", "Advanced Options", "Configure exploitation parameters")
        table.add_row("0", "Back", "Return to main menu")
        
        self.console.print(table)
        
        # Show active sessions if any
        if self.sessions:
            self.console.print(f"\n[green]Active Sessions: {len(self.sessions)}[/]")
            
    def _web_exploitation_menu(self, url: str = None, vuln_type: str = None):
        """Web application exploitation submenu."""
        self.console.print("\n[bold green]Web Application Exploitation[/]")
        
        if not url:
            url = Prompt.ask("[cyan]Enter target URL")
            
        # Validate URL
        if not self.utils.validate_url(url):
            self.console.print("[red]Invalid URL format.[/]")
            return
            
        # Vulnerability type selection
        if not vuln_type:
            vuln_types = {
                "1": ("sqli", "SQL Injection"),
                "2": ("xss", "Cross-Site Scripting (XSS)"),
                "3": ("rce", "Remote Code Execution"),
                "4": ("lfi", "Local File Inclusion"),
                "5": ("rfi", "Remote File Inclusion"),
                "6": ("xxe", "XML External Entity (XXE)"),
                "7": ("ssrf", "Server-Side Request Forgery"),
                "8": ("deserialization", "Insecure Deserialization"),
                "9": ("command_injection", "Command Injection"),
                "10": ("template_injection", "Template Injection"),
                "11": ("directory_traversal", "Directory Traversal"),
                "12": ("auto", "Automatic exploitation (all types)")
            }
            
            self.console.print("\n[bold yellow]Web Vulnerability Types:[/]")
            for key, (vuln_id, desc) in vuln_types.items():
                self.console.print(f"[yellow]{key}[/] - {desc}")
                
            vuln_choice = Prompt.ask(
                "[cyan]Select vulnerability type[/]",
                choices=list(vuln_types.keys()),
                default="12"
            )
            
            vuln_type = vuln_types[vuln_choice][0]
            
        # Configuration
        config = {
            'url': url,
            'vuln_type': vuln_type,
            'threads': IntPrompt.ask("[cyan]Number of threads", default=5),
            'timeout': IntPrompt.ask("[cyan]Request timeout (seconds)", default=10),
            'verify_ssl': Confirm.ask("[cyan]Verify SSL certificates?[/]", default=False)
        }
        
        # Authentication
        if Confirm.ask("[cyan]Configure authentication?[/]", default=False):
            auth_type = Prompt.ask(
                "[cyan]Authentication type[/]",
                choices=["form", "basic", "bearer", "cookie"],
                default="form"
            )
            
            config['auth'] = {'type': auth_type}
            
            if auth_type == "form":
                config['auth']['login_url'] = Prompt.ask("[cyan]Login URL")
                config['auth']['username'] = Prompt.ask("[cyan]Username")
                config['auth']['password'] = Prompt.ask("[cyan]Password", password=True)
            elif auth_type == "basic":
                config['auth']['username'] = Prompt.ask("[cyan]Username")
                config['auth']['password'] = Prompt.ask("[cyan]Password", password=True)
            elif auth_type == "bearer":
                config['auth']['token'] = Prompt.ask("[cyan]Bearer token", password=True)
            elif auth_type == "cookie":
                config['auth']['cookies'] = Prompt.ask("[cyan]Cookie string")
                
        # Exploitation options
        config['blind_exploitation'] = Confirm.ask("[cyan]Enable blind exploitation techniques?[/]", default=True)
        config['payload_encoding'] = Confirm.ask("[cyan]Use payload encoding/obfuscation?[/]", default=True)
        config['custom_headers'] = {}
        
        if Confirm.ask("[cyan]Add custom headers?[/]", default=False):
            while True:
                header_name = Prompt.ask("[cyan]Header name (or Enter to finish)", default="")
                if not header_name:
                    break
                header_value = Prompt.ask(f"[cyan]Value for {header_name}")
                config['custom_headers'][header_name] = header_value
                
        self._execute_web_exploitation(config)
        
    def _execute_web_exploitation(self, config: Dict[str, Any]):
        """Execute web application exploitation."""
        url = config['url']
        vuln_type = config['vuln_type']
        
        self.console.print(f"\n[green]Starting {vuln_type} exploitation on: {url}[/]")
        
        if not self.utils.confirm_dangerous_action(f"exploit {vuln_type} vulnerability"):
            return
            
        exploit_id = f"web_{len(self.active_exploits) + 1}"
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            console=self.console
        ) as progress:
            
            if vuln_type == "auto":
                # Automatic exploitation - try multiple vulnerability types
                task = progress.add_task("Running automatic exploitation...", total=100)
                
                try:
                    result = self.web_exploiter.auto_exploit(
                        url,
                        config,
                        progress_callback=lambda p: progress.update(task, completed=p)
                    )
                    progress.update(task, completed=100, description="Auto exploitation completed")
                except Exception as e:
                    self.console.print(f"[red]Auto exploitation failed: {e}[/]")
                    return
            else:
                # Specific vulnerability exploitation
                task = progress.add_task(f"Exploiting {vuln_type}...", total=100)
                
                try:
                    if vuln_type == "sqli":
                        result = self.web_exploiter.exploit_sql_injection(
                            url,
                            config,
                            progress_callback=lambda p: progress.update(task, completed=p)
                        )
                    elif vuln_type == "xss":
                        result = self.web_exploiter.exploit_xss(
                            url,
                            config,
                            progress_callback=lambda p: progress.update(task, completed=p)
                        )
                    elif vuln_type == "rce":
                        result = self.web_exploiter.exploit_rce(
                            url,
                            config,
                            progress_callback=lambda p: progress.update(task, completed=p)
                        )
                    else:
                        result = self.web_exploiter.exploit_generic(
                            url,
                            vuln_type,
                            config,
                            progress_callback=lambda p: progress.update(task, completed=p)
                        )
                        
                    progress.update(task, completed=100, description=f"{vuln_type} exploitation completed")
                    
                except Exception as e:
                    self.console.print(f"[red]{vuln_type} exploitation failed: {e}[/]")
                    return
                    
        # Store results
        if 'web_exploits' not in self.exploit_results:
            self.exploit_results['web_exploits'] = []
            
        exploit_result = {
            'exploit_id': exploit_id,
            'url': url,
            'vuln_type': vuln_type,
            'timestamp': datetime.now(),
            'config': config,
            'result': result
        }
        
        self.exploit_results['web_exploits'].append(exploit_result)
        
        # Display results
        self._display_web_exploit_results(result)
        
        # Handle successful exploitation
        if result.get('success') and result.get('shell'):
            session_id = f"web_shell_{len(self.sessions) + 1}"
            self.sessions[session_id] = {
                'type': 'web_shell',
                'target': url,
                'shell_info': result['shell'],
                'timestamp': datetime.now()
            }
            self.console.print(f"[green]✅ Web shell established! Session ID: {session_id}[/]")
            
        # Save to file option
        if Confirm.ask("[cyan]Save exploit results to file?[/]"):
            filename = f"web_exploit_{url.replace('://', '_').replace('/', '_')}_{vuln_type}.json"
            self.utils.save_results_to_file(exploit_result, filename)
            
    def _display_web_exploit_results(self, result: Dict[str, Any]):
        """Display web exploitation results."""
        if result.get('success'):
            self.console.print(f"\n[green]✅ Exploitation Successful![/]")
            
            # Success details
            success_table = Table(title="Exploitation Results")
            success_table.add_column("Property", style="cyan")
            success_table.add_column("Value", style="white")
            
            success_table.add_row("Status", "[green]Success[/]")
            success_table.add_row("Vulnerability", result.get('vulnerability', 'N/A'))
            success_table.add_row("Payload Used", result.get('payload', 'N/A')[:50])
            success_table.add_row("Response Time", f"{result.get('response_time', 0):.2f}s")
            
            if result.get('data_extracted'):
                success_table.add_row("Data Extracted", f"{len(result['data_extracted'])} items")
                
            if result.get('shell'):
                success_table.add_row("Shell Type", result['shell'].get('type', 'Unknown'))
                success_table.add_row("Shell URL", result['shell'].get('url', 'N/A'))
                
            self.console.print(success_table)
            
            # Show extracted data if any
            if result.get('data_extracted'):
                self._display_extracted_data(result['data_extracted'])
                
        else:
            self.console.print(f"\n[red]❌ Exploitation Failed[/]")
            if result.get('error'):
                self.console.print(f"[red]Error: {result['error']}[/]")
            if result.get('attempts'):
                self.console.print(f"[yellow]Attempts made: {result['attempts']}[/]")
                
    def _display_extracted_data(self, data: List[Dict[str, Any]]):
        """Display extracted data from successful exploitation."""
        if not data:
            return
            
        self.console.print(f"\n[cyan]Extracted Data ({len(data)} items):[/]")
        
        # Show first few items
        for i, item in enumerate(data[:10], 1):
            if isinstance(item, dict):
                self.console.print(f"[yellow]{i}.[/] {item}")
            else:
                self.console.print(f"[yellow]{i}.[/] {str(item)[:100]}")
                
        if len(data) > 10:
            self.console.print(f"[dim]... and {len(data) - 10} more items[/]")
            
    def _network_exploitation_menu(self, target: str = None, service: str = None):
        """Network service exploitation submenu."""
        self.console.print("\n[bold green]Network Service Exploitation[/]")
        
        if not target:
            target = Prompt.ask("[cyan]Enter target host")
            
        # Validate target
        if not self.utils.validate_target(target):
            self.console.print("[red]Invalid target format.[/]")
            return
            
        # Service selection
        if not service:
            services = {
                "1": ("ssh", "SSH Service (port 22)"),
                "2": ("ftp", "FTP Service (port 21)"),
                "3": ("telnet", "Telnet Service (port 23)"),
                "4": ("smtp", "SMTP Service (port 25)"),
                "5": ("http", "HTTP Service (port 80/443)"),
                "6": ("smb", "SMB Service (port 445)"),
                "7": ("rdp", "RDP Service (port 3389)"),
                "8": ("mysql", "MySQL Service (port 3306)"),
                "9": ("mssql", "MS SQL Service (port 1433)"),
                "10": ("oracle", "Oracle Service (port 1521)"),
                "11": ("snmp", "SNMP Service (port 161)"),
                "12": ("custom", "Custom service/port"),
                "13": ("auto", "Automatic service detection and exploitation")
            }
            
            self.console.print("\n[bold yellow]Network Services:[/]")
            for key, (service_id, desc) in services.items():
                self.console.print(f"[yellow]{key}[/] - {desc}")
                
            service_choice = Prompt.ask(
                "[cyan]Select service type[/]",
                choices=list(services.keys()),
                default="13"
            )
            
            service = services[service_choice][0]
            
        # Configuration
        config = {
            'target': target,
            'service': service,
            'threads': IntPrompt.ask("[cyan]Number of threads", default=10),
            'timeout': IntPrompt.ask("[cyan]Connection timeout (seconds)", default=10)
        }
        
        # Service-specific configuration
        if service == "custom":
            config['port'] = IntPrompt.ask("[cyan]Target port")
            config['protocol'] = Prompt.ask("[cyan]Protocol", choices=["tcp", "udp"], default="tcp")
        elif service != "auto":
            # Get default port for service
            default_ports = {
                "ssh": 22, "ftp": 21, "telnet": 23, "smtp": 25,
                "http": 80, "smb": 445, "rdp": 3389, "mysql": 3306,
                "mssql": 1433, "oracle": 1521, "snmp": 161
            }
            config['port'] = IntPrompt.ask(f"[cyan]Port (default: {default_ports.get(service, 'unknown')})", default=default_ports.get(service, 80))
            
        # Exploitation options
        config['brute_force'] = Confirm.ask("[cyan]Enable brute force attacks?[/]", default=True)
        if config['brute_force']:
            config['username_list'] = self.utils.prompt_for_wordlist("usernames") if Confirm.ask("[cyan]Use username wordlist?[/]") else None
            config['password_list'] = self.utils.prompt_for_wordlist("passwords") if Confirm.ask("[cyan]Use password wordlist?[/]") else None
            
        config['exploit_vulns'] = Confirm.ask("[cyan]Exploit known vulnerabilities?[/]", default=True)
        config['default_creds'] = Confirm.ask("[cyan]Try default credentials?[/]", default=True)
        
        self._execute_network_exploitation(config)
        
    def _execute_network_exploitation(self, config: Dict[str, Any]):
        """Execute network service exploitation."""
        target = config['target']
        service = config['service']
        
        self.console.print(f"\n[green]Starting {service} exploitation on: {target}[/]")
        
        if not self.utils.confirm_dangerous_action(f"exploit {service} service"):
            return
            
        exploit_id = f"network_{len(self.active_exploits) + 1}"
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            console=self.console
        ) as progress:
            
            task = progress.add_task(f"Exploiting {service} service...", total=100)
            
            try:
                result = self.network_exploiter.exploit_service(
                    target,
                    service,
                    config,
                    progress_callback=lambda p: progress.update(task, completed=p)
                )
                
                progress.update(task, completed=100, description=f"{service} exploitation completed")
                
            except Exception as e:
                self.console.print(f"[red]{service} exploitation failed: {e}[/]")
                return
                
        # Store results
        if 'network_exploits' not in self.exploit_results:
            self.exploit_results['network_exploits'] = []
            
        exploit_result = {
            'exploit_id': exploit_id,
            'target': target,
            'service': service,
            'timestamp': datetime.now(),
            'config': config,
            'result': result
        }
        
        self.exploit_results['network_exploits'].append(exploit_result)
        
        # Display results
        self._display_network_exploit_results(result)
        
        # Handle successful exploitation
        if result.get('success') and result.get('access'):
            session_id = f"network_session_{len(self.sessions) + 1}"
            self.sessions[session_id] = {
                'type': 'network_access',
                'target': target,
                'service': service,
                'access_info': result['access'],
                'timestamp': datetime.now()
            }
            self.console.print(f"[green]✅ Network access established! Session ID: {session_id}[/]")
            
        # Save to file option
        if Confirm.ask("[cyan]Save exploit results to file?[/]"):
            filename = f"network_exploit_{target}_{service}.json"
            self.utils.save_results_to_file(exploit_result, filename)
            
    def _display_network_exploit_results(self, result: Dict[str, Any]):
        """Display network exploitation results."""
        if result.get('success'):
            self.console.print(f"\n[green]✅ Network Exploitation Successful![/]")
            
            # Success details
            success_table = Table(title="Network Exploitation Results")
            success_table.add_column("Property", style="cyan")
            success_table.add_column("Value", style="white")
            
            success_table.add_row("Status", "[green]Success[/]")
            success_table.add_row("Service", result.get('service', 'N/A'))
            success_table.add_row("Method", result.get('method', 'N/A'))
            success_table.add_row("Credentials", result.get('credentials', 'N/A'))
            
            if result.get('access'):
                access_info = result['access']
                success_table.add_row("Access Type", access_info.get('type', 'Unknown'))
                success_table.add_row("Privileges", access_info.get('privileges', 'Unknown'))
                
            self.console.print(success_table)
            
        else:
            self.console.print(f"\n[red]❌ Network Exploitation Failed[/]")
            if result.get('error'):
                self.console.print(f"[red]Error: {result['error']}[/]")
            if result.get('attempts'):
                self.console.print(f"[yellow]Attempts made: {result['attempts']}[/]")
                
    def _binary_exploitation_menu(self, target: str = None):
        """Binary exploitation submenu."""
        self.console.print("\n[bold green]Binary Exploitation[/]")
        
        if not target:
            target = Prompt.ask("[cyan]Enter target (IP:port or binary path)")
            
        # Exploitation type
        exploit_types = {
            "1": ("buffer_overflow", "Buffer Overflow"),
            "2": ("format_string", "Format String Vulnerability"),
            "3": ("heap_overflow", "Heap Overflow"),
            "4": ("use_after_free", "Use After Free"),
            "5": ("rop_chain", "Return Oriented Programming"),
            "6": ("shellcode_injection", "Shellcode Injection"),
            "7": ("custom", "Custom Binary Exploitation")
        }
        
        self.console.print("\n[bold yellow]Binary Exploitation Types:[/]")
        for key, (exploit_id, desc) in exploit_types.items():
            self.console.print(f"[yellow]{key}[/] - {desc}")
            
        exploit_choice = Prompt.ask(
            "[cyan]Select exploitation type[/]",
            choices=list(exploit_types.keys()),
            default="1"
        )
        
        exploit_type = exploit_types[exploit_choice][0]
        
        # Configuration
        config = {
            'target': target,
            'exploit_type': exploit_type,
            'architecture': Prompt.ask("[cyan]Target architecture", choices=["x86", "x64", "arm", "auto"], default="auto"),
            'operating_system': Prompt.ask("[cyan]Target OS", choices=["linux", "windows", "auto"], default="auto")
        }
        
        # Payload configuration
        config['payload_type'] = Prompt.ask(
            "[cyan]Payload type[/]",
            choices=["reverse_shell", "bind_shell", "meterpreter", "custom"],
            default="reverse_shell"
        )
        
        if config['payload_type'] in ["reverse_shell", "meterpreter"]:
            config['lhost'] = Prompt.ask("[cyan]Local host (LHOST)")
            config['lport'] = IntPrompt.ask("[cyan]Local port (LPORT)", default=4444)
        elif config['payload_type'] == "bind_shell":
            config['rport'] = IntPrompt.ask("[cyan]Remote port (RPORT)", default=4444)
            
        # Advanced options
        config['aslr_bypass'] = Confirm.ask("[cyan]Enable ASLR bypass techniques?[/]", default=True)
        config['dep_bypass'] = Confirm.ask("[cyan]Enable DEP/NX bypass techniques?[/]", default=True)
        config['stack_canary_bypass'] = Confirm.ask("[cyan]Enable stack canary bypass?[/]", default=True)
        
        self._execute_binary_exploitation(config)
        
    def _execute_binary_exploitation(self, config: Dict[str, Any]):
        """Execute binary exploitation."""
        target = config['target']
        exploit_type = config['exploit_type']
        
        self.console.print(f"\n[green]Starting {exploit_type} exploitation on: {target}[/]")
        
        if not self.utils.confirm_dangerous_action(f"perform {exploit_type} exploitation"):
            return
            
        exploit_id = f"binary_{len(self.active_exploits) + 1}"
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            console=self.console
        ) as progress:
            
            task = progress.add_task(f"Running {exploit_type} exploit...", total=100)
            
            try:
                result = self.binary_exploiter.exploit_binary(
                    target,
                    exploit_type,
                    config,
                    progress_callback=lambda p: progress.update(task, completed=p)
                )
                
                progress.update(task, completed=100, description=f"{exploit_type} exploitation completed")
                
            except Exception as e:
                self.console.print(f"[red]Binary exploitation failed: {e}[/]")
                return
                
        # Store and display results
        exploit_result = {
            'exploit_id': exploit_id,
            'target': target,
            'exploit_type': exploit_type,
            'timestamp': datetime.now(),
            'config': config,
            'result': result
        }
        
        if 'binary_exploits' not in self.exploit_results:
            self.exploit_results['binary_exploits'] = []
        self.exploit_results['binary_exploits'].append(exploit_result)
        
        self._display_binary_exploit_results(result)
        
        # Handle successful exploitation
        if result.get('success') and result.get('shell'):
            session_id = f"binary_shell_{len(self.sessions) + 1}"
            self.sessions[session_id] = {
                'type': 'binary_shell',
                'target': target,
                'shell_info': result['shell'],
                'timestamp': datetime.now()
            }
            self.console.print(f"[green]✅ Binary shell established! Session ID: {session_id}[/]")
            
    def _display_binary_exploit_results(self, result: Dict[str, Any]):
        """Display binary exploitation results."""
        if result.get('success'):
            self.console.print(f"\n[green]✅ Binary Exploitation Successful![/]")
            
            exploit_table = Table(title="Binary Exploitation Results")
            exploit_table.add_column("Property", style="cyan")
            exploit_table.add_column("Value", style="white")
            
            exploit_table.add_row("Status", "[green]Success[/]")
            exploit_table.add_row("Exploit Used", result.get('exploit', 'N/A'))
            exploit_table.add_row("Payload", result.get('payload', 'N/A'))
            exploit_table.add_row("Return Address", result.get('return_address', 'N/A'))
            
            if result.get('shell'):
                exploit_table.add_row("Shell Type", result['shell'].get('type', 'Unknown'))
                exploit_table.add_row("Connection", result['shell'].get('connection', 'N/A'))
                
            self.console.print(exploit_table)
        else:
            self.console.print(f"\n[red]❌ Binary Exploitation Failed[/]")
            if result.get('error'):
                self.console.print(f"[red]Error: {result['error']}[/]")
                
    def _social_engineering_menu(self, campaign_type: str = None):
        """Social engineering submenu."""
        self.console.print("\n[bold green]Social Engineering Operations[/]")
        
        # Legal warning
        self.console.print("[red]⚠️ WARNING: Social engineering attacks must only be performed against authorized targets with proper written consent.[/]")
        if not Confirm.ask("[cyan]Do you have authorization for social engineering attacks?[/]"):
            return
            
        if not campaign_type:
            campaign_types = {
                "1": ("phishing_email", "Email Phishing Campaign"),
                "2": ("spear_phishing", "Spear Phishing (Targeted)"),
                "3": ("smishing", "SMS Phishing (Smishing)"),
                "4": ("vishing", "Voice Phishing (Vishing)"),
                "5": ("credential_harvester", "Credential Harvesting Site"),
                "6": ("usb_drop", "USB Drop Attack"),
                "7": ("pretexting", "Pretexting Campaign")
            }
            
            self.console.print("\n[bold yellow]Social Engineering Campaign Types:[/]")
            for key, (campaign_id, desc) in campaign_types.items():
                self.console.print(f"[yellow]{key}[/] - {desc}")
                
            campaign_choice = Prompt.ask(
                "[cyan]Select campaign type[/]",
                choices=list(campaign_types.keys()),
                default="1"
            )
            
            campaign_type = campaign_types[campaign_choice][0]
            
        # Configuration
        config = {
            'campaign_type': campaign_type,
            'target_organization': Prompt.ask("[cyan]Target organization name"),
            'campaign_name': Prompt.ask("[cyan]Campaign name", default=f"{campaign_type}_{datetime.now().strftime('%Y%m%d')}")
        }
        
        # Campaign-specific configuration
        if campaign_type in ["phishing_email", "spear_phishing"]:
            config['email_template'] = Prompt.ask("[cyan]Email template", choices=["corporate", "social_media", "shipping", "security_alert", "custom"], default="security_alert")
            config['sender_domain'] = Prompt.ask("[cyan]Sender domain", default="legitimate-looking-domain.com")
            config['target_emails'] = Prompt.ask("[cyan]Target email addresses (comma-separated)").split(',')
            
        elif campaign_type == "credential_harvester":
            config['target_site'] = Prompt.ask("[cyan]Site to clone (URL)")
            config['harvester_port'] = IntPrompt.ask("[cyan]Harvester port", default=8080)
            config['redirect_url'] = Prompt.ask("[cyan]Redirect after harvest", default="https://google.com")
            
        self._execute_social_engineering(config)
        
    def _execute_social_engineering(self, config: Dict[str, Any]):
        """Execute social engineering campaign."""
        campaign_type = config['campaign_type']
        
        self.console.print(f"\n[green]Starting {campaign_type} campaign: {config['campaign_name']}[/]")
        
        campaign_id = f"social_{len(self.active_exploits) + 1}"
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            console=self.console
        ) as progress:
            
            task = progress.add_task(f"Setting up {campaign_type}...", total=100)
            
            try:
                result = self.social_engineer.run_campaign(
                    campaign_type,
                    config,
                    progress_callback=lambda p: progress.update(task, completed=p)
                )
                
                progress.update(task, completed=100, description=f"{campaign_type} campaign launched")
                
            except Exception as e:
                self.console.print(f"[red]Social engineering campaign failed: {e}[/]")
                return
                
        # Store and display results
        campaign_result = {
            'campaign_id': campaign_id,
            'campaign_type': campaign_type,
            'timestamp': datetime.now(),
            'config': config,
            'result': result
        }
        
        if 'social_campaigns' not in self.exploit_results:
            self.exploit_results['social_campaigns'] = []
        self.exploit_results['social_campaigns'].append(campaign_result)
        
        self._display_social_engineering_results(result)
        
    def _display_social_engineering_results(self, result: Dict[str, Any]):
        """Display social engineering campaign results."""
        if result.get('success'):
            self.console.print(f"\n[green]✅ Social Engineering Campaign Launched![/]")
            
            campaign_table = Table(title="Campaign Status")
            campaign_table.add_column("Property", style="cyan")
            campaign_table.add_column("Value", style="white")
            
            campaign_table.add_row("Status", "[green]Active[/]")
            campaign_table.add_row("Campaign URL", result.get('campaign_url', 'N/A'))
            campaign_table.add_row("Targets", str(result.get('target_count', 0)))
            campaign_table.add_row("Emails Sent", str(result.get('emails_sent', 0)))
            
            self.console.print(campaign_table)
            
            if result.get('campaign_url'):
                self.console.print(f"\n[cyan]Campaign is accessible at: {result['campaign_url']}[/]")
                self.console.print("[yellow]Monitor campaign results in the social engineering dashboard.[/]")
        else:
            self.console.print(f"\n[red]❌ Social Engineering Campaign Failed[/]")
            if result.get('error'):
                self.console.print(f"[red]Error: {result['error']}[/]")
                
    def _wireless_exploitation_menu(self, interface: str = None):
        """Wireless exploitation submenu."""
        self.console.print("\n[bold green]Wireless Network Exploitation[/]")
        
        # Check for wireless interface
        interfaces = self.wireless_exploiter.get_wireless_interfaces()
        
        if not interfaces:
            self.console.print("[red]No wireless interfaces found.[/]")
            return
            
        if not interface:
            if len(interfaces) == 1:
                interface = interfaces[0]
            else:
                self.console.print("\n[yellow]Available wireless interfaces:[/]")
                for i, iface in enumerate(interfaces, 1):
                    self.console.print(f"[yellow]{i}[/] - {iface}")
                    
                choice = IntPrompt.ask(f"[cyan]Select interface[/] (1-{len(interfaces)})", default=1)
                interface = interfaces[choice - 1]
                
        # Attack type selection
        attack_types = {
            "1": ("wpa_crack", "WPA/WPA2 Password Cracking"),
            "2": ("wep_crack", "WEP Key Cracking"),
            "3": ("evil_twin", "Evil Twin Attack"),
            "4": ("deauth_attack", "Deauthentication Attack"),
            "5": ("wps_attack", "WPS PIN Attack"),
            "6": ("capture_handshake", "Capture WPA Handshake"),
            "7": ("wifi_pineapple", "WiFi Pineapple Attack")
        }
        
        self.console.print("\n[bold yellow]Wireless Attack Types:[/]")
        for key, (attack_id, desc) in attack_types.items():
            self.console.print(f"[yellow]{key}[/] - {desc}")
            
        attack_choice = Prompt.ask(
            "[cyan]Select attack type[/]",
            choices=list(attack_types.keys()),
            default="1"
        )
        
        attack_type = attack_types[attack_choice][0]
        
        # Configuration
        config = {
            'interface': interface,
            'attack_type': attack_type
        }
        
        # Attack-specific configuration
        if attack_type in ["wpa_crack", "wep_crack"]:
            config['target_ssid'] = Prompt.ask("[cyan]Target SSID (or 'auto' for strongest signal)", default="auto")
            if attack_type == "wpa_crack":
                config['wordlist'] = self.utils.prompt_for_wordlist("passwords")
                config['capture_timeout'] = IntPrompt.ask("[cyan]Handshake capture timeout (seconds)", default=300)
        elif attack_type == "evil_twin":
            config['target_ssid'] = Prompt.ask("[cyan]Target SSID to clone")
            config['portal_type'] = Prompt.ask("[cyan]Portal type", choices=["captive", "fake_login", "firmware_update"], default="captive")
        elif attack_type == "deauth_attack":
            config['target_ssid'] = Prompt.ask("[cyan]Target SSID")
            config['target_client'] = Prompt.ask("[cyan]Target client MAC (or 'broadcast')", default="broadcast")
            config['packet_count'] = IntPrompt.ask("[cyan]Deauth packet count", default=100)
            
        self._execute_wireless_exploitation(config)
        
    def _execute_wireless_exploitation(self, config: Dict[str, Any]):
        """Execute wireless exploitation."""
        interface = config['interface']
        attack_type = config['attack_type']
        
        self.console.print(f"\n[green]Starting {attack_type} on interface: {interface}[/]")
        
        if not self.utils.confirm_dangerous_action(f"perform {attack_type} attack"):
            return
            
        exploit_id = f"wireless_{len(self.active_exploits) + 1}"
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            console=self.console
        ) as progress:
            
            task = progress.add_task(f"Running {attack_type}...", total=100)
            
            try:
                result = self.wireless_exploiter.run_attack(
                    attack_type,
                    config,
                    progress_callback=lambda p: progress.update(task, completed=p)
                )
                
                progress.update(task, completed=100, description=f"{attack_type} completed")
                
            except Exception as e:
                self.console.print(f"[red]Wireless exploitation failed: {e}[/]")
                return
                
        # Store and display results
        exploit_result = {
            'exploit_id': exploit_id,
            'interface': interface,
            'attack_type': attack_type,
            'timestamp': datetime.now(),
            'config': config,
            'result': result
        }
        
        if 'wireless_exploits' not in self.exploit_results:
            self.exploit_results['wireless_exploits'] = []
        self.exploit_results['wireless_exploits'].append(exploit_result)
        
        self._display_wireless_exploit_results(result)
        
    def _display_wireless_exploit_results(self, result: Dict[str, Any]):
        """Display wireless exploitation results."""
        if result.get('success'):
            self.console.print(f"\n[green]✅ Wireless Exploitation Successful![/]")
            
            wireless_table = Table(title="Wireless Attack Results")
            wireless_table.add_column("Property", style="cyan")
            wireless_table.add_column("Value", style="white")
            
            wireless_table.add_row("Status", "[green]Success[/]")
            wireless_table.add_row("Attack Type", result.get('attack_type', 'N/A'))
            wireless_table.add_row("Target SSID", result.get('target_ssid', 'N/A'))
            
            if result.get('password_cracked'):
                wireless_table.add_row("Password", result['password_cracked'])
            if result.get('handshake_captured'):
                wireless_table.add_row("Handshake File", result['handshake_captured'])
            if result.get('clients_deauthed'):
                wireless_table.add_row("Clients Deauthed", str(result['clients_deauthed']))
                
            self.console.print(wireless_table)
        else:
            self.console.print(f"\n[red]❌ Wireless Exploitation Failed[/]")
            if result.get('error'):
                self.console.print(f"[red]Error: {result['error']}[/]")
                
    def _payload_generation_menu(self, payload_type: str = None):
        """Payload generation submenu."""
        self.console.print("\n[bold green]Payload Generation[/]")
        
        if not payload_type:
            payload_types = {
                "1": ("reverse_shell", "Reverse Shell Payload"),
                "2": ("bind_shell", "Bind Shell Payload"),
                "3": ("meterpreter", "Meterpreter Payload"),
                "4": ("web_shell", "Web Shell"),
                "5": ("powershell", "PowerShell Payload"),
                "6": ("python", "Python Payload"),
                "7": ("java", "Java Payload"),
                "8": ("android", "Android APK Payload"),
                "9": ("windows_exe", "Windows Executable"),
                "10": ("custom_shellcode", "Custom Shellcode")
            }
            
            self.console.print("\n[bold yellow]Payload Types:[/]")
            for key, (payload_id, desc) in payload_types.items():
                self.console.print(f"[yellow]{key}[/] - {desc}")
                
            payload_choice = Prompt.ask(
                "[cyan]Select payload type[/]",
                choices=list(payload_types.keys()),
                default="1"
            )
            
            payload_type = payload_types[payload_choice][0]
            
        # Payload configuration
        config = {
            'payload_type': payload_type,
            'architecture': Prompt.ask("[cyan]Target architecture", choices=["x86", "x64", "auto"], default="auto"),
            'operating_system': Prompt.ask("[cyan]Target OS", choices=["windows", "linux", "android", "auto"], default="auto")
        }
        
        # Connection configuration
        if payload_type in ["reverse_shell", "meterpreter"]:
            config['lhost'] = Prompt.ask("[cyan]Local host (LHOST)")
            config['lport'] = IntPrompt.ask("[cyan]Local port (LPORT)", default=4444)
        elif payload_type == "bind_shell":
            config['rport'] = IntPrompt.ask("[cyan]Remote port (RPORT)", default=4444)
            
        # Encoding and evasion
        config['encoding'] = Prompt.ask(
            "[cyan]Payload encoding[/]",
            choices=["none", "base64", "hex", "xor", "custom"],
            default="none"
        )
        config['evasion'] = Confirm.ask("[cyan]Enable AV evasion techniques?[/]", default=False)
        config['obfuscation'] = Confirm.ask("[cyan]Enable code obfuscation?[/]", default=False)
        
        # Format selection
        if payload_type in ["windows_exe", "android"]:
            config['output_format'] = payload_type
        else:
            config['output_format'] = Prompt.ask(
                "[cyan]Output format[/]",
                choices=["raw", "executable", "script", "c_code", "python"],
                default="raw"
            )
            
        self._generate_payload(config)
        
    def _generate_payload(self, config: Dict[str, Any]):
        """Generate custom payload."""
        payload_type = config['payload_type']
        
        self.console.print(f"\n[green]Generating {payload_type} payload...[/]")
        
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=self.console
        ) as progress:
            
            task = progress.add_task("Generating payload...", total=None)
            
            try:
                # Use appropriate exploiter based on payload type
                if payload_type in ["web_shell"]:
                    payload_data = self.web_exploiter.generate_payload(config)
                elif payload_type in ["reverse_shell", "bind_shell", "meterpreter"]:
                    payload_data = self.network_exploiter.generate_payload(config)
                else:
                    payload_data = self.binary_exploiter.generate_payload(config)
                    
                progress.update(task, description="Payload generated successfully")
                
            except Exception as e:
                self.console.print(f"[red]Payload generation failed: {e}[/]")
                return
                
        # Display payload information
        self._display_payload_info(payload_data, config)
        
        # Save payload
        if Confirm.ask("[cyan]Save payload to file?[/]"):
            filename = Prompt.ask(
                "[cyan]Filename[/]",
                default=f"{payload_type}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.{config.get('output_format', 'bin')}"
            )
            self.utils.save_payload_to_file(payload_data, filename)
            
    def _display_payload_info(self, payload_data: Dict[str, Any], config: Dict[str, Any]):
        """Display generated payload information."""
        self.console.print(f"\n[green]✅ Payload Generated Successfully![/]")
        
        payload_table = Table(title="Payload Information")
        payload_table.add_column("Property", style="cyan")
        payload_table.add_column("Value", style="white")
        
        payload_table.add_row("Type", config['payload_type'])
        payload_table.add_row("Architecture", config.get('architecture', 'N/A'))
        payload_table.add_row("OS", config.get('operating_system', 'N/A'))
        payload_table.add_row("Size", f"{payload_data.get('size', 0)} bytes")
        payload_table.add_row("Format", config.get('output_format', 'raw'))
        payload_table.add_row("Encoding", config.get('encoding', 'none'))
        
        if config.get('lhost'):
            payload_table.add_row("LHOST", config['lhost'])
        if config.get('lport'):
            payload_table.add_row("LPORT", str(config['lport']))
            
        self.console.print(payload_table)
        
        # Show payload preview if it's text-based
        if payload_data.get('preview'):
            self.console.print(f"\n[cyan]Payload Preview:[/]")
            self.console.print(f"[dim]{payload_data['preview'][:200]}...[/]")
            
    def _session_management_menu(self):
        """Session management submenu."""
        self.console.print("\n[bold green]Session Management[/]")
        
        if not self.sessions:
            self.console.print("[yellow]No active sessions.[/]")
            return
            
        # Display active sessions
        sessions_table = Table(title="Active Sessions")
        sessions_table.add_column("ID", style="yellow")
        sessions_table.add_column("Type", style="green")
        sessions_table.add_column("Target", style="cyan")
        sessions_table.add_column("Established", style="dim")
        sessions_table.add_column("Status", style="bold")
        
        for session_id, session_info in self.sessions.items():
            sessions_table.add_row(
                session_id,
                session_info.get('type', 'Unknown'),
                session_info.get('target', 'N/A'),
                str(session_info.get('timestamp', 'N/A')),
                "[green]Active[/]"
            )
            
        self.console.print(sessions_table)
        
        # Session actions
        if Confirm.ask("[cyan]Interact with a session?[/]"):
            session_id = Prompt.ask("[cyan]Enter session ID")
            
            if session_id in self.sessions:
                self._interact_with_session(session_id)
            else:
                self.console.print("[red]Invalid session ID.[/]")
                
    def _interact_with_session(self, session_id: str):
        """Interact with a specific session."""
        session = self.sessions[session_id]
        session_type = session.get('type', 'unknown')
        
        self.console.print(f"\n[green]Interacting with {session_type} session: {session_id}[/]")
        
        # Session-specific interactions
        actions = {
            "1": ("execute", "Execute command"),
            "2": ("upload", "Upload file"),
            "3": ("download", "Download file"),
            "4": ("info", "Session information"),
            "5": ("terminate", "Terminate session")
        }
        
        self.console.print("\n[bold yellow]Session Actions:[/]")
        for key, (action_id, desc) in actions.items():
            self.console.print(f"[yellow]{key}[/] - {desc}")
            
        action_choice = Prompt.ask("[cyan]Select action[/]", choices=list(actions.keys()), default="1")
        action = actions[action_choice][0]
        
        if action == "execute":
            command = Prompt.ask("[cyan]Enter command to execute")
            # Execute command in session (implementation depends on session type)
            self.console.print(f"[green]Executing: {command}[/]")
        elif action == "info":
            # Display detailed session information
            for key, value in session.items():
                self.console.print(f"[cyan]{key}:[/] {value}")
        elif action == "terminate":
            if Confirm.ask(f"[red]Terminate session {session_id}?[/]"):
                del self.sessions[session_id]
                self.console.print(f"[green]Session {session_id} terminated.[/]")
                
    def _show_results(self):
        """Display all exploitation results."""
        if not self.exploit_results:
            self.console.print("[yellow]No exploitation results available.[/]")
            return
            
        self.console.print("\n[bold red]Exploitation Results Summary[/]")
        
        total_exploits = 0
        successful_exploits = 0
        
        for exploit_type, results in self.exploit_results.items():
            self.console.print(f"\n[green]{exploit_type.replace('_', ' ').title()}: {len(results)} attempts[/]")
            
            type_successful = 0
            for result in results:
                total_exploits += 1
                if result.get('result', {}).get('success'):
                    type_successful += 1
                    successful_exploits += 1
                    
            success_rate = (type_successful / len(results) * 100) if results else 0
            self.console.print(f"  Success rate: {success_rate:.1f}% ({type_successful}/{len(results)})")
            
        overall_success_rate = (successful_exploits / total_exploits * 100) if total_exploits > 0 else 0
        self.console.print(f"\n[bold red]Overall Success Rate: {overall_success_rate:.1f}% ({successful_exploits}/{total_exploits})[/]")
        
        # Show active sessions
        if self.sessions:
            self.console.print(f"\n[green]Active Sessions: {len(self.sessions)}[/]")
            for session_id, session in self.sessions.items():
                self.console.print(f"  {session_id}: {session.get('type')} on {session.get('target')}")
                
    def _advanced_options(self):
        """Advanced exploitation configuration."""
        self.console.print("[yellow]Advanced exploitation options not yet implemented.[/]")
        
    def _show_help(self):
        """Display help information."""
        help_text = """
[bold red]Exploitation Module Help[/]

[bold yellow]Available Commands:[/]
  exploit web <url> [vuln_type]   - Web application exploitation
  exploit network <target> [svc]  - Network service exploitation
  exploit binary <target>         - Binary exploitation techniques
  exploit social [type]           - Social engineering campaigns
  exploit wireless [interface]    - Wireless network attacks
  exploit payload [type]          - Generate custom payloads
  exploit sessions                - Manage active sessions

[bold yellow]Interactive Mode:[/]
  Run 'exploit' without arguments to enter interactive mode

[bold yellow]Examples:[/]
  exploit web https://example.com sqli
  exploit network 192.168.1.100 ssh
  exploit binary 192.168.1.100:9999
  exploit social phishing_email
  exploit payload reverse_shell

[bold red]⚠️  CRITICAL WARNING:[/]
- Only use against systems you own or have explicit written authorization
- Unauthorized exploitation is illegal and unethical
- Always follow responsible disclosure practices
- Ensure proper legal agreements are in place before testing
- Maintain detailed logs for compliance and reporting
"""
        
        self.console.print(Panel(help_text, title="Help", border_style="blue"))


if __name__ == "__main__":
    import sys
    exploit_cli = ExploitCLI()
    exploit_cli.run(sys.argv[1:] if len(sys.argv) > 1 else [])