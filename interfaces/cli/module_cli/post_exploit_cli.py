#!/usr/bin/env python3
"""
Post-Exploitation CLI Module for Pentest-USB Toolkit
====================================================

Command-line interface for post-exploitation operations including
credential access, lateral movement, persistence, and data exfiltration.
"""

import sys
import threading
from typing import Dict, List, Optional, Any, Tuple
from pathlib import Path

from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.progress import Progress, SpinnerColumn, TextColumn, BarColumn
from rich.prompt import Prompt, Confirm, IntPrompt
from rich import box

# Add project root to path
project_root = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(project_root))

from interfaces.cli.utils import CLIUtils
from modules.post_exploit.credential_access import CredentialAccessor
from modules.post_exploit.lateral_movement import LateralMovement
from modules.post_exploit.persistence import PersistenceManager
from modules.post_exploit.data_exfil import DataExfiltrator
from modules.post_exploit.cleanup import EvidenceCleanup


class PostExploitCLI:
    """Command-line interface for post-exploitation module."""
    
    def __init__(self):
        """Initialize post-exploitation CLI."""
        self.console = Console()
        self.utils = CLIUtils()
        
        # Initialize post-exploitation modules
        self.credential_accessor = CredentialAccessor()
        self.lateral_movement = LateralMovement()
        self.persistence_manager = PersistenceManager()
        self.data_exfiltrator = DataExfiltrator()
        self.evidence_cleanup = EvidenceCleanup()
        
        # CLI state
        self.current_target = None
        self.session_info = {}
        self.collected_data = {}
        
    def run(self, args: List[str] = None):
        """Main entry point for post-exploitation CLI."""
        try:
            self._show_banner()
            self._show_warning()
            
            if args and len(args) > 0:
                # Direct command mode
                self._handle_direct_command(args)
            else:
                # Interactive mode
                self._interactive_mode()
                
        except KeyboardInterrupt:
            self.console.print("\n[yellow]Post-exploitation module interrupted.[/]")
        except Exception as e:
            self.console.print(f"[red]Error in post-exploitation module: {e}[/]")
            
    def _show_banner(self):
        """Show post-exploitation module banner."""
        banner = """
[bold magenta]🎯 POST-EXPLOITATION MODULE[/]
[dim]Credential Access • Lateral Movement • Persistence • Data Exfiltration[/]
"""
        self.console.print(Panel(banner, border_style="magenta"))
        
    def _show_warning(self):
        """Show legal warning."""
        warning = """
[bold red]⚠️  LEGAL WARNING ⚠️[/]

[yellow]This module contains advanced techniques for post-exploitation activities.
Only use these tools on systems you own or have explicit written permission to test.
Unauthorized access and data exfiltration may violate local, state, and federal laws.[/]

[bold]By continuing, you acknowledge that you have proper authorization.[/]
"""
        
        self.console.print(Panel(warning, border_style="yellow", title="Legal Notice"))
        
        if not Confirm.ask("[bold red]Do you have explicit authorization to perform post-exploitation?[/]"):
            self.console.print("[red]Post-exploitation module terminated. Authorization required.[/]")
            sys.exit(1)
            
    def _handle_direct_command(self, args: List[str]):
        """Handle direct command execution."""
        if not args:
            return
            
        command = args[0].lower()
        
        if command in ['creds', 'credentials']:
            target = args[1] if len(args) > 1 else Prompt.ask("[cyan]Enter target host")
            self._credential_access_menu(target)
        elif command in ['lateral', 'move']:
            source = args[1] if len(args) > 1 else Prompt.ask("[cyan]Enter source host")
            target = args[2] if len(args) > 2 else Prompt.ask("[cyan]Enter target host")
            self._lateral_movement_menu(source, target)
        elif command in ['persist', 'persistence']:
            target = args[1] if len(args) > 1 else Prompt.ask("[cyan]Enter target host")
            self._persistence_menu(target)
        elif command in ['exfil', 'exfiltrate']:
            target = args[1] if len(args) > 1 else Prompt.ask("[cyan]Enter target host")
            self._data_exfiltration_menu(target)
        elif command in ['cleanup', 'clean']:
            target = args[1] if len(args) > 1 else Prompt.ask("[cyan]Enter target host")
            self._cleanup_menu(target)
        else:
            self.console.print(f"[red]Unknown post-exploitation command: {command}[/]")
            self._show_help()
            
    def _interactive_mode(self):
        """Run interactive post-exploitation mode."""
        while True:
            self._show_menu()
            
            choice = Prompt.ask(
                "\n[bold cyan]Select post-exploitation option[/]",
                choices=["1", "2", "3", "4", "5", "6", "7", "0"],
                default="0"
            )
            
            if choice == "0":
                break
            elif choice == "1":
                target = Prompt.ask("[cyan]Enter target host")
                self._credential_access_menu(target)
            elif choice == "2":
                source = Prompt.ask("[cyan]Enter source host")
                target = Prompt.ask("[cyan]Enter target host")
                self._lateral_movement_menu(source, target)
            elif choice == "3":
                target = Prompt.ask("[cyan]Enter target host")
                self._persistence_menu(target)
            elif choice == "4":
                target = Prompt.ask("[cyan]Enter target host")
                self._data_exfiltration_menu(target)
            elif choice == "5":
                target = Prompt.ask("[cyan]Enter target host")
                self._cleanup_menu(target)
            elif choice == "6":
                self._show_collected_data()
            elif choice == "7":
                self._export_data()
                
    def _show_menu(self):
        """Display post-exploitation menu options."""
        table = Table(title="[bold magenta]Post-Exploitation Options[/]", box=box.ROUNDED)
        table.add_column("Option", style="bold yellow", justify="center")
        table.add_column("Module", style="bold green")
        table.add_column("Description", style="white")
        
        table.add_row("1", "Credential Access", "Harvest credentials and secrets")
        table.add_row("2", "Lateral Movement", "Move laterally through network")
        table.add_row("3", "Persistence", "Establish persistent access")
        table.add_row("4", "Data Exfiltration", "Exfiltrate sensitive data")
        table.add_row("5", "Evidence Cleanup", "Clean up attack traces")
        table.add_row("", "", "")
        table.add_row("6", "View Collected Data", "Display harvested information")
        table.add_row("7", "Export Data", "Export collected data to file")
        table.add_row("0", "Back", "Return to main menu")
        
        self.console.print(table)
        
    def _credential_access_menu(self, target: str = None):
        """Credential access submenu."""
        self.console.print("\n[bold green]Credential Access Operations[/]")
        
        if not target:
            target = Prompt.ask("[cyan]Enter target host/IP")
            
        # Credential harvesting techniques
        techniques = {
            "1": ("mimikatz", "Mimikatz - Windows credential dumping"),
            "2": ("lazagne", "LaZagne - Multi-platform password recovery"),
            "3": ("secretsdump", "Secretsdump - Remote credential extraction"),
            "4": ("hashcat_crack", "Hashcat - Hash cracking"),
            "5": ("kerberoast", "Kerberoasting - Service account attacks"),
            "6": ("asreproast", "AS-REP Roasting - Account attacks"),
            "7": ("dcsync", "DCSync - Domain controller synchronization"),
            "8": ("lsass_dump", "LSASS memory dump analysis")
        }
        
        self.console.print("\n[bold yellow]Credential Access Techniques:[/]")
        for key, (tech_id, desc) in techniques.items():
            self.console.print(f"[yellow]{key}[/] - {desc}")
            
        tech_choice = Prompt.ask(
            "[cyan]Select technique[/]",
            choices=list(techniques.keys()),
            default="1"
        )
        
        technique = techniques[tech_choice][0]
        
        # Configuration
        config = {
            'target': target,
            'technique': technique
        }
        
        # Technique-specific options
        if technique in ["hashcat_crack", "john_crack"]:
            config['wordlist'] = self.utils.prompt_for_wordlist("passwords")
            config['rules'] = Prompt.ask("[cyan]Hashcat rules file (optional)", default="")
            
        elif technique == "kerberoast":
            config['domain'] = Prompt.ask("[cyan]Target domain")
            config['username'] = Prompt.ask("[cyan]Domain username")
            config['password'] = Prompt.ask("[cyan]Domain password", password=True)
            
        elif technique == "dcsync":
            config['domain_controller'] = Prompt.ask("[cyan]Domain controller IP")
            config['target_user'] = Prompt.ask("[cyan]Target user (or 'all')", default="all")
            
        self._execute_credential_access(config)
        
    def _execute_credential_access(self, config: Dict[str, Any]):
        """Execute credential access operations."""
        target = config['target']
        technique = config['technique']
        
        self.console.print(f"\n[green]Executing {technique} on: {target}[/]")
        
        if not self.utils.confirm_dangerous_action(f"harvest credentials using {technique}"):
            return
            
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            console=self.console
        ) as progress:
            
            task = progress.add_task("Harvesting credentials...", total=100)
            
            try:
                if technique == "mimikatz":
                    result = self.credential_accessor.run_mimikatz(
                        target,
                        progress_callback=lambda p: progress.update(task, completed=p)
                    )
                elif technique == "lazagne":
                    result = self.credential_accessor.run_lazagne(
                        target,
                        progress_callback=lambda p: progress.update(task, completed=p)
                    )
                elif technique == "kerberoast":
                    result = self.credential_accessor.kerberoast_attack(
                        config,
                        progress_callback=lambda p: progress.update(task, completed=p)
                    )
                else:
                    result = self.credential_accessor.generic_harvest(
                        target,
                        technique,
                        config,
                        progress_callback=lambda p: progress.update(task, completed=p)
                    )
                    
                progress.update(task, completed=100, description="Credential harvest completed")
                
            except Exception as e:
                self.console.print(f"[red]Credential access failed: {e}[/]")
                return
                
        # Store and display results
        if 'credentials' not in self.collected_data:
            self.collected_data['credentials'] = []
            
        credentials = result.get('credentials', [])
        self.collected_data['credentials'].extend(credentials)
        
        self._display_credentials(credentials)
        
        if credentials and Confirm.ask("[cyan]Save credentials to file?[/]"):
            filename = f"credentials_{target}_{technique}.json"
            self.utils.save_results_to_file({'credentials': credentials}, filename)
            
    def _lateral_movement_menu(self, source: str = None, target: str = None):
        """Lateral movement submenu."""
        self.console.print("\n[bold green]Lateral Movement Operations[/]")
        
        if not source:
            source = Prompt.ask("[cyan]Enter source host/IP")
        if not target:
            target = Prompt.ask("[cyan]Enter target host/IP")
            
        # Movement techniques
        techniques = {
            "1": ("psexec", "PsExec - Remote command execution"),
            "2": ("wmiexec", "WMIExec - WMI-based execution"), 
            "3": ("smbexec", "SMBExec - SMB-based execution"),
            "4": ("rdp_session", "RDP Session hijacking"),
            "5": ("pass_the_hash", "Pass-the-Hash attack"),
            "6": ("pass_the_ticket", "Pass-the-Ticket attack"),
            "7": ("golden_ticket", "Golden Ticket attack"),
            "8": ("silver_ticket", "Silver Ticket attack")
        }
        
        self.console.print("\n[bold yellow]Lateral Movement Techniques:[/]")
        for key, (tech_id, desc) in techniques.items():
            self.console.print(f"[yellow]{key}[/] - {desc}")
            
        tech_choice = Prompt.ask(
            "[cyan]Select technique[/]",
            choices=list(techniques.keys()),
            default="1"
        )
        
        technique = techniques[tech_choice][0]
        
        # Configuration
        config = {
            'source': source,
            'target': target,
            'technique': technique
        }
        
        # Authentication method
        auth_method = Prompt.ask(
            "[cyan]Authentication method[/]",
            choices=["password", "hash", "ticket", "key"],
            default="password"
        )
        
        if auth_method == "password":
            config['username'] = Prompt.ask("[cyan]Username")
            config['password'] = Prompt.ask("[cyan]Password", password=True)
        elif auth_method == "hash":
            config['username'] = Prompt.ask("[cyan]Username") 
            config['ntlm_hash'] = Prompt.ask("[cyan]NTLM Hash")
        elif auth_method == "ticket":
            config['ticket_file'] = Prompt.ask("[cyan]Kerberos ticket file path")
            
        # Command to execute
        config['command'] = Prompt.ask("[cyan]Command to execute", default="whoami")
        
        self._execute_lateral_movement(config)
        
    def _execute_lateral_movement(self, config: Dict[str, Any]):
        """Execute lateral movement."""
        source = config['source']
        target = config['target']
        technique = config['technique']
        
        self.console.print(f"\n[green]Moving from {source} to {target} using {technique}[/]")
        
        if not self.utils.confirm_dangerous_action(f"perform lateral movement using {technique}"):
            return
            
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            console=self.console
        ) as progress:
            
            task = progress.add_task("Executing lateral movement...", total=100)
            
            try:
                result = self.lateral_movement.execute_movement(
                    technique,
                    config,
                    progress_callback=lambda p: progress.update(task, completed=p)
                )
                
                progress.update(task, completed=100, description="Lateral movement completed")
                
            except Exception as e:
                self.console.print(f"[red]Lateral movement failed: {e}[/]")
                return
                
        # Display results
        if result.get('success'):
            self.console.print(f"[green]✅ Successfully moved to {target}[/]")
            if result.get('output'):
                self.console.print(f"[white]Command output:[/] {result['output']}")
                
            # Store session info
            self.session_info[target] = {
                'access_method': technique,
                'timestamp': result.get('timestamp'),
                'credentials': config.get('username', 'N/A')
            }
        else:
            self.console.print(f"[red]❌ Failed to move to {target}[/]")
            if result.get('error'):
                self.console.print(f"[red]Error: {result['error']}[/]")
                
    def _persistence_menu(self, target: str = None):
        """Persistence establishment submenu."""
        self.console.print("\n[bold green]Persistence Operations[/]")
        
        if not target:
            target = Prompt.ask("[cyan]Enter target host/IP")
            
        # Persistence techniques
        techniques = {
            "1": ("scheduled_task", "Scheduled Task (Windows)"),
            "2": ("service_install", "Windows Service Installation"),
            "3": ("registry_key", "Registry Run Key"),
            "4": ("startup_folder", "Startup Folder"),
            "5": ("wmi_event", "WMI Event Subscription"),
            "6": ("dll_hijack", "DLL Hijacking"),
            "7": ("ssh_key", "SSH Key Installation (Linux)"),
            "8": ("cron_job", "Cron Job (Linux)"),
            "9": ("backdoor_user", "Backdoor User Account"),
            "10": ("golden_ticket", "Golden Ticket Persistence")
        }
        
        self.console.print("\n[bold yellow]Persistence Techniques:[/]")
        for key, (tech_id, desc) in techniques.items():
            self.console.print(f"[yellow]{key}[/] - {desc}")
            
        tech_choice = Prompt.ask(
            "[cyan]Select persistence technique[/]",
            choices=list(techniques.keys()),
            default="1"
        )
        
        technique = techniques[tech_choice][0]
        
        # Configuration
        config = {
            'target': target,
            'technique': technique
        }
        
        # Technique-specific configuration
        if technique == "scheduled_task":
            config['task_name'] = Prompt.ask("[cyan]Task name", default="SystemUpdate")
            config['trigger'] = Prompt.ask("[cyan]Trigger", choices=["startup", "logon", "daily"], default="logon")
            config['command'] = Prompt.ask("[cyan]Command to execute")
            
        elif technique == "service_install":
            config['service_name'] = Prompt.ask("[cyan]Service name", default="WindowsUpdate") 
            config['display_name'] = Prompt.ask("[cyan]Display name", default="Windows Update Service")
            config['executable_path'] = Prompt.ask("[cyan]Executable path")
            
        elif technique == "ssh_key":
            config['public_key'] = Prompt.ask("[cyan]SSH public key")
            config['username'] = Prompt.ask("[cyan]Target username", default="root")
            
        elif technique == "cron_job":
            config['cron_expression'] = Prompt.ask("[cyan]Cron expression", default="@reboot")
            config['command'] = Prompt.ask("[cyan]Command to execute")
            
        # Stealth options
        config['stealth'] = Confirm.ask("[cyan]Enable stealth mode?[/]", default=True)
        if config['stealth']:
            config['hide_files'] = Confirm.ask("[cyan]Hide files/registry entries?[/]", default=True)
            
        self._execute_persistence(config)
        
    def _execute_persistence(self, config: Dict[str, Any]):
        """Execute persistence establishment."""
        target = config['target']
        technique = config['technique']
        
        self.console.print(f"\n[green]Establishing {technique} persistence on: {target}[/]")
        
        if not self.utils.confirm_dangerous_action(f"establish {technique} persistence"):
            return
            
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            console=self.console
        ) as progress:
            
            task = progress.add_task("Establishing persistence...", total=100)
            
            try:
                result = self.persistence_manager.establish_persistence(
                    technique,
                    config,
                    progress_callback=lambda p: progress.update(task, completed=p)
                )
                
                progress.update(task, completed=100, description="Persistence established")
                
            except Exception as e:
                self.console.print(f"[red]Persistence establishment failed: {e}[/]")
                return
                
        # Display results
        if result.get('success'):
            self.console.print(f"[green]✅ Persistence established successfully[/]")
            
            # Display persistence details
            if result.get('details'):
                details_table = Table(title="Persistence Details")
                details_table.add_column("Property", style="cyan")
                details_table.add_column("Value", style="white")
                
                for key, value in result['details'].items():
                    details_table.add_row(key, str(value))
                    
                self.console.print(details_table)
                
            # Store persistence info
            if 'persistence' not in self.collected_data:
                self.collected_data['persistence'] = []
                
            self.collected_data['persistence'].append({
                'target': target,
                'technique': technique,
                'config': config,
                'result': result
            })
        else:
            self.console.print(f"[red]❌ Failed to establish persistence[/]")
            if result.get('error'):
                self.console.print(f"[red]Error: {result['error']}[/]")
                
    def _data_exfiltration_menu(self, target: str = None):
        """Data exfiltration submenu."""
        self.console.print("\n[bold green]Data Exfiltration Operations[/]")
        
        if not target:
            target = Prompt.ask("[cyan]Enter target host/IP")
            
        # Exfiltration methods
        methods = {
            "1": ("http_post", "HTTP POST exfiltration"),
            "2": ("https_upload", "HTTPS file upload"), 
            "3": ("dns_tunneling", "DNS tunneling"),
            "4": ("icmp_tunneling", "ICMP tunneling"),
            "5": ("ftp_upload", "FTP upload"),
            "6": ("email_exfil", "Email exfiltration"),
            "7": ("cloud_upload", "Cloud storage upload"),
            "8": ("usb_copy", "USB device copy"),
            "9": ("network_share", "Network share copy"),
            "10": ("steganography", "Steganography (image hiding)")
        }
        
        self.console.print("\n[bold yellow]Exfiltration Methods:[/]")
        for key, (method_id, desc) in methods.items():
            self.console.print(f"[yellow]{key}[/] - {desc}")
            
        method_choice = Prompt.ask(
            "[cyan]Select exfiltration method[/]",
            choices=list(methods.keys()),
            default="1"
        )
        
        method = methods[method_choice][0]
        
        # Data selection
        data_types = []
        if Confirm.ask("[cyan]Exfiltrate user files?[/]", default=True):
            data_types.append("user_files")
        if Confirm.ask("[cyan]Exfiltrate system configuration?[/]", default=False):
            data_types.append("system_config")
        if Confirm.ask("[cyan]Exfiltrate database files?[/]", default=False):
            data_types.append("databases")
        if Confirm.ask("[cyan]Exfiltrate browser data?[/]", default=True):
            data_types.append("browser_data")
        if Confirm.ask("[cyan]Exfiltrate log files?[/]", default=False):
            data_types.append("log_files")
            
        # Configuration
        config = {
            'target': target,
            'method': method,
            'data_types': data_types
        }
        
        # Method-specific configuration
        if method in ["http_post", "https_upload"]:
            config['server_url'] = Prompt.ask("[cyan]Exfiltration server URL")
            
        elif method == "dns_tunneling":
            config['dns_server'] = Prompt.ask("[cyan]DNS server IP")
            config['domain'] = Prompt.ask("[cyan]Domain for tunneling")
            
        elif method == "ftp_upload":
            config['ftp_server'] = Prompt.ask("[cyan]FTP server")
            config['ftp_username'] = Prompt.ask("[cyan]FTP username")
            config['ftp_password'] = Prompt.ask("[cyan]FTP password", password=True)
            
        elif method == "cloud_upload":
            config['cloud_provider'] = Prompt.ask("[cyan]Cloud provider", choices=["aws", "google", "dropbox"], default="dropbox")
            config['api_key'] = Prompt.ask("[cyan]API key", password=True)
            
        # Compression and encryption
        config['compress'] = Confirm.ask("[cyan]Compress data before exfiltration?[/]", default=True)
        config['encrypt'] = Confirm.ask("[cyan]Encrypt data before exfiltration?[/]", default=True)
        
        if config['encrypt']:
            config['encryption_key'] = Prompt.ask("[cyan]Encryption password", password=True)
            
        self._execute_data_exfiltration(config)
        
    def _execute_data_exfiltration(self, config: Dict[str, Any]):
        """Execute data exfiltration."""
        target = config['target']
        method = config['method']
        
        self.console.print(f"\n[green]Exfiltrating data from {target} using {method}[/]")
        
        if not self.utils.confirm_dangerous_action(f"exfiltrate data using {method}"):
            return
            
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            console=self.console
        ) as progress:
            
            # Data collection phase
            task1 = progress.add_task("Collecting data...", total=100)
            
            try:
                collected_files = self.data_exfiltrator.collect_data(
                    target,
                    config['data_types'],
                    progress_callback=lambda p: progress.update(task1, completed=p)
                )
                progress.update(task1, completed=100, description=f"Collected {len(collected_files)} files")
                
            except Exception as e:
                self.console.print(f"[red]Data collection failed: {e}[/]")
                return
                
            # Data processing phase
            task2 = progress.add_task("Processing data...", total=100)
            
            try:
                processed_data = self.data_exfiltrator.process_data(
                    collected_files,
                    compress=config.get('compress', True),
                    encrypt=config.get('encrypt', True),
                    encryption_key=config.get('encryption_key'),
                    progress_callback=lambda p: progress.update(task2, completed=p)
                )
                progress.update(task2, completed=100, description="Data processed")
                
            except Exception as e:
                self.console.print(f"[red]Data processing failed: {e}[/]")
                return
                
            # Data exfiltration phase
            task3 = progress.add_task("Exfiltrating data...", total=100)
            
            try:
                result = self.data_exfiltrator.exfiltrate_data(
                    processed_data,
                    method,
                    config,
                    progress_callback=lambda p: progress.update(task3, completed=p)
                )
                progress.update(task3, completed=100, description="Exfiltration completed")
                
            except Exception as e:
                self.console.print(f"[red]Data exfiltration failed: {e}[/]")
                return
                
        # Display results
        if result.get('success'):
            self.console.print(f"[green]✅ Data exfiltration successful[/]")
            
            exfil_stats = Table(title="Exfiltration Statistics")
            exfil_stats.add_column("Metric", style="cyan")
            exfil_stats.add_column("Value", style="white")
            
            exfil_stats.add_row("Files collected", str(len(collected_files)))
            exfil_stats.add_row("Data size", self.utils.format_bytes(result.get('total_size', 0)))
            exfil_stats.add_row("Transfer time", self.utils.format_duration(result.get('transfer_time', 0)))
            exfil_stats.add_row("Method", method)
            exfil_stats.add_row("Compressed", "Yes" if config.get('compress') else "No")
            exfil_stats.add_row("Encrypted", "Yes" if config.get('encrypt') else "No")
            
            self.console.print(exfil_stats)
            
            # Store exfiltration info
            if 'exfiltration' not in self.collected_data:
                self.collected_data['exfiltration'] = []
                
            self.collected_data['exfiltration'].append({
                'target': target,
                'method': method,
                'files': len(collected_files),
                'size': result.get('total_size', 0),
                'timestamp': result.get('timestamp')
            })
        else:
            self.console.print(f"[red]❌ Data exfiltration failed[/]")
            if result.get('error'):
                self.console.print(f"[red]Error: {result['error']}[/]")
                
    def _cleanup_menu(self, target: str = None):
        """Evidence cleanup submenu."""
        self.console.print("\n[bold green]Evidence Cleanup Operations[/]")
        
        if not target:
            target = Prompt.ask("[cyan]Enter target host/IP")
            
        # Cleanup categories
        cleanup_options = []
        
        if Confirm.ask("[cyan]Clear system logs?[/]", default=True):
            cleanup_options.append("system_logs")
        if Confirm.ask("[cyan]Clear application logs?[/]", default=True):
            cleanup_options.append("application_logs")
        if Confirm.ask("[cyan]Clear event logs (Windows)?[/]", default=True):
            cleanup_options.append("event_logs")
        if Confirm.ask("[cyan]Clear browser history?[/]", default=False):
            cleanup_options.append("browser_history")
        if Confirm.ask("[cyan]Clear temporary files?[/]", default=True):
            cleanup_options.append("temp_files")
        if Confirm.ask("[cyan]Clear registry traces (Windows)?[/]", default=True):
            cleanup_options.append("registry_traces")
        if Confirm.ask("[cyan]Clear network traces?[/]", default=True):
            cleanup_options.append("network_traces")
        if Confirm.ask("[cyan]Remove uploaded files?[/]", default=True):
            cleanup_options.append("uploaded_files")
            
        config = {
            'target': target,
            'cleanup_options': cleanup_options,
            'secure_delete': Confirm.ask("[cyan]Use secure deletion?[/]", default=True),
            'overwrite_passes': IntPrompt.ask("[cyan]Overwrite passes", default=3) if Confirm.ask("[cyan]Use secure deletion?[/]", default=True) else 1
        }
        
        self._execute_cleanup(config)
        
    def _execute_cleanup(self, config: Dict[str, Any]):
        """Execute evidence cleanup."""
        target = config['target']
        
        self.console.print(f"\n[green]Cleaning up evidence on: {target}[/]")
        
        if not self.utils.confirm_dangerous_action("perform evidence cleanup"):
            return
            
        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            BarColumn(),
            console=self.console
        ) as progress:
            
            cleanup_results = []
            
            for cleanup_type in config['cleanup_options']:
                task = progress.add_task(f"Cleaning {cleanup_type}...", total=100)
                
                try:
                    result = self.evidence_cleanup.cleanup_category(
                        target,
                        cleanup_type,
                        secure_delete=config.get('secure_delete', True),
                        overwrite_passes=config.get('overwrite_passes', 3),
                        progress_callback=lambda p: progress.update(task, completed=p)
                    )
                    
                    cleanup_results.append({
                        'category': cleanup_type,
                        'success': result.get('success', False),
                        'items_cleaned': result.get('items_cleaned', 0)
                    })
                    
                    progress.update(task, completed=100, description=f"{cleanup_type}: {result.get('items_cleaned', 0)} items")
                    
                except Exception as e:
                    self.console.print(f"[red]{cleanup_type} cleanup failed: {e}[/]")
                    cleanup_results.append({
                        'category': cleanup_type,
                        'success': False,
                        'error': str(e)
                    })
                    progress.update(task, completed=100)
                    
        # Display cleanup results
        cleanup_table = Table(title="Cleanup Results")
        cleanup_table.add_column("Category", style="cyan")
        cleanup_table.add_column("Status", style="bold")
        cleanup_table.add_column("Items Cleaned", style="yellow")
        
        total_cleaned = 0
        for result in cleanup_results:
            status = "[green]Success[/]" if result['success'] else "[red]Failed[/]"
            items = str(result.get('items_cleaned', 0))
            total_cleaned += result.get('items_cleaned', 0)
            
            cleanup_table.add_row(result['category'], status, items)
            
        self.console.print(cleanup_table)
        self.console.print(f"\n[green]Total items cleaned: {total_cleaned}[/]")
        
        # Store cleanup info
        if 'cleanup' not in self.collected_data:
            self.collected_data['cleanup'] = []
            
        self.collected_data['cleanup'].append({
            'target': target,
            'timestamp': self.utils._get_timestamp(),
            'results': cleanup_results,
            'total_cleaned': total_cleaned
        })
        
    def _display_credentials(self, credentials: List[Dict[str, Any]]):
        """Display harvested credentials."""
        if not credentials:
            self.console.print("[yellow]No credentials found.[/]")
            return
            
        self.console.print(f"\n[green]Found {len(credentials)} credentials:[/]")
        self.utils.display_scan_results({'credentials': credentials})
        
    def _show_collected_data(self):
        """Display all collected post-exploitation data."""
        if not self.collected_data:
            self.console.print("[yellow]No data collected yet.[/]")
            return
            
        self.console.print("\n[bold magenta]Post-Exploitation Data Summary[/]")
        
        for data_type, items in self.collected_data.items():
            self.console.print(f"\n[bold cyan]{data_type.replace('_', ' ').title()}:[/]")
            
            if isinstance(items, list):
                self.console.print(f"  Items: {len(items)}")
                
                if data_type == "credentials":
                    unique_users = set(item.get('username', 'N/A') for item in items)
                    self.console.print(f"  Unique users: {len(unique_users)}")
                    
                elif data_type == "exfiltration":
                    total_size = sum(item.get('size', 0) for item in items)
                    self.console.print(f"  Total data exfiltrated: {self.utils.format_bytes(total_size)}")
                    
        # Show session information
        if self.session_info:
            self.console.print(f"\n[bold cyan]Active Sessions:[/]")
            sessions_table = Table()
            sessions_table.add_column("Target", style="cyan")
            sessions_table.add_column("Method", style="green") 
            sessions_table.add_column("User", style="yellow")
            sessions_table.add_column("Timestamp", style="dim")
            
            for target, info in self.session_info.items():
                sessions_table.add_row(
                    target,
                    info.get('access_method', 'N/A'),
                    info.get('credentials', 'N/A'),
                    str(info.get('timestamp', 'N/A'))
                )
                
            self.console.print(sessions_table)
            
    def _export_data(self):
        """Export all collected data to file."""
        if not self.collected_data and not self.session_info:
            self.console.print("[yellow]No data to export.[/]")
            return
            
        export_data = {
            'collected_data': self.collected_data,
            'session_info': self.session_info,
            'export_timestamp': self.utils._get_timestamp()
        }
        
        filename = Prompt.ask(
            "[cyan]Enter filename for export[/]",
            default="post_exploitation_data.json"
        )
        
        # Sanitize sensitive data
        sanitized_data = self._sanitize_export_data(export_data)
        
        output_file = self.utils.save_results_to_file(sanitized_data, filename)
        self.console.print(f"[green]Data exported to: {output_file}[/]")
        self.console.print("[yellow]Note: Sensitive credentials have been redacted for security[/]")
        
    def _sanitize_export_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Sanitize sensitive data for export."""
        import copy
        sanitized = copy.deepcopy(data)
        
        # Redact credentials
        if 'collected_data' in sanitized and 'credentials' in sanitized['collected_data']:
            for cred in sanitized['collected_data']['credentials']:
                if 'password' in cred:
                    cred['password'] = "[REDACTED]"
                if 'hash' in cred:
                    cred['hash'] = "[REDACTED]"
                    
        return sanitized
        
    def _show_help(self):
        """Display help information."""
        help_text = """
[bold magenta]Post-Exploitation Module Help[/]

[bold yellow]Available Commands:[/]
  postexploit creds <target>       - Harvest credentials and secrets
  postexploit lateral <src> <dst>  - Lateral movement between hosts
  postexploit persist <target>     - Establish persistence mechanisms
  postexploit exfil <target>       - Exfiltrate sensitive data
  postexploit cleanup <target>     - Clean up attack evidence

[bold yellow]Interactive Mode:[/]
  Run 'postexploit' without arguments to enter interactive mode

[bold yellow]Examples:[/]
  postexploit creds 192.168.1.100
  postexploit lateral 192.168.1.100 192.168.1.101
  postexploit persist 192.168.1.100
  postexploit exfil 192.168.1.100

[bold red]⚠️  Legal Warning:[/]
Only use on authorized targets. Unauthorized access is illegal.
"""
        
        self.console.print(Panel(help_text, title="Help", border_style="blue"))


if __name__ == "__main__":
    import sys
    postexploit_cli = PostExploitCLI()
    postexploit_cli.run(sys.argv[1:] if len(sys.argv) > 1 else [])