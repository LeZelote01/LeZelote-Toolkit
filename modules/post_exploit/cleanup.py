#!/usr/bin/env python3
"""
Cleanup Module - Pentest USB Toolkit

This module implements comprehensive cleanup capabilities including
evidence removal, log cleaning, registry cleanup, and network traces removal.

Author: Pentest USB Team
Version: 1.0.0
"""

import os
import sys
import json
import logging
import subprocess
import time
import re
import shutil
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum
from datetime import datetime, timedelta

# Internal imports
sys.path.append(str(Path(__file__).parent.parent.parent))
from core.utils.logging_handler import setup_logger
from core.utils.error_handler import handle_error
from core.security.consent_manager import ConsentManager


class CleanupType(Enum):
    """Types of cleanup operations."""
    LOG_CLEANING = "log_cleaning"
    FILE_DELETION = "file_deletion"
    REGISTRY_CLEANUP = "registry_cleanup"
    PROCESS_CLEANUP = "process_cleanup"
    NETWORK_CLEANUP = "network_cleanup"
    MEMORY_CLEANUP = "memory_cleanup"
    ARTIFACT_REMOVAL = "artifact_removal"


@dataclass
class CleanupOperation:
    """Data structure for cleanup operations."""
    operation_type: CleanupType
    description: str
    command: str
    risk_level: int  # 1-5, where 5 is highest risk
    success: bool = False
    error: Optional[str] = None


class CleanupModule:
    """Main class for cleanup operations."""
    
    def __init__(self, target: str, config: Dict[str, Any] = None):
        self.target = target
        self.config = config or {}
        self.logger = setup_logger(__name__)
        self.consent_manager = ConsentManager()
        
        self.logger.info(f"Initialized CleanupModule for target: {target}")

    @handle_error
    def perform_cleanup(self, profile: str = "default") -> Dict[str, Any]:
        """
        Main method to perform cleanup operations.
        
        Args:
            profile: Cleanup profile (minimal, default, aggressive)
            
        Returns:
            Dictionary containing cleanup results
        """
        self.logger.info("Starting cleanup operations")
        
        # Verify consent and authorization
        if not self.consent_manager.verify_authorization(self.target, "cleanup"):
            raise PermissionError("No authorization for cleanup operations on target")
        
        results = {
            'target': self.target,
            'profile': profile,
            'successful_operations': 0,
            'failed_operations': 0,
            'operations_details': [],
            'execution_time': 0
        }
        
        start_time = time.time()
        
        try:
            # Get operations based on profile
            operations = self._get_profile_operations(profile)
            
            # Execute operations
            for operation in operations:
                try:
                    self.logger.info(f"Executing: {operation.description}")
                    success = self._execute_operation(operation)
                    
                    if success:
                        results['successful_operations'] += 1
                        operation.success = True
                    else:
                        results['failed_operations'] += 1
                    
                    results['operations_details'].append(operation.__dict__)
                    
                except Exception as e:
                    self.logger.error(f"Error executing {operation.description}: {e}")
                    operation.error = str(e)
                    results['failed_operations'] += 1
                    results['operations_details'].append(operation.__dict__)
        
        except Exception as e:
            self.logger.error(f"Error during cleanup operations: {e}")
            results['error'] = str(e)
        
        finally:
            results['execution_time'] = time.time() - start_time
            
        self.logger.info(f"Cleanup operations completed in {results['execution_time']:.2f} seconds")
        return results

    def _get_profile_operations(self, profile: str) -> List[CleanupOperation]:
        """Get cleanup operations based on profile."""
        operations = []
        
        if profile in ['default', 'aggressive']:
            # DNS cache flush
            operations.extend(self._get_network_cleanup_operations())
            
            # Clear temporary files
            operations.extend(self._get_file_cleanup_operations())
            
            # Process cleanup
            operations.extend(self._get_process_cleanup_operations())
        
        if profile == 'aggressive':
            # Clear system logs (high risk)
            operations.extend(self._get_log_cleanup_operations())
            
            # Registry cleanup (Windows)
            operations.extend(self._get_registry_cleanup_operations())
            
            # Memory cleanup
            operations.extend(self._get_memory_cleanup_operations())
            
            # Artifact removal
            operations.extend(self._get_artifact_removal_operations())
        
        return operations

    def _get_network_cleanup_operations(self) -> List[CleanupOperation]:
        """Get network cleanup operations."""
        operations = []
        
        if sys.platform.startswith('win'):
            # Windows network cleanup
            operations.extend([
                CleanupOperation(
                    operation_type=CleanupType.NETWORK_CLEANUP,
                    description="Flush DNS cache",
                    command="ipconfig /flushdns",
                    risk_level=1
                ),
                CleanupOperation(
                    operation_type=CleanupType.NETWORK_CLEANUP,
                    description="Clear ARP cache",
                    command="arp -d *",
                    risk_level=2
                ),
                CleanupOperation(
                    operation_type=CleanupType.NETWORK_CLEANUP,
                    description="Clear NetBIOS cache",
                    command="nbtstat -R",
                    risk_level=1
                ),
                CleanupOperation(
                    operation_type=CleanupType.NETWORK_CLEANUP,
                    description="Reset network statistics",
                    command="netstat -r > nul && netsh interface ip delete arpcache",
                    risk_level=2
                )
            ])
        else:
            # Linux/Unix network cleanup
            operations.extend([
                CleanupOperation(
                    operation_type=CleanupType.NETWORK_CLEANUP,
                    description="Flush DNS cache",
                    command="systemctl flush-dns || service nscd restart || /etc/init.d/nscd restart",
                    risk_level=1
                ),
                CleanupOperation(
                    operation_type=CleanupType.NETWORK_CLEANUP,
                    description="Clear ARP cache",
                    command="ip neigh flush all",
                    risk_level=2
                ),
                CleanupOperation(
                    operation_type=CleanupType.NETWORK_CLEANUP,
                    description="Clear connection tracking",
                    command="conntrack -F 2>/dev/null || echo 'conntrack not available'",
                    risk_level=3
                )
            ])
        
        return operations

    def _get_file_cleanup_operations(self) -> List[CleanupOperation]:
        """Get file cleanup operations."""
        operations = []
        
        if sys.platform.startswith('win'):
            # Windows file cleanup
            operations.extend([
                CleanupOperation(
                    operation_type=CleanupType.FILE_DELETION,
                    description="Clear Windows temp files",
                    command='del /f /s /q "%TEMP%\\*" 2>nul',
                    risk_level=2
                ),
                CleanupOperation(
                    operation_type=CleanupType.FILE_DELETION,
                    description="Clear system temp files",
                    command='del /f /s /q "C:\\Windows\\Temp\\*" 2>nul',
                    risk_level=3
                ),
                CleanupOperation(
                    operation_type=CleanupType.FILE_DELETION,
                    description="Clear prefetch files",
                    command='del /f /s /q "C:\\Windows\\Prefetch\\*" 2>nul',
                    risk_level=4
                ),
                CleanupOperation(
                    operation_type=CleanupType.FILE_DELETION,
                    description="Clear recent documents",
                    command='del /f /s /q "%APPDATA%\\Microsoft\\Windows\\Recent\\*" 2>nul',
                    risk_level=3
                ),
                CleanupOperation(
                    operation_type=CleanupType.FILE_DELETION,
                    description="Clear browser cache (Chrome)",
                    command='del /f /s /q "%LOCALAPPDATA%\\Google\\Chrome\\User Data\\Default\\Cache\\*" 2>nul',
                    risk_level=2
                ),
                CleanupOperation(
                    operation_type=CleanupType.FILE_DELETION,
                    description="Clear browser cache (Firefox)",
                    command='del /f /s /q "%APPDATA%\\Mozilla\\Firefox\\Profiles\\*\\cache2\\*" 2>nul',
                    risk_level=2
                )
            ])
        else:
            # Linux/Unix file cleanup
            operations.extend([
                CleanupOperation(
                    operation_type=CleanupType.FILE_DELETION,
                    description="Clear temp files",
                    command="rm -rf /tmp/* /var/tmp/* 2>/dev/null",
                    risk_level=2
                ),
                CleanupOperation(
                    operation_type=CleanupType.FILE_DELETION,
                    description="Clear user cache",
                    command="rm -rf ~/.cache/* 2>/dev/null",
                    risk_level=2
                ),
                CleanupOperation(
                    operation_type=CleanupType.FILE_DELETION,
                    description="Clear bash history",
                    command="history -c && rm -f ~/.bash_history 2>/dev/null",
                    risk_level=4
                ),
                CleanupOperation(
                    operation_type=CleanupType.FILE_DELETION,
                    description="Clear system logs in /var/log",
                    command="find /var/log -type f -name '*.log' -exec truncate -s 0 {} \\; 2>/dev/null",
                    risk_level=5
                )
            ])
        
        return operations

    def _get_process_cleanup_operations(self) -> List[CleanupOperation]:
        """Get process cleanup operations."""
        operations = []
        
        if sys.platform.startswith('win'):
            # Windows process cleanup
            operations.extend([
                CleanupOperation(
                    operation_type=CleanupType.PROCESS_CLEANUP,
                    description="Kill suspicious processes",
                    command='taskkill /f /im "cmd.exe" /im "powershell.exe" 2>nul || echo "No suspicious processes"',
                    risk_level=3
                ),
                CleanupOperation(
                    operation_type=CleanupType.PROCESS_CLEANUP,
                    description="Clear process environment variables",
                    command='set TEMP= && set TMP= && set COMPUTERNAME=WORKSTATION',
                    risk_level=2
                )
            ])
        else:
            # Linux/Unix process cleanup
            operations.extend([
                CleanupOperation(
                    operation_type=CleanupType.PROCESS_CLEANUP,
                    description="Kill pentest processes",
                    command="pkill -f '(nmap|sqlmap|metasploit|msfconsole)' 2>/dev/null || echo 'No processes to kill'",
                    risk_level=3
                ),
                CleanupOperation(
                    operation_type=CleanupType.PROCESS_CLEANUP,
                    description="Clear environment variables",
                    command="unset HISTFILE && unset HISTSIZE && export HISTSIZE=0",
                    risk_level=2
                )
            ])
        
        return operations

    def _get_log_cleanup_operations(self) -> List[CleanupOperation]:
        """Get log cleanup operations."""
        operations = []
        
        if sys.platform.startswith('win'):
            # Windows log cleanup
            operations.extend([
                CleanupOperation(
                    operation_type=CleanupType.LOG_CLEANING,
                    description="Clear Windows System event log",
                    command='wevtutil cl "System"',
                    risk_level=5
                ),
                CleanupOperation(
                    operation_type=CleanupType.LOG_CLEANING,
                    description="Clear Windows Application event log",
                    command='wevtutil cl "Application"',
                    risk_level=5
                ),
                CleanupOperation(
                    operation_type=CleanupType.LOG_CLEANING,
                    description="Clear Windows Security event log",
                    command='wevtutil cl "Security"',
                    risk_level=5
                ),
                CleanupOperation(
                    operation_type=CleanupType.LOG_CLEANING,
                    description="Clear PowerShell logs",
                    command='wevtutil cl "Microsoft-Windows-PowerShell/Operational"',
                    risk_level=5
                ),
                CleanupOperation(
                    operation_type=CleanupType.LOG_CLEANING,
                    description="Clear Windows Defender logs",
                    command='wevtutil cl "Microsoft-Windows-Windows Defender/Operational"',
                    risk_level=4
                )
            ])
        else:
            # Linux log cleanup
            operations.extend([
                CleanupOperation(
                    operation_type=CleanupType.LOG_CLEANING,
                    description="Clear systemd journal",
                    command="journalctl --vacuum-time=1s",
                    risk_level=5
                ),
                CleanupOperation(
                    operation_type=CleanupType.LOG_CLEANING,
                    description="Clear auth logs",
                    command="echo '' > /var/log/auth.log && echo '' > /var/log/secure 2>/dev/null",
                    risk_level=5
                ),
                CleanupOperation(
                    operation_type=CleanupType.LOG_CLEANING,
                    description="Clear syslog",
                    command="echo '' > /var/log/syslog && echo '' > /var/log/messages 2>/dev/null",
                    risk_level=5
                ),
                CleanupOperation(
                    operation_type=CleanupType.LOG_CLEANING,
                    description="Clear Apache/Nginx logs",
                    command="find /var/log -name '*access.log*' -exec truncate -s 0 {} \\; 2>/dev/null",
                    risk_level=4
                )
            ])
        
        return operations

    def _get_registry_cleanup_operations(self) -> List[CleanupOperation]:
        """Get registry cleanup operations (Windows only)."""
        operations = []
        
        if sys.platform.startswith('win'):
            operations.extend([
                CleanupOperation(
                    operation_type=CleanupType.REGISTRY_CLEANUP,
                    description="Clear MRU (Most Recently Used) lists",
                    command='reg delete "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU" /f 2>nul',
                    risk_level=3
                ),
                CleanupOperation(
                    operation_type=CleanupType.REGISTRY_CLEANUP,
                    description="Clear typed URLs",
                    command='reg delete "HKCU\\Software\\Microsoft\\Internet Explorer\\TypedURLs" /f 2>nul',
                    risk_level=3
                ),
                CleanupOperation(
                    operation_type=CleanupType.REGISTRY_CLEANUP,
                    description="Clear recent documents registry",
                    command='reg delete "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs" /f 2>nul',
                    risk_level=4
                ),
                CleanupOperation(
                    operation_type=CleanupType.REGISTRY_CLEANUP,
                    description="Clear UserAssist entries",
                    command='reg delete "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist" /f 2>nul',
                    risk_level=4
                ),
                CleanupOperation(
                    operation_type=CleanupType.REGISTRY_CLEANUP,
                    description="Clear Windows Search index",
                    command='reg delete "HKCU\\Software\\Microsoft\\Windows Search\\Gather\\Windows\\SystemIndex" /f 2>nul',
                    risk_level=3
                )
            ])
        
        return operations

    def _get_memory_cleanup_operations(self) -> List[CleanupOperation]:
        """Get memory cleanup operations."""
        operations = []
        
        if sys.platform.startswith('win'):
            # Windows memory cleanup
            operations.extend([
                CleanupOperation(
                    operation_type=CleanupType.MEMORY_CLEANUP,
                    description="Clear clipboard",
                    command='echo | clip',
                    risk_level=1
                ),
                CleanupOperation(
                    operation_type=CleanupType.MEMORY_CLEANUP,
                    description="Clear page file on shutdown",
                    command='reg add "HKLM\\System\\CurrentControlSet\\Control\\Session Manager\\Memory Management" /v "ClearPageFileAtShutdown" /t REG_DWORD /d 1 /f',
                    risk_level=2
                ),
                CleanupOperation(
                    operation_type=CleanupType.MEMORY_CLEANUP,
                    description="Flush memory caches",
                    command='rundll32.exe advapi32.dll,ProcessIdleTasks',
                    risk_level=2
                )
            ])
        else:
            # Linux memory cleanup
            operations.extend([
                CleanupOperation(
                    operation_type=CleanupType.MEMORY_CLEANUP,
                    description="Clear memory caches",
                    command="sync && echo 3 > /proc/sys/vm/drop_caches 2>/dev/null",
                    risk_level=2
                ),
                CleanupOperation(
                    operation_type=CleanupType.MEMORY_CLEANUP,
                    description="Clear swap if possible",
                    command="swapoff -a && swapon -a 2>/dev/null",
                    risk_level=3
                )
            ])
        
        return operations

    def _get_artifact_removal_operations(self) -> List[CleanupOperation]:
        """Get artifact removal operations."""
        operations = []
        
        common_artifacts = [
            CleanupOperation(
                operation_type=CleanupType.ARTIFACT_REMOVAL,
                description="Remove tool artifacts",
                command=self._get_tool_cleanup_command(),
                risk_level=3
            ),
            CleanupOperation(
                operation_type=CleanupType.ARTIFACT_REMOVAL,
                description="Clear DNS resolution cache",
                command=self._get_dns_artifact_cleanup_command(),
                risk_level=2
            )
        ]
        
        operations.extend(common_artifacts)
        
        if sys.platform.startswith('win'):
            # Windows-specific artifact removal
            operations.extend([
                CleanupOperation(
                    operation_type=CleanupType.ARTIFACT_REMOVAL,
                    description="Clear Windows thumbnail cache",
                    command='del /f /s /q "%LOCALAPPDATA%\\Microsoft\\Windows\\Explorer\\thumbcache_*.db" 2>nul',
                    risk_level=2
                ),
                CleanupOperation(
                    operation_type=CleanupType.ARTIFACT_REMOVAL,
                    description="Clear Windows icon cache",
                    command='del /f /s /q "%LOCALAPPDATA%\\IconCache.db" 2>nul',
                    risk_level=2
                ),
                CleanupOperation(
                    operation_type=CleanupType.ARTIFACT_REMOVAL,
                    description="Clear Windows search history",
                    command='reg delete "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\WordWheelQuery" /f 2>nul',
                    risk_level=3
                )
            ])
        else:
            # Linux-specific artifact removal
            operations.extend([
                CleanupOperation(
                    operation_type=CleanupType.ARTIFACT_REMOVAL,
                    description="Clear shell history files",
                    command="rm -f ~/.bash_history ~/.zsh_history ~/.fish_history 2>/dev/null",
                    risk_level=4
                ),
                CleanupOperation(
                    operation_type=CleanupType.ARTIFACT_REMOVAL,
                    description="Clear recently used files",
                    command="rm -f ~/.recently-used* ~/.local/share/recently-used.xbel 2>/dev/null",
                    risk_level=3
                )
            ])
        
        return operations

    def _get_tool_cleanup_command(self) -> str:
        """Get command to cleanup tool-specific artifacts."""
        if sys.platform.startswith('win'):
            return '''
            del /f /q "%TEMP%\\nmap*" "%TEMP%\\sqlmap*" "%TEMP%\\metasploit*" 2>nul
            reg delete "HKCU\\Software\\Nmap" /f 2>nul
            reg delete "HKCU\\Software\\Metasploit" /f 2>nul
            '''.strip()
        else:
            return '''
            rm -rf /tmp/nmap* /tmp/sqlmap* /tmp/metasploit* 2>/dev/null
            rm -rf ~/.nmap ~/.sqlmap ~/.metasploit 2>/dev/null
            find /var/log -name "*nmap*" -delete 2>/dev/null
            find /var/log -name "*sqlmap*" -delete 2>/dev/null
            '''.strip()

    def _get_dns_artifact_cleanup_command(self) -> str:
        """Get command to cleanup DNS-related artifacts."""
        if sys.platform.startswith('win'):
            return "ipconfig /flushdns && netsh interface ip delete arpcache"
        else:
            return "systemctl restart systemd-resolved 2>/dev/null || service nscd restart 2>/dev/null"

    def _execute_operation(self, operation: CleanupOperation) -> bool:
        """Execute a single cleanup operation."""
        try:
            result = subprocess.run(
                operation.command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                self.logger.debug(f"Command executed successfully: {result.stdout}")
                return True
            else:
                operation.error = result.stderr
                self.logger.warning(f"Command failed: {result.stderr}")
                return False
                
        except subprocess.TimeoutExpired:
            operation.error = "Command timed out"
            self.logger.error(f"Command timed out: {operation.command}")
            return False
        except Exception as e:
            operation.error = str(e)
            self.logger.error(f"Error executing command: {e}")
            return False


def main():
    """Main function for testing the module."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Cleanup Module")
    parser.add_argument("--target", required=True, help="Target system IP/hostname")
    parser.add_argument("--profile", choices=['minimal', 'default', 'aggressive'], 
                       default='default', help="Cleanup profile")
    
    args = parser.parse_args()
    
    # Initialize module
    cleanup_module = CleanupModule(args.target)
    
    # Perform cleanup
    results = cleanup_module.perform_cleanup(profile=args.profile)
    
    # Print summary
    print(f"\n=== Cleanup Results ===")
    print(f"Target: {results['target']}")
    print(f"Profile: {results['profile']}")
    print(f"Successful operations: {results['successful_operations']}")
    print(f"Failed operations: {results['failed_operations']}")
    print(f"Execution time: {results['execution_time']:.2f} seconds")


if __name__ == "__main__":
    main()