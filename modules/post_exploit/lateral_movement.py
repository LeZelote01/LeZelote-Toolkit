#!/usr/bin/env python3
"""
Lateral Movement Module - Pentest USB Toolkit

This module implements comprehensive lateral movement capabilities including
PsExec, WMIExec, Evil-WinRM, and network share enumeration techniques.

Author: Pentest USB Team
Version: 1.0.0
"""

import os
import sys
import json
import logging
import subprocess
import time
import socket
from pathlib import Path
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum
from concurrent.futures import ThreadPoolExecutor, as_completed

# Internal imports
sys.path.append(str(Path(__file__).parent.parent.parent))
from core.utils.logging_handler import setup_logger
from core.utils.error_handler import handle_error
from core.utils.network_utils import is_port_open, get_network_range
from core.security.consent_manager import ConsentManager
from core.db.sqlite_manager import DatabaseManager


class MovementMethod(Enum):
    """Lateral movement methods."""
    PSEXEC = "psexec"
    WMIEXEC = "wmiexec"
    SMBEXEC = "smbexec"
    WINRM = "winrm"
    SSH = "ssh"
    RDP = "rdp"
    DCOM = "dcom"
    SCHEDULED_TASK = "scheduled_task"


class ServiceType(Enum):
    """Network service types."""
    SMB = "smb"
    WMI = "wmi"
    WINRM = "winrm"
    SSH = "ssh"
    RDP = "rdp"
    TELNET = "telnet"
    FTP = "ftp"
    SNMP = "snmp"


@dataclass
class Target:
    """Target host information."""
    ip: str
    hostname: Optional[str] = None
    os: Optional[str] = None
    domain: Optional[str] = None
    services: List[Dict[str, Any]] = None
    credentials: List[Dict[str, Any]] = None
    status: str = "unknown"


@dataclass
class MovementResult:
    """Result of a lateral movement attempt."""
    target: str
    method: MovementMethod
    success: bool
    credentials_used: Dict[str, str]
    command_executed: str
    output: str
    error: Optional[str] = None
    timestamp: Optional[str] = None


class LateralMovementModule:
    """Main class for lateral movement operations."""
    
    def __init__(self, initial_target: str, config: Dict[str, Any] = None):
        self.initial_target = initial_target
        self.config = config or {}
        self.logger = setup_logger(__name__)
        self.consent_manager = ConsentManager()
        self.db_manager = DatabaseManager()
        
        # Discovered targets
        self.targets: List[Target] = []
        self.compromised_hosts: List[str] = []
        self.movement_history: List[MovementResult] = []
        
        # Tool paths
        self.tool_paths = {
            'psexec': self._get_tool_path('psexec'),
            'wmiexec': self._get_tool_path('wmiexec'),
            'smbexec': self._get_tool_path('smbexec'),
            'evil-winrm': self._get_tool_path('evil-winrm'),
            'crackmapexec': self._get_tool_path('crackmapexec'),
            'impacket': self._get_tool_path('impacket'),
            'smbclient': self._get_tool_path('smbclient'),
            'nmap': self._get_tool_path('nmap')
        }
        
        # Credentials store
        self.credentials = []
        
        self.logger.info(f"Initialized LateralMovementModule from: {initial_target}")

    def _get_tool_path(self, tool_name: str) -> str:
        """Get the appropriate tool path based on OS."""
        base_path = Path(__file__).parent.parent.parent / "tools" / "binaries"
        
        if sys.platform.startswith('win'):
            return str(base_path / "windows" / f"{tool_name}.exe")
        elif sys.platform.startswith('linux'):
            return str(base_path / "linux" / tool_name)
        else:  # macOS
            return str(base_path / "macos" / tool_name)

    @handle_error
    def perform_lateral_movement(self, credentials: List[Dict[str, str]], 
                               targets: List[str] = None, 
                               methods: List[str] = None,
                               profile: str = "default") -> Dict[str, Any]:
        """
        Main method to perform lateral movement operations.
        
        Args:
            credentials: List of credential dictionaries
            targets: List of target IPs/hostnames
            methods: List of movement methods to use
            profile: Movement profile (quick, default, comprehensive)
            
        Returns:
            Dictionary containing movement results
        """
        self.logger.info("Starting lateral movement operations")
        
        # Verify consent for all targets
        all_targets = targets or [self.initial_target]
        for target in all_targets:
            if not self.consent_manager.verify_authorization(target, "lateral_movement"):
                raise PermissionError(f"No authorization for lateral movement on target {target}")
        
        self.credentials = credentials
        
        if not targets:
            targets = self._discover_targets()
        
        if not methods:
            methods = self._get_default_methods(profile)
        
        results = {
            'initial_target': self.initial_target,
            'targets_discovered': len(targets),
            'methods_used': methods,
            'successful_movements': [],
            'failed_movements': [],
            'compromised_hosts': [],
            'network_shares': [],
            'execution_time': 0
        }
        
        start_time = time.time()
        
        try:
            # Discover and enumerate network targets
            self.logger.info("Discovering network targets")
            discovered_targets = self._enumerate_network_targets(targets)
            
            # Enumerate network shares
            self.logger.info("Enumerating network shares")
            shares = self._enumerate_network_shares(discovered_targets)
            results['network_shares'] = shares
            
            # Perform lateral movement attempts
            self.logger.info("Attempting lateral movement")
            for target in discovered_targets:
                for method in methods:
                    movement_results = self._attempt_movement(target, method, credentials)
                    
                    for result in movement_results:
                        if result.success:
                            results['successful_movements'].append(result.__dict__)
                            if result.target not in self.compromised_hosts:
                                self.compromised_hosts.append(result.target)
                        else:
                            results['failed_movements'].append(result.__dict__)
            
            results['compromised_hosts'] = self.compromised_hosts
            
            # Perform post-movement enumeration on compromised hosts
            if self.compromised_hosts:
                self.logger.info("Performing post-movement enumeration")
                enum_results = self._post_movement_enumeration()
                results['enumeration_results'] = enum_results
        
        except Exception as e:
            self.logger.error(f"Error during lateral movement: {e}")
            results['error'] = str(e)
        
        finally:
            results['execution_time'] = time.time() - start_time
            
        self.logger.info(f"Lateral movement completed in {results['execution_time']:.2f} seconds")
        return results

    def _get_default_methods(self, profile: str) -> List[str]:
        """Get default movement methods based on profile."""
        methods = {
            'quick': ['psexec', 'wmiexec'],
            'default': ['psexec', 'wmiexec', 'smbexec', 'winrm'],
            'comprehensive': [
                'psexec', 'wmiexec', 'smbexec', 'winrm', 
                'ssh', 'dcom', 'scheduled_task'
            ]
        }
        return methods.get(profile, methods['default'])

    def _discover_targets(self) -> List[str]:
        """Discover potential targets in the network."""
        self.logger.info("Discovering network targets")
        
        targets = []
        
        try:
            # Get network range from initial target
            network_range = get_network_range(self.initial_target)
            
            # Use Nmap for host discovery
            if Path(self.tool_paths['nmap']).exists():
                nmap_targets = self._nmap_host_discovery(network_range)
                targets.extend(nmap_targets)
            
            # ARP scan for local network
            arp_targets = self._arp_scan_discovery(network_range)
            targets.extend(arp_targets)
            
            # Remove duplicates
            targets = list(set(targets))
            
        except Exception as e:
            self.logger.error(f"Error discovering targets: {e}")
        
        return targets

    def _nmap_host_discovery(self, network_range: str) -> List[str]:
        """Use Nmap for host discovery."""
        try:
            cmd = [
                self.tool_paths['nmap'],
                '-sn',  # Ping scan
                network_range
            ]
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=300
            )
            
            if result.returncode == 0:
                # Parse Nmap output for live hosts
                lines = result.stdout.split('\n')
                hosts = []
                for line in lines:
                    if "Nmap scan report for" in line:
                        parts = line.split()
                        if len(parts) >= 5:
                            ip = parts[-1].strip('()')
                            hosts.append(ip)
                return hosts
            
        except (subprocess.TimeoutExpired, Exception) as e:
            self.logger.error(f"Nmap discovery failed: {e}")
        
        return []

    def _arp_scan_discovery(self, network_range: str) -> List[str]:
        """Use ARP scan for local network discovery."""
        # Simplified ARP discovery implementation
        # In practice, this would use tools like arp-scan or netdiscover
        return []

    def _enumerate_network_targets(self, target_ips: List[str]) -> List[Target]:
        """Enumerate discovered targets to identify services."""
        targets = []
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            future_to_ip = {
                executor.submit(self._enumerate_single_target, ip): ip 
                for ip in target_ips
            }
            
            for future in as_completed(future_to_ip):
                ip = future_to_ip[future]
                try:
                    target = future.result()
                    if target:
                        targets.append(target)
                except Exception as e:
                    self.logger.error(f"Error enumerating {ip}: {e}")
        
        return targets

    def _enumerate_single_target(self, ip: str) -> Optional[Target]:
        """Enumerate a single target for services and OS information."""
        target = Target(ip=ip)
        
        try:
            # Port scan for common services
            services = []
            common_ports = [21, 22, 23, 25, 53, 80, 135, 139, 389, 443, 445, 993, 995, 3389, 5985, 5986]
            
            for port in common_ports:
                if is_port_open(ip, port, timeout=2):
                    service = self._identify_service(ip, port)
                    services.append(service)
            
            target.services = services
            
            # Try to get hostname
            try:
                target.hostname = socket.gethostbyaddr(ip)[0]
            except socket.herror:
                pass
            
            # OS fingerprinting (simplified)
            target.os = self._identify_os(ip, services)
            
            return target
            
        except Exception as e:
            self.logger.error(f"Error enumerating target {ip}: {e}")
            return None

    def _identify_service(self, ip: str, port: int) -> Dict[str, Any]:
        """Identify service running on a specific port."""
        service_map = {
            21: 'ftp',
            22: 'ssh',
            23: 'telnet',
            25: 'smtp',
            53: 'dns',
            80: 'http',
            135: 'rpc',
            139: 'netbios-ssn',
            389: 'ldap',
            443: 'https',
            445: 'smb',
            993: 'imaps',
            995: 'pop3s',
            3389: 'rdp',
            5985: 'winrm',
            5986: 'winrm-ssl'
        }
        
        return {
            'port': port,
            'service': service_map.get(port, 'unknown'),
            'state': 'open'
        }

    def _identify_os(self, ip: str, services: List[Dict[str, Any]]) -> str:
        """Simple OS identification based on open services."""
        service_names = [s['service'] for s in services]
        
        if 'smb' in service_names or 'winrm' in service_names or 'rdp' in service_names:
            return 'windows'
        elif 'ssh' in service_names:
            return 'linux'
        else:
            return 'unknown'

    def _enumerate_network_shares(self, targets: List[Target]) -> List[Dict[str, Any]]:
        """Enumerate network shares on discovered targets."""
        shares = []
        
        for target in targets:
            if any(s['service'] == 'smb' for s in target.services or []):
                target_shares = self._enumerate_smb_shares(target.ip)
                shares.extend(target_shares)
        
        return shares

    def _enumerate_smb_shares(self, ip: str) -> List[Dict[str, Any]]:
        """Enumerate SMB shares on a target."""
        shares = []
        
        try:
            # Use smbclient or CrackMapExec for share enumeration
            if Path(self.tool_paths['crackmapexec']).exists():
                shares = self._cme_share_enumeration(ip)
            elif Path(self.tool_paths['smbclient']).exists():
                shares = self._smbclient_enumeration(ip)
            
        except Exception as e:
            self.logger.error(f"Error enumerating shares on {ip}: {e}")
        
        return shares

    def _cme_share_enumeration(self, ip: str) -> List[Dict[str, Any]]:
        """Use CrackMapExec for share enumeration."""
        try:
            cmd = [self.tool_paths['crackmapexec'], 'smb', ip, '--shares']
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=60
            )
            
            if result.returncode == 0:
                return self._parse_cme_shares_output(ip, result.stdout)
            
        except Exception as e:
            self.logger.error(f"CrackMapExec share enumeration failed: {e}")
        
        return []

    def _parse_cme_shares_output(self, ip: str, output: str) -> List[Dict[str, Any]]:
        """Parse CrackMapExec share enumeration output."""
        shares = []
        lines = output.split('\n')
        
        for line in lines:
            if 'READ' in line or 'WRITE' in line:
                parts = line.split()
                if len(parts) >= 3:
                    share_name = parts[2]
                    permissions = []
                    if 'READ' in line:
                        permissions.append('READ')
                    if 'WRITE' in line:
                        permissions.append('WRITE')
                    
                    shares.append({
                        'target': ip,
                        'share_name': share_name,
                        'permissions': permissions,
                        'accessible': True
                    })
        
        return shares

    def _smbclient_enumeration(self, ip: str) -> List[Dict[str, Any]]:
        """Use smbclient for share enumeration."""
        # Implementation for smbclient share enumeration
        return []

    def _attempt_movement(self, target: Target, method: str, 
                         credentials: List[Dict[str, str]]) -> List[MovementResult]:
        """Attempt lateral movement to a target using a specific method."""
        results = []
        
        for cred in credentials:
            try:
                if method == 'psexec':
                    result = self._psexec_movement(target, cred)
                elif method == 'wmiexec':
                    result = self._wmiexec_movement(target, cred)
                elif method == 'smbexec':
                    result = self._smbexec_movement(target, cred)
                elif method == 'winrm':
                    result = self._winrm_movement(target, cred)
                elif method == 'ssh':
                    result = self._ssh_movement(target, cred)
                elif method == 'dcom':
                    result = self._dcom_movement(target, cred)
                else:
                    continue
                
                if result:
                    results.append(result)
                    if result.success:
                        break  # Success with this credential, move to next target
                        
            except Exception as e:
                self.logger.error(f"Error in {method} movement to {target.ip}: {e}")
        
        return results

    def _psexec_movement(self, target: Target, credentials: Dict[str, str]) -> MovementResult:
        """Attempt PsExec lateral movement."""
        self.logger.info(f"Attempting PsExec movement to {target.ip}")
        
        try:
            domain = credentials.get('domain', '')
            username = credentials.get('username', '')
            password = credentials.get('password', '')
            hash_value = credentials.get('hash', '')
            
            # Build PsExec command
            cmd = [self.tool_paths['psexec']]
            
            if hash_value:
                cmd.extend(['-hashes', f':{hash_value}'])
            else:
                cmd.extend(['-u', username, '-p', password])
            
            if domain:
                cmd.extend(['-d', domain])
            
            cmd.extend([target.ip, 'whoami'])
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            success = result.returncode == 0
            
            return MovementResult(
                target=target.ip,
                method=MovementMethod.PSEXEC,
                success=success,
                credentials_used=credentials,
                command_executed='whoami',
                output=result.stdout,
                error=result.stderr if not success else None,
                timestamp=time.strftime("%Y-%m-%d %H:%M:%S")
            )
            
        except subprocess.TimeoutExpired:
            return MovementResult(
                target=target.ip,
                method=MovementMethod.PSEXEC,
                success=False,
                credentials_used=credentials,
                command_executed='whoami',
                output='',
                error='Timeout expired',
                timestamp=time.strftime("%Y-%m-%d %H:%M:%S")
            )

    def _wmiexec_movement(self, target: Target, credentials: Dict[str, str]) -> MovementResult:
        """Attempt WMIExec lateral movement."""
        # Similar implementation to PsExec but using WMI
        self.logger.info(f"Attempting WMIExec movement to {target.ip}")
        
        # Implementation placeholder
        return MovementResult(
            target=target.ip,
            method=MovementMethod.WMIEXEC,
            success=False,
            credentials_used=credentials,
            command_executed='whoami',
            output='',
            error='Not implemented',
            timestamp=time.strftime("%Y-%m-%d %H:%M:%S")
        )

    def _smbexec_movement(self, target: Target, credentials: Dict[str, str]) -> MovementResult:
        """Attempt SMBExec lateral movement."""
        self.logger.info(f"Attempting SMBExec movement to {target.ip}")
        
        # Implementation placeholder
        return MovementResult(
            target=target.ip,
            method=MovementMethod.SMBEXEC,
            success=False,
            credentials_used=credentials,
            command_executed='whoami',
            output='',
            error='Not implemented',
            timestamp=time.strftime("%Y-%m-%d %H:%M:%S")
        )

    def _winrm_movement(self, target: Target, credentials: Dict[str, str]) -> MovementResult:
        """Attempt WinRM lateral movement using Evil-WinRM."""
        self.logger.info(f"Attempting WinRM movement to {target.ip}")
        
        # Check if WinRM port is open
        if not any(s.get('port') in [5985, 5986] for s in target.services or []):
            return MovementResult(
                target=target.ip,
                method=MovementMethod.WINRM,
                success=False,
                credentials_used=credentials,
                command_executed='whoami',
                output='',
                error='WinRM port not open',
                timestamp=time.strftime("%Y-%m-%d %H:%M:%S")
            )
        
        # Implementation placeholder for Evil-WinRM
        return MovementResult(
            target=target.ip,
            method=MovementMethod.WINRM,
            success=False,
            credentials_used=credentials,
            command_executed='whoami',
            output='',
            error='Not implemented',
            timestamp=time.strftime("%Y-%m-%d %H:%M:%S")
        )

    def _ssh_movement(self, target: Target, credentials: Dict[str, str]) -> MovementResult:
        """Attempt SSH lateral movement."""
        self.logger.info(f"Attempting SSH movement to {target.ip}")
        
        # Implementation placeholder
        return MovementResult(
            target=target.ip,
            method=MovementMethod.SSH,
            success=False,
            credentials_used=credentials,
            command_executed='whoami',
            output='',
            error='Not implemented',
            timestamp=time.strftime("%Y-%m-%d %H:%M:%S")
        )

    def _dcom_movement(self, target: Target, credentials: Dict[str, str]) -> MovementResult:
        """Attempt DCOM lateral movement."""
        self.logger.info(f"Attempting DCOM movement to {target.ip}")
        
        # Implementation placeholder
        return MovementResult(
            target=target.ip,
            method=MovementMethod.DCOM,
            success=False,
            credentials_used=credentials,
            command_executed='whoami',
            output='',
            error='Not implemented',
            timestamp=time.strftime("%Y-%m-%d %H:%M:%S")
        )

    def _post_movement_enumeration(self) -> Dict[str, Any]:
        """Perform enumeration on compromised hosts."""
        enum_results = {}
        
        for host in self.compromised_hosts:
            self.logger.info(f"Performing post-movement enumeration on {host}")
            
            host_results = {
                'system_info': self._get_system_info(host),
                'network_info': self._get_network_info(host),
                'user_info': self._get_user_info(host),
                'process_info': self._get_process_info(host)
            }
            
            enum_results[host] = host_results
        
        return enum_results

    def _get_system_info(self, host: str) -> Dict[str, Any]:
        """Get system information from compromised host."""
        # Implementation for system enumeration
        return {}

    def _get_network_info(self, host: str) -> Dict[str, Any]:
        """Get network information from compromised host."""
        # Implementation for network enumeration
        return {}

    def _get_user_info(self, host: str) -> Dict[str, Any]:
        """Get user information from compromised host."""
        # Implementation for user enumeration
        return {}

    def _get_process_info(self, host: str) -> Dict[str, Any]:
        """Get process information from compromised host."""
        # Implementation for process enumeration
        return {}

    def execute_command_on_host(self, host: str, command: str, 
                               credentials: Dict[str, str] = None) -> Dict[str, Any]:
        """Execute a command on a compromised host."""
        self.logger.info(f"Executing command on {host}: {command}")
        
        if not credentials:
            # Use stored credentials for this host
            credentials = self._get_stored_credentials(host)
        
        # Try different execution methods
        for method in ['psexec', 'wmiexec', 'winrm']:
            try:
                result = self._execute_via_method(host, command, method, credentials)
                if result['success']:
                    return result
            except Exception as e:
                self.logger.error(f"Failed to execute via {method}: {e}")
        
        return {'success': False, 'output': '', 'error': 'All execution methods failed'}

    def _get_stored_credentials(self, host: str) -> Dict[str, str]:
        """Get stored credentials for a specific host."""
        # Implementation to retrieve stored credentials
        return {}

    def _execute_via_method(self, host: str, command: str, method: str, 
                           credentials: Dict[str, str]) -> Dict[str, Any]:
        """Execute command via specific method."""
        # Implementation for command execution
        return {'success': False, 'output': '', 'error': 'Not implemented'}


def main():
    """Main function for testing the module."""
    import argparse
    
    parser = argparse.ArgumentParser(description="Lateral Movement Module")
    parser.add_argument("--target", required=True, help="Initial target IP/hostname")
    parser.add_argument("--credentials", required=True, help="JSON file with credentials")
    parser.add_argument("--profile", choices=['quick', 'default', 'comprehensive'], 
                       default='default', help="Movement profile")
    parser.add_argument("--methods", nargs='+', help="Specific methods to use")
    parser.add_argument("--targets", nargs='+', help="Specific target hosts")
    
    args = parser.parse_args()
    
    # Load credentials
    with open(args.credentials, 'r') as f:
        credentials = json.load(f)
    
    # Initialize module
    movement_module = LateralMovementModule(args.target)
    
    # Perform lateral movement
    results = movement_module.perform_lateral_movement(
        credentials=credentials,
        targets=args.targets,
        methods=args.methods,
        profile=args.profile
    )
    
    # Print summary
    print(f"\n=== Lateral Movement Results ===")
    print(f"Initial target: {results['initial_target']}")
    print(f"Targets discovered: {results['targets_discovered']}")
    print(f"Methods used: {', '.join(results['methods_used'])}")
    print(f"Successful movements: {len(results['successful_movements'])}")
    print(f"Failed movements: {len(results['failed_movements'])}")
    print(f"Compromised hosts: {len(results['compromised_hosts'])}")
    print(f"Network shares found: {len(results['network_shares'])}")
    print(f"Execution time: {results['execution_time']:.2f} seconds")


if __name__ == "__main__":
    main()