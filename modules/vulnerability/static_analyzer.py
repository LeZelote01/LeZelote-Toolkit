"""
Pentest-USB Toolkit - Static Code Analysis Module
================================================

Static code analysis and secret detection using Semgrep, TruffleHog, Gitleaks,
and other static analysis tools for comprehensive security code review.

Author: Pentest-USB Development Team
Version: 1.0.0
"""

import subprocess
import json
import os
import time
import re
from pathlib import Path
from typing import Dict, List, Any, Optional

from ...core.utils.logging_handler import get_logger
from ...core.utils.error_handler import PentestError


class StaticAnalysisError(PentestError):
    """Static analysis specific error"""
    pass


class StaticCodeAnalyzer:
    """
    Static code analysis and security scanning module
    """
    
    def __init__(self):
        """Initialize Static Code Analyzer"""
        self.logger = get_logger(__name__)
        
        # Tool paths
        self.tools = {
            'semgrep': self._find_tool('semgrep'),
            'trufflehog': self._find_tool('trufflehog'),
            'bandit': self._find_tool('bandit')
        }
        
        # Supported file extensions
        self.language_extensions = {
            'python': ['.py', '.pyx', '.pyw'],
            'javascript': ['.js', '.jsx', '.ts', '.tsx'],
            'java': ['.java', '.jsp'],
            'php': ['.php', '.phtml']
        }
        
        # Secret patterns
        self.secret_patterns = {
            'api_key': r'(?i)(api[_-]?key|apikey)[\s]*[=:]+[\s]*[\'"]?([a-zA-Z0-9_\-]{20,})[\'"]?',
            'password': r'(?i)(password|passwd|pwd)[\s]*[=:]+[\s]*[\'"]?([^\s\'"]{8,})[\'"]?'
        }
        
        self.logger.info("StaticCodeAnalyzer initialized")
    
    def _find_tool(self, tool_name: str) -> Optional[str]:
        """Find tool executable path"""
        import shutil
        
        tool_path = shutil.which(tool_name)
        if tool_path:
            return tool_path
        
        potential_paths = [
            f'./tools/binaries/{tool_name}',
            f'./tools/python_scripts/{tool_name}.py'
        ]
        
        for path in potential_paths:
            if Path(path).exists():
                return str(Path(path).absolute())
        
        self.logger.warning(f"Tool {tool_name} not found")
        return None
    
    def analyze_codebase(self, target_path: str, profile: str = "default", 
                        languages: Optional[List[str]] = None) -> Dict[str, Any]:
        """
        Comprehensive static code analysis
        
        Args:
            target_path: Path to codebase (file or directory)
            profile: Analysis profile (quick, default, comprehensive)
            languages: Specific languages to analyze
            
        Returns:
            Static analysis results
        """
        try:
            self.logger.info(f"Starting static code analysis: {target_path} (profile: {profile})")
            
            if not Path(target_path).exists():
                raise StaticAnalysisError(f"Target path does not exist: {target_path}")
            
            if not languages:
                languages = self._detect_languages(target_path)
            
            results = {
                'target_path': target_path,
                'profile': profile,
                'languages_detected': languages,
                'timestamp': time.time(),
                'vulnerabilities': [],
                'secrets': [],
                'tool_results': {},
                'summary': {}
            }
            
            # Basic secret scanning
            secrets = self._regex_secret_scan(target_path)
            results['secrets'] = secrets
            results['tool_results']['secret_scan'] = len(secrets)
            
            # Generate summary
            results['summary'] = self._generate_static_analysis_summary(results)
            
            return results
            
        except Exception as e:
            self.logger.error(f"Static code analysis failed: {str(e)}")
            raise StaticAnalysisError(f"Static analysis failed: {str(e)}")
    
    def _detect_languages(self, target_path: str) -> List[str]:
        """Detect programming languages in the codebase"""
        try:
            detected_languages = set()
            
            if Path(target_path).is_file():
                file_ext = Path(target_path).suffix.lower()
                for lang, extensions in self.language_extensions.items():
                    if file_ext in extensions:
                        detected_languages.add(lang)
            else:
                for root, dirs, files in os.walk(target_path):
                    for file in files:
                        file_ext = Path(file).suffix.lower()
                        for lang, extensions in self.language_extensions.items():
                            if file_ext in extensions:
                                detected_languages.add(lang)
            
            return list(detected_languages)
            
        except Exception as e:
            self.logger.error(f"Language detection failed: {str(e)}")
            return []
    
    def _regex_secret_scan(self, target_path: str) -> List[Dict[str, Any]]:
        """Perform regex-based secret scanning"""
        try:
            secrets = []
            
            def scan_file(file_path: Path):
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read()
                        
                        for secret_type, pattern in self.secret_patterns.items():
                            matches = re.finditer(pattern, content, re.MULTILINE)
                            
                            for match in matches:
                                secret = {
                                    'source': 'regex_scan',
                                    'type': secret_type,
                                    'file_path': str(file_path),
                                    'line_number': content[:match.start()].count('\n') + 1,
                                    'match': match.group(0)[:50] + '...' if len(match.group(0)) > 50 else match.group(0),
                                    'severity': 'high'
                                }
                                secrets.append(secret)
                                
                except Exception:
                    pass  # Skip files that can't be read
            
            if Path(target_path).is_file():
                scan_file(Path(target_path))
            else:
                for root, dirs, files in os.walk(target_path):
                    for file in files:
                        file_path = Path(root) / file
                        if file_path.suffix.lower() in ['.py', '.js', '.java', '.php']:
                            scan_file(file_path)
            
            return secrets
            
        except Exception as e:
            self.logger.error(f"Regex secret scan failed: {str(e)}")
            return []
    
    def _generate_static_analysis_summary(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate static analysis summary"""
        return {
            'total_vulnerabilities': len(results.get('vulnerabilities', [])),
            'total_secrets': len(results.get('secrets', [])),
            'languages_analyzed': results.get('languages_detected', []),
            'tools_used': list(results.get('tool_results', {}).keys())
        }
    
    def quick_scan(self, target_path: str) -> Dict[str, Any]:
        """Perform quick static code analysis"""
        return self.analyze_codebase(target_path, "quick")
    
    def secret_scan_only(self, target_path: str) -> List[Dict[str, Any]]:
        """Perform only secret scanning"""
        return self._regex_secret_scan(target_path)


def analyze_code_security(target_path: str, profile: str = "default") -> Dict[str, Any]:
    """Analyze code for security issues"""
    analyzer = StaticCodeAnalyzer()
    return analyzer.analyze_codebase(target_path, profile)