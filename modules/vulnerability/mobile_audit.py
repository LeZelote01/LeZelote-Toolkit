"""
Pentest-USB Toolkit - Mobile Application Security Audit Module
==============================================================

Mobile application security testing using MobSF, Frida, and other tools.
Provides comprehensive mobile app security assessment for Android and iOS.

Author: Pentest-USB Development Team
Version: 1.0.0
"""

import subprocess
import json
import time
import requests
import os
from pathlib import Path
from typing import Dict, List, Any, Optional
from urllib.parse import urljoin

from ...core.utils.logging_handler import get_logger
from ...core.utils.error_handler import PentestError, MobileAuditError
from ...core.utils.file_ops import FileOperations


class MobileSecurityAuditor:
    """
    Mobile application security auditing module
    """
    
    def __init__(self):
        """Initialize Mobile Security Auditor"""
        self.logger = get_logger(__name__)
        self.file_ops = FileOperations()
        
        # Tool paths and configurations
        self.tools = {
            'mobsf': self._find_tool('mobsf'),
            'frida': self._find_tool('frida'),
            'objection': self._find_tool('objection'),
            'jadx': self._find_tool('jadx'),
            'apktool': self._find_tool('apktool'),
            'dex2jar': self._find_tool('dex2jar'),
            'aapt': self._find_tool('aapt'),
            'zipalign': self._find_tool('zipalign')
        }
        
        # MobSF configuration
        self.mobsf_config = {
            'host': 'localhost',
            'port': 8000,
            'api_key': None,
            'base_url': None
        }
        
        # Supported file types
        self.supported_formats = {
            'android': ['.apk', '.aab', '.zip'],
            'ios': ['.ipa', '.app'],
            'source': ['.zip', '.tar.gz', '.tar']
        }
        
        # Security check categories
        self.check_categories = {
            'permissions': 'Permission Analysis',
            'manifest': 'Manifest Analysis',
            'code': 'Code Analysis',
            'crypto': 'Cryptographic Analysis',
            'network': 'Network Security',
            'storage': 'Data Storage',
            'binary': 'Binary Analysis'
        }
        
        self.logger.info("MobileSecurityAuditor initialized")
    
    def _find_tool(self, tool_name: str) -> Optional[str]:
        """Find tool executable path"""
        import shutil
        
        # Check system PATH
        tool_path = shutil.which(tool_name)
        if tool_path:
            return tool_path
        
        # Check toolkit binaries
        potential_paths = [
            f'./tools/binaries/{tool_name}',
            f'./tools/binaries/linux/{tool_name}',
            f'./tools/python_scripts/{tool_name}',
            f'./tools/python_scripts/{tool_name}.py'
        ]
        
        for path in potential_paths:
            if Path(path).exists():
                return str(Path(path).absolute())
        
        self.logger.warning(f"Tool {tool_name} not found")
        return None
    
    def audit_mobile_app(self, app_path: str, platform: str = "auto", 
                        profile: str = "default") -> Dict[str, Any]:
        """
        Comprehensive mobile application security audit
        
        Args:
            app_path: Path to mobile application file (APK, IPA, etc.)
            platform: Target platform (android, ios, auto)
            profile: Audit profile (quick, default, comprehensive, dynamic)
            
        Returns:
            Mobile security audit results
        """
        try:
            self.logger.info(f"Starting mobile security audit: {app_path} (profile: {profile})")
            
            # Validate application file
            if not Path(app_path).exists():
                raise MobileAuditError(f"Application file not found: {app_path}")
            
            # Auto-detect platform if not specified
            if platform == "auto":
                platform = self._detect_platform(app_path)
            
            # Validate platform
            if platform not in ['android', 'ios']:
                raise MobileAuditError(f"Unsupported platform: {platform}")
            
            results = {
                'app_path': app_path,
                'platform': platform,
                'profile': profile,
                'timestamp': time.time(),
                'app_info': {},
                'permissions': [],
                'manifest_analysis': {},
                'code_vulnerabilities': [],
                'crypto_issues': [],
                'network_security': {},
                'storage_issues': [],
                'binary_analysis': {},
                'dynamic_analysis': {},
                'tool_results': {},
                'summary': {}
            }
            
            # Basic app information extraction
            results['app_info'] = self._extract_app_info(app_path, platform)
            
            # Execute audit based on profile
            if profile == "quick":
                results = self._quick_mobile_audit(app_path, platform, results)
            elif profile == "comprehensive":
                results = self._comprehensive_mobile_audit(app_path, platform, results)
            elif profile == "dynamic":
                results = self._dynamic_mobile_audit(app_path, platform, results)
            else:
                results = self._default_mobile_audit(app_path, platform, results)
            
            # Risk assessment
            results = self._assess_mobile_risks(results)
            
            # Generate summary
            results['summary'] = self._generate_mobile_audit_summary(results)
            
            return results
            
        except Exception as e:
            self.logger.error(f"Mobile security audit failed: {str(e)}")
            raise MobileAuditError(f"Mobile audit failed: {str(e)}")
    
    def _detect_platform(self, app_path: str) -> str:
        """Auto-detect mobile platform from file extension"""
        try:
            file_ext = Path(app_path).suffix.lower()
            
            if file_ext in self.supported_formats['android']:
                return 'android'
            elif file_ext in self.supported_formats['ios']:
                return 'ios'
            else:
                # Try to detect by file analysis
                return self._analyze_file_type(app_path)
                
        except Exception as e:
            self.logger.error(f"Platform detection failed: {str(e)}")
            return 'android'  # Default to Android
    
    def _analyze_file_type(self, app_path: str) -> str:
        """Analyze file type to determine platform"""
        try:
            # Use file command to analyze
            result = subprocess.run(['file', app_path], capture_output=True, text=True)
            
            if 'Android' in result.stdout or 'APK' in result.stdout:
                return 'android'
            elif 'Mach-O' in result.stdout or 'iOS' in result.stdout:
                return 'ios'
            
            return 'android'  # Default fallback
            
        except Exception:
            return 'android'
    
    def _extract_app_info(self, app_path: str, platform: str) -> Dict[str, Any]:
        """Extract basic application information"""
        try:
            app_info = {
                'file_name': Path(app_path).name,
                'file_size': Path(app_path).stat().st_size,
                'platform': platform,
                'package_name': None,
                'version_name': None,
                'version_code': None,
                'min_sdk_version': None,
                'target_sdk_version': None,
                'permissions': []
            }
            
            if platform == 'android':
                app_info.update(self._extract_android_info(app_path))
            elif platform == 'ios':
                app_info.update(self._extract_ios_info(app_path))
            
            return app_info
            
        except Exception as e:
            self.logger.error(f"App info extraction failed: {str(e)}")
            return {'error': str(e)}
    
    def _extract_android_info(self, app_path: str) -> Dict[str, Any]:
        """Extract Android APK information"""
        try:
            info = {}
            
            # Use aapt to extract APK information
            if self.tools['aapt']:
                result = subprocess.run([
                    self.tools['aapt'], 'dump', 'badging', app_path
                ], capture_output=True, text=True, timeout=30)
                
                if result.returncode == 0:
                    info.update(self._parse_aapt_output(result.stdout))
            
            # Use apktool for additional analysis
            if self.tools['apktool']:
                apktool_info = self._run_apktool_analysis(app_path)
                info.update(apktool_info)
            
            return info
            
        except Exception as e:
            self.logger.error(f"Android info extraction failed: {str(e)}")
            return {}
    
    def _extract_ios_info(self, app_path: str) -> Dict[str, Any]:
        """Extract iOS IPA information"""
        try:
            # Placeholder for iOS information extraction
            # Would require iOS-specific tools like otool, class-dump, etc.
            
            info = {
                'bundle_id': None,
                'bundle_name': None,
                'bundle_version': None,
                'minimum_os_version': None,
                'architectures': []
            }
            
            return info
            
        except Exception as e:
            self.logger.error(f"iOS info extraction failed: {str(e)}")
            return {}
    
    def _quick_mobile_audit(self, app_path: str, platform: str, results: Dict[str, Any]) -> Dict[str, Any]:
        """Quick mobile security audit"""
        try:
            # Basic permission analysis
            if platform == 'android':
                permissions = self._analyze_android_permissions(app_path)
                results['permissions'] = permissions
                results['tool_results']['permission_analysis'] = len(permissions)
            
            # Basic manifest analysis
            manifest_issues = self._analyze_manifest_security(app_path, platform)
            results['manifest_analysis'] = manifest_issues
            results['tool_results']['manifest_analysis'] = len(manifest_issues.get('issues', []))
            
            return results
            
        except Exception as e:
            self.logger.error(f"Quick mobile audit failed: {str(e)}")
            return results
    
    def _default_mobile_audit(self, app_path: str, platform: str, results: Dict[str, Any]) -> Dict[str, Any]:
        """Default mobile security audit"""
        try:
            # MobSF static analysis
            if self._is_mobsf_available():
                mobsf_results = self._run_mobsf_analysis(app_path)
                results.update(mobsf_results)
                results['tool_results']['mobsf'] = 1
            
            # Platform-specific analysis
            if platform == 'android':
                results = self._android_security_analysis(app_path, results)
            elif platform == 'ios':
                results = self._ios_security_analysis(app_path, results)
            
            return results
            
        except Exception as e:
            self.logger.error(f"Default mobile audit failed: {str(e)}")
            return results
    
    def _comprehensive_mobile_audit(self, app_path: str, platform: str, results: Dict[str, Any]) -> Dict[str, Any]:
        """Comprehensive mobile security audit"""
        try:
            # All static analysis tools
            results = self._default_mobile_audit(app_path, platform, results)
            
            # Additional comprehensive checks
            if platform == 'android':
                # JADX decompilation and analysis
                if self.tools['jadx']:
                    jadx_results = self._run_jadx_analysis(app_path)
                    results['code_vulnerabilities'].extend(jadx_results)
                    results['tool_results']['jadx'] = len(jadx_results)
                
                # Advanced binary analysis
                binary_analysis = self._comprehensive_binary_analysis(app_path)
                results['binary_analysis'].update(binary_analysis)
                results['tool_results']['binary_analysis'] = len(binary_analysis.get('findings', []))
            
            # Network security analysis
            network_security = self._analyze_network_security(app_path, platform)
            results['network_security'] = network_security
            results['tool_results']['network_security'] = len(network_security.get('issues', []))
            
            return results
            
        except Exception as e:
            self.logger.error(f"Comprehensive mobile audit failed: {str(e)}")
            return results
    
    def _dynamic_mobile_audit(self, app_path: str, platform: str, results: Dict[str, Any]) -> Dict[str, Any]:
        """Dynamic mobile security audit using runtime analysis"""
        try:
            # Frida-based dynamic analysis
            if self.tools['frida']:
                dynamic_results = self._run_frida_analysis(app_path, platform)
                results['dynamic_analysis'] = dynamic_results
                results['tool_results']['frida'] = len(dynamic_results.get('hooks', []))
            
            # Objection analysis
            if self.tools['objection']:
                objection_results = self._run_objection_analysis(app_path)
                results['dynamic_analysis'].update(objection_results)
                results['tool_results']['objection'] = len(objection_results.get('findings', []))
            
            return results
            
        except Exception as e:
            self.logger.error(f"Dynamic mobile audit failed: {str(e)}")
            return results
    
    def _is_mobsf_available(self) -> bool:
        """Check if MobSF is available and running"""
        try:
            if not self.mobsf_config['base_url']:
                self.mobsf_config['base_url'] = f"http://{self.mobsf_config['host']}:{self.mobsf_config['port']}"
            
            response = requests.get(
                urljoin(self.mobsf_config['base_url'], '/api/v1/upload'),
                timeout=10
            )
            
            return response.status_code in [200, 405]  # 405 is expected for GET on upload endpoint
            
        except Exception:
            return False
    
    def _run_mobsf_analysis(self, app_path: str) -> Dict[str, Any]:
        """Run MobSF static analysis"""
        try:
            if not self._is_mobsf_available():
                return {}
            
            self.logger.info(f"Running MobSF analysis on {app_path}")
            
            # Upload file to MobSF
            upload_url = urljoin(self.mobsf_config['base_url'], '/api/v1/upload')
            
            with open(app_path, 'rb') as f:
                files = {'file': f}
                headers = {}
                
                if self.mobsf_config['api_key']:
                    headers['Authorization'] = self.mobsf_config['api_key']
                
                response = requests.post(upload_url, files=files, headers=headers, timeout=300)
            
            if response.status_code == 200:
                upload_data = response.json()
                file_hash = upload_data.get('hash')
                
                if file_hash:
                    # Get scan results
                    return self._get_mobsf_results(file_hash)
            
            return {}
            
        except Exception as e:
            self.logger.error(f"MobSF analysis failed: {str(e)}")
            return {}
    
    def _get_mobsf_results(self, file_hash: str) -> Dict[str, Any]:
        """Get MobSF scan results"""
        try:
            scan_url = urljoin(self.mobsf_config['base_url'], f'/api/v1/scan')
            
            headers = {}
            if self.mobsf_config['api_key']:
                headers['Authorization'] = self.mobsf_config['api_key']
            
            data = {'hash': file_hash}
            response = requests.post(scan_url, data=data, headers=headers, timeout=600)
            
            if response.status_code == 200:
                scan_results = response.json()
                return self._parse_mobsf_results(scan_results)
            
            return {}
            
        except Exception as e:
            self.logger.error(f"MobSF results retrieval failed: {str(e)}")
            return {}
    
    def _parse_mobsf_results(self, mobsf_data: Dict[str, Any]) -> Dict[str, Any]:
        """Parse MobSF scan results"""
        try:
            results = {
                'permissions': mobsf_data.get('permissions', {}),
                'manifest_analysis': {
                    'issues': []
                },
                'code_vulnerabilities': [],
                'crypto_issues': [],
                'network_security': {
                    'issues': []
                }
            }
            
            # Parse security issues
            for finding in mobsf_data.get('code_analysis', {}).values():
                if isinstance(finding, dict) and finding.get('type') == 'Insecure':
                    vulnerability = {
                        'source': 'mobsf',
                        'title': finding.get('title', ''),
                        'description': finding.get('description', ''),
                        'severity': finding.get('level', 'info').lower(),
                        'file_path': finding.get('path', ''),
                        'line_number': finding.get('line', 0),
                        'type': 'mobile_vulnerability'
                    }
                    results['code_vulnerabilities'].append(vulnerability)
            
            return results
            
        except Exception as e:
            self.logger.error(f"MobSF results parsing failed: {str(e)}")
            return {}
    
    def _analyze_android_permissions(self, app_path: str) -> List[Dict[str, Any]]:
        """Analyze Android application permissions"""
        try:
            permissions = []
            
            if self.tools['aapt']:
                result = subprocess.run([
                    self.tools['aapt'], 'dump', 'permissions', app_path
                ], capture_output=True, text=True, timeout=30)
                
                if result.returncode == 0:
                    permissions = self._parse_android_permissions(result.stdout)
            
            return permissions
            
        except Exception as e:
            self.logger.error(f"Permission analysis failed: {str(e)}")
            return []
    
    def _parse_android_permissions(self, aapt_output: str) -> List[Dict[str, Any]]:
        """Parse Android permissions from aapt output"""
        try:
            permissions = []
            dangerous_permissions = {
                'android.permission.CAMERA',
                'android.permission.RECORD_AUDIO',
                'android.permission.ACCESS_FINE_LOCATION',
                'android.permission.ACCESS_COARSE_LOCATION',
                'android.permission.READ_CONTACTS',
                'android.permission.WRITE_CONTACTS',
                'android.permission.READ_SMS',
                'android.permission.SEND_SMS',
                'android.permission.READ_PHONE_STATE',
                'android.permission.CALL_PHONE'
            }
            
            for line in aapt_output.split('\n'):
                if 'uses-permission:' in line:
                    # Extract permission name
                    parts = line.split("'")
                    if len(parts) >= 2:
                        permission_name = parts[1]
                        
                        permission_info = {
                            'name': permission_name,
                            'risk_level': 'high' if permission_name in dangerous_permissions else 'medium',
                            'description': self._get_permission_description(permission_name)
                        }
                        
                        permissions.append(permission_info)
            
            return permissions
            
        except Exception as e:
            self.logger.error(f"Permission parsing failed: {str(e)}")
            return []
    
    def _get_permission_description(self, permission: str) -> str:
        """Get description for Android permission"""
        descriptions = {
            'android.permission.CAMERA': 'Access device camera',
            'android.permission.RECORD_AUDIO': 'Record audio using microphone',
            'android.permission.ACCESS_FINE_LOCATION': 'Access precise location',
            'android.permission.ACCESS_COARSE_LOCATION': 'Access approximate location',
            'android.permission.READ_CONTACTS': 'Read device contacts',
            'android.permission.WRITE_CONTACTS': 'Modify device contacts',
            'android.permission.READ_SMS': 'Read SMS messages',
            'android.permission.SEND_SMS': 'Send SMS messages',
            'android.permission.READ_PHONE_STATE': 'Read phone state and identity',
            'android.permission.CALL_PHONE': 'Initiate phone calls',
            'android.permission.INTERNET': 'Access internet',
            'android.permission.WRITE_EXTERNAL_STORAGE': 'Write to external storage'
        }
        
        return descriptions.get(permission, 'Unknown permission')
    
    def _analyze_manifest_security(self, app_path: str, platform: str) -> Dict[str, Any]:
        """Analyze manifest security configuration"""
        try:
            manifest_issues = {
                'issues': [],
                'exported_components': [],
                'debug_flags': [],
                'backup_settings': {}
            }
            
            if platform == 'android':
                manifest_issues = self._analyze_android_manifest(app_path)
            elif platform == 'ios':
                manifest_issues = self._analyze_ios_plist(app_path)
            
            return manifest_issues
            
        except Exception as e:
            self.logger.error(f"Manifest analysis failed: {str(e)}")
            return {'issues': [], 'error': str(e)}
    
    def _analyze_android_manifest(self, app_path: str) -> Dict[str, Any]:
        """Analyze Android manifest for security issues"""
        try:
            issues = []
            
            if self.tools['aapt']:
                # Get XML dump of manifest
                result = subprocess.run([
                    self.tools['aapt'], 'dump', 'xmltree', app_path, 'AndroidManifest.xml'
                ], capture_output=True, text=True, timeout=30)
                
                if result.returncode == 0:
                    issues = self._parse_manifest_security_issues(result.stdout)
            
            return {
                'issues': issues,
                'exported_components': [],
                'debug_flags': [],
                'backup_settings': {}
            }
            
        except Exception as e:
            self.logger.error(f"Android manifest analysis failed: {str(e)}")
            return {'issues': [], 'error': str(e)}
    
    def _analyze_ios_plist(self, app_path: str) -> Dict[str, Any]:
        """Analyze iOS Info.plist for security issues"""
        # Placeholder for iOS plist analysis
        return {'issues': [], 'note': 'iOS plist analysis not implemented'}
    
    def _parse_manifest_security_issues(self, manifest_xml: str) -> List[Dict[str, Any]]:
        """Parse Android manifest for security issues"""
        try:
            issues = []
            
            # Check for debug mode
            if 'android:debuggable' in manifest_xml and 'true' in manifest_xml:
                issues.append({
                    'type': 'debug_enabled',
                    'severity': 'high',
                    'description': 'Application is debuggable in production',
                    'recommendation': 'Set android:debuggable to false for production builds'
                })
            
            # Check for backup allowance
            if 'android:allowBackup' in manifest_xml and 'true' in manifest_xml:
                issues.append({
                    'type': 'backup_allowed',
                    'severity': 'medium',
                    'description': 'Application allows backup of data',
                    'recommendation': 'Consider setting android:allowBackup to false for sensitive apps'
                })
            
            return issues
            
        except Exception as e:
            self.logger.error(f"Manifest parsing failed: {str(e)}")
            return []
    
    def _parse_aapt_output(self, aapt_output: str) -> Dict[str, Any]:
        """Parse aapt badging output"""
        try:
            info = {}
            
            for line in aapt_output.split('\n'):
                if line.startswith('package:'):
                    # Extract package information
                    parts = line.split()
                    for part in parts:
                        if part.startswith('name='):
                            info['package_name'] = part.split('=')[1].strip("'")
                        elif part.startswith('versionName='):
                            info['version_name'] = part.split('=')[1].strip("'")
                        elif part.startswith('versionCode='):
                            info['version_code'] = part.split('=')[1].strip("'")
                
                elif line.startswith('sdkVersion:'):
                    info['min_sdk_version'] = line.split(':')[1].strip().strip("'")
                elif line.startswith('targetSdkVersion:'):
                    info['target_sdk_version'] = line.split(':')[1].strip().strip("'")
            
            return info
            
        except Exception as e:
            self.logger.error(f"AAPT output parsing failed: {str(e)}")
            return {}
    
    def _run_apktool_analysis(self, app_path: str) -> Dict[str, Any]:
        """Run apktool analysis"""
        # Placeholder for apktool analysis
        return {}
    
    def _android_security_analysis(self, app_path: str, results: Dict[str, Any]) -> Dict[str, Any]:
        """Android-specific security analysis"""
        try:
            # Permission analysis
            permissions = self._analyze_android_permissions(app_path)
            results['permissions'] = permissions
            results['tool_results']['permission_analysis'] = len(permissions)
            
            # Manifest analysis
            manifest_analysis = self._analyze_android_manifest(app_path)
            results['manifest_analysis'] = manifest_analysis
            results['tool_results']['manifest_analysis'] = len(manifest_analysis.get('issues', []))
            
            return results
            
        except Exception as e:
            self.logger.error(f"Android security analysis failed: {str(e)}")
            return results
    
    def _ios_security_analysis(self, app_path: str, results: Dict[str, Any]) -> Dict[str, Any]:
        """iOS-specific security analysis"""
        try:
            # Placeholder for iOS-specific analysis
            # Would include plist analysis, entitlements check, binary analysis, etc.
            
            results['tool_results']['ios_analysis'] = 0
            return results
            
        except Exception as e:
            self.logger.error(f"iOS security analysis failed: {str(e)}")
            return results
    
    def _run_jadx_analysis(self, app_path: str) -> List[Dict[str, Any]]:
        """Run JADX decompilation and analysis"""
        # Placeholder for JADX analysis
        return []
    
    def _comprehensive_binary_analysis(self, app_path: str) -> Dict[str, Any]:
        """Comprehensive binary analysis"""
        # Placeholder for binary analysis
        return {'findings': []}
    
    def _analyze_network_security(self, app_path: str, platform: str) -> Dict[str, Any]:
        """Analyze network security configuration"""
        # Placeholder for network security analysis
        return {'issues': []}
    
    def _run_frida_analysis(self, app_path: str, platform: str) -> Dict[str, Any]:
        """Run Frida-based dynamic analysis"""
        # Placeholder for Frida analysis
        return {'hooks': []}
    
    def _run_objection_analysis(self, app_path: str) -> Dict[str, Any]:
        """Run Objection analysis"""
        # Placeholder for Objection analysis
        return {'findings': []}
    
    def _assess_mobile_risks(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Assess and prioritize mobile security risks"""
        try:
            # Calculate risk scores for vulnerabilities
            for vuln in results.get('code_vulnerabilities', []):
                severity = vuln.get('severity', 'info')
                
                risk_score = {
                    'critical': 9.0,
                    'high': 7.0,
                    'medium': 5.0,
                    'low': 3.0,
                    'info': 1.0
                }.get(severity.lower(), 1.0)
                
                vuln['risk_score'] = risk_score
            
            # Calculate risk scores for permissions
            for permission in results.get('permissions', []):
                risk_level = permission.get('risk_level', 'medium')
                
                permission['risk_score'] = {
                    'high': 7.0,
                    'medium': 4.0,
                    'low': 2.0
                }.get(risk_level, 4.0)
            
            return results
            
        except Exception as e:
            self.logger.error(f"Risk assessment failed: {str(e)}")
            return results
    
    def _generate_mobile_audit_summary(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate comprehensive mobile audit summary"""
        try:
            vulnerabilities = results.get('code_vulnerabilities', [])
            permissions = results.get('permissions', [])
            manifest_issues = results.get('manifest_analysis', {}).get('issues', [])
            
            summary = {
                'total_vulnerabilities': len(vulnerabilities),
                'critical_vulnerabilities': 0,
                'high_vulnerabilities': 0,
                'medium_vulnerabilities': 0,
                'low_vulnerabilities': 0,
                'info_vulnerabilities': 0,
                'total_permissions': len(permissions),
                'dangerous_permissions': len([p for p in permissions if p.get('risk_level') == 'high']),
                'manifest_issues': len(manifest_issues),
                'crypto_issues': len(results.get('crypto_issues', [])),
                'network_security_issues': len(results.get('network_security', {}).get('issues', [])),
                'storage_issues': len(results.get('storage_issues', [])),
                'platform': results.get('platform'),
                'app_package': results.get('app_info', {}).get('package_name'),
                'tools_used': list(results.get('tool_results', {}).keys()),
                'highest_risk_score': 0.0,
                'average_risk_score': 0.0
            }
            
            risk_scores = []
            
            # Count vulnerability severities
            for vuln in vulnerabilities:
                severity = vuln.get('severity', 'info').lower()
                summary[f'{severity}_vulnerabilities'] += 1
                
                risk_score = vuln.get('risk_score', 0.0)
                risk_scores.append(risk_score)
                
                if risk_score > summary['highest_risk_score']:
                    summary['highest_risk_score'] = risk_score
            
            # Include permission risk scores
            for permission in permissions:
                risk_score = permission.get('risk_score', 0.0)
                risk_scores.append(risk_score)
                
                if risk_score > summary['highest_risk_score']:
                    summary['highest_risk_score'] = risk_score
            
            if risk_scores:
                summary['average_risk_score'] = sum(risk_scores) / len(risk_scores)
            
            return summary
            
        except Exception as e:
            self.logger.error(f"Summary generation failed: {str(e)}")
            return {}
    
    # Public interface methods
    def audit_android_app(self, apk_path: str, profile: str = "default") -> Dict[str, Any]:
        """Audit Android application"""
        return self.audit_mobile_app(apk_path, "android", profile)
    
    def audit_ios_app(self, ipa_path: str, profile: str = "default") -> Dict[str, Any]:
        """Audit iOS application"""
        return self.audit_mobile_app(ipa_path, "ios", profile)
    
    def quick_mobile_scan(self, app_path: str, platform: str = "auto") -> Dict[str, Any]:
        """Quick mobile security scan"""
        return self.audit_mobile_app(app_path, platform, "quick")
    
    def dynamic_mobile_audit(self, app_path: str, platform: str = "auto") -> Dict[str, Any]:
        """Dynamic mobile security audit"""
        return self.audit_mobile_app(app_path, platform, "dynamic")


# Module-level functions for easy access
def audit_mobile_application(app_path: str, platform: str = "auto", profile: str = "default") -> Dict[str, Any]:
    """Audit mobile application security"""
    auditor = MobileSecurityAuditor()
    return auditor.audit_mobile_app(app_path, platform, profile)


def audit_android_apk(apk_path: str, profile: str = "default") -> Dict[str, Any]:
    """Audit Android APK file"""
    auditor = MobileSecurityAuditor()
    return auditor.audit_android_app(apk_path, profile)


def audit_ios_ipa(ipa_path: str, profile: str = "default") -> Dict[str, Any]:
    """Audit iOS IPA file"""
    auditor = MobileSecurityAuditor()
    return auditor.audit_ios_app(ipa_path, profile)