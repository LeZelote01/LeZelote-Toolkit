"""
Pentest-USB Toolkit - Social Engineering Module
===============================================

Social engineering automation using Gophish, King Phisher, and custom campaigns.
Template management, statistics, and analytics for social engineering assessments.

Author: Pentest-USB Development Team
Version: 1.0.0
"""

import re
import time
import json
import uuid
import smtplib
import subprocess
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path
from email.mime.text import MimeText
from email.mime.multipart import MimeMultipart
from email.mime.base import MimeBase
from email import encoders
from datetime import datetime, timedelta
import sqlite3

from ...core.utils.logging_handler import get_logger
from ...core.utils.error_handler import PentestError
from ...core.security.consent_manager import ConsentManager
from ...core.utils.file_ops import FileOperations


class SocialEngineeringEngine:
    """
    Social engineering automation and campaign management engine
    """
    
    def __init__(self):
        """Initialize Social Engineering Engine"""
        self.logger = get_logger(__name__)
        self.consent_manager = ConsentManager()
        self.file_ops = FileOperations()
        
        # Tool paths
        self.gophish_path = self._find_tool_path('gophish')
        self.setoolkit_path = self._find_tool_path('setoolkit')
        
        # Working directories
        self.campaigns_dir = Path("/app/outputs/social_engineering/campaigns")
        self.templates_dir = Path("/app/data/templates/social_engineering")
        self.results_dir = Path("/app/outputs/social_engineering/results")
        
        self.file_ops.ensure_directory(self.campaigns_dir)
        self.file_ops.ensure_directory(self.templates_dir)
        self.file_ops.ensure_directory(self.results_dir)
        
        # Initialize database for tracking
        self.db_path = self.results_dir / "social_engineering.db"
        self._init_database()
        
        # Template manager
        self.template_manager = TemplateManager(self.templates_dir)
        
        # Campaign statistics
        self.stats_tracker = CampaignStatistics(self.db_path)
        
        self.logger.info("SocialEngineeringEngine initialized")
    
    def _find_tool_path(self, tool_name: str) -> Optional[str]:
        """Find tool path in binaries directory"""
        try:
            import platform
            system = platform.system().lower()
            
            tool_dir = Path(f"/app/tools/binaries/{system}")
            if system == "windows":
                tool_path = tool_dir / f"{tool_name}.exe"
            else:
                tool_path = tool_dir / tool_name
            
            if tool_path.exists():
                return str(tool_path)
            
            # Fallback to system PATH
            try:
                result = subprocess.run(['which', tool_name], capture_output=True, text=True)
                if result.returncode == 0:
                    return result.stdout.strip()
            except:
                pass
                
            self.logger.warning(f"Tool not found: {tool_name}")
            return None
            
        except Exception as e:
            self.logger.error(f"Error finding tool {tool_name}: {str(e)}")
            return None
    
    def _init_database(self):
        """Initialize SQLite database for campaign tracking"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Campaigns table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS campaigns (
                        id TEXT PRIMARY KEY,
                        name TEXT NOT NULL,
                        type TEXT NOT NULL,
                        status TEXT NOT NULL,
                        target_count INTEGER DEFAULT 0,
                        sent_count INTEGER DEFAULT 0,
                        opened_count INTEGER DEFAULT 0,
                        clicked_count INTEGER DEFAULT 0,
                        submitted_count INTEGER DEFAULT 0,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        started_at TIMESTAMP,
                        completed_at TIMESTAMP
                    )
                ''')
                
                # Targets table
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS targets (
                        id TEXT PRIMARY KEY,
                        campaign_id TEXT,
                        email TEXT NOT NULL,
                        first_name TEXT,
                        last_name TEXT,
                        position TEXT,
                        department TEXT,
                        status TEXT DEFAULT 'pending',
                        sent_at TIMESTAMP,
                        opened_at TIMESTAMP,
                        clicked_at TIMESTAMP,
                        submitted_at TIMESTAMP,
                        user_agent TEXT,
                        ip_address TEXT,
                        FOREIGN KEY (campaign_id) REFERENCES campaigns (id)
                    )
                ''')
                
                # Events table for detailed tracking
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS events (
                        id TEXT PRIMARY KEY,
                        campaign_id TEXT,
                        target_id TEXT,
                        event_type TEXT NOT NULL,
                        timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        details TEXT,
                        FOREIGN KEY (campaign_id) REFERENCES campaigns (id),
                        FOREIGN KEY (target_id) REFERENCES targets (id)
                    )
                ''')
                
                conn.commit()
                self.logger.debug("Database initialized successfully")
                
        except Exception as e:
            self.logger.error(f"Database initialization failed: {str(e)}")
            raise PentestError(f"Database initialization failed: {str(e)}")
    
    def create_phishing_campaign(self, campaign_config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create and launch phishing campaign
        
        Args:
            campaign_config: Campaign configuration including targets, template, etc.
            
        Returns:
            Campaign creation and launch results
        """
        try:
            # Verify consent for social engineering
            if not self.consent_manager.verify_consent("social_engineering"):
                raise PentestError("Consent verification failed for social engineering campaign")
            
            self.logger.info("Creating phishing campaign")
            
            # Validate campaign configuration
            self._validate_campaign_config(campaign_config)
            
            # Generate campaign ID
            campaign_id = str(uuid.uuid4())
            campaign_config['campaign_id'] = campaign_id
            
            # Create campaign directory
            campaign_dir = self.campaigns_dir / campaign_id
            self.file_ops.ensure_directory(campaign_dir)
            
            # Process targets
            targets = self._process_targets(campaign_config.get('targets', []))
            
            # Select or create template
            template = self._prepare_template(campaign_config, campaign_dir)
            
            # Set up landing page
            landing_page = self._setup_landing_page(campaign_config, campaign_dir)
            
            # Create campaign in database
            campaign_info = self._create_campaign_record(campaign_config, targets)
            
            # Launch campaign based on method
            launch_method = campaign_config.get('method', 'email')
            if launch_method == 'email':
                launch_result = self._launch_email_campaign(campaign_config, targets, template, campaign_dir)
            elif launch_method == 'sms':
                launch_result = self._launch_sms_campaign(campaign_config, targets, template, campaign_dir)
            else:
                raise PentestError(f"Unsupported campaign method: {launch_method}")
            
            campaign_result = {
                'success': launch_result.get('success', False),
                'campaign_id': campaign_id,
                'campaign_name': campaign_config.get('name', 'Unnamed Campaign'),
                'method': launch_method,
                'targets_processed': len(targets),
                'template_used': template.get('name', 'Unknown'),
                'landing_page_url': landing_page.get('url', ''),
                'launch_result': launch_result,
                'campaign_directory': str(campaign_dir),
                'tracking_url': f"/track/{campaign_id}"
            }
            
            if launch_result.get('success', False):
                self.logger.info(f"Phishing campaign launched successfully: {campaign_id}")
                # Start monitoring
                self._start_campaign_monitoring(campaign_id)
            else:
                self.logger.error("Phishing campaign launch failed")
            
            return campaign_result
            
        except Exception as e:
            self.logger.error(f"Phishing campaign creation failed: {str(e)}")
            raise PentestError(f"Phishing campaign creation failed: {str(e)}")
    
    def create_pretexting_campaign(self, pretext_config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create pretexting (social engineering via phone/vishing) campaign
        
        Args:
            pretext_config: Pretexting campaign configuration
            
        Returns:
            Campaign results
        """
        try:
            self.logger.info("Creating pretexting campaign")
            
            # Verify consent
            if not self.consent_manager.verify_consent("social_engineering"):
                raise PentestError("Consent verification failed for pretexting campaign")
            
            campaign_id = str(uuid.uuid4())
            
            # Process targets
            targets = self._process_targets(pretext_config.get('targets', []))
            
            # Create pretext scripts
            scripts = self._generate_pretext_scripts(pretext_config)
            
            # Set up call tracking
            call_tracker = self._setup_call_tracking(campaign_id)
            
            # Create campaign record
            campaign_info = {
                'id': campaign_id,
                'name': pretext_config.get('name', 'Pretexting Campaign'),
                'type': 'pretexting',
                'status': 'ready',
                'target_count': len(targets)
            }
            
            self._save_campaign_info(campaign_info)
            
            pretexting_result = {
                'success': True,
                'campaign_id': campaign_id,
                'campaign_name': campaign_info['name'],
                'method': 'pretexting',
                'targets_count': len(targets),
                'scripts_generated': len(scripts),
                'call_tracking_setup': call_tracker.get('success', False),
                'scripts': scripts,
                'note': 'Pretexting campaign prepared - manual execution required'
            }
            
            self.logger.info(f"Pretexting campaign created: {campaign_id}")
            return pretexting_result
            
        except Exception as e:
            self.logger.error(f"Pretexting campaign creation failed: {str(e)}")
            raise PentestError(f"Pretexting campaign creation failed: {str(e)}")
    
    def create_physical_access_campaign(self, physical_config: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create physical social engineering campaign
        
        Args:
            physical_config: Physical campaign configuration
            
        Returns:
            Campaign results
        """
        try:
            self.logger.info("Creating physical access campaign")
            
            # Verify consent
            if not self.consent_manager.verify_consent("physical_access"):
                raise PentestError("Consent verification failed for physical access campaign")
            
            campaign_id = str(uuid.uuid4())
            
            # Generate pretexts and approaches
            approaches = self._generate_physical_approaches(physical_config)
            
            # Create documentation templates
            documentation = self._create_physical_documentation(physical_config, campaign_id)
            
            # Set up tracking
            tracking = self._setup_physical_tracking(campaign_id)
            
            physical_result = {
                'success': True,
                'campaign_id': campaign_id,
                'campaign_name': physical_config.get('name', 'Physical Access Campaign'),
                'method': 'physical_access',
                'approaches_generated': len(approaches),
                'documentation_created': len(documentation),
                'tracking_setup': tracking.get('success', False),
                'approaches': approaches,
                'documentation_files': documentation,
                'note': 'Physical access campaign prepared - manual execution required'
            }
            
            self.logger.info(f"Physical access campaign created: {campaign_id}")
            return physical_result
            
        except Exception as e:
            self.logger.error(f"Physical access campaign creation failed: {str(e)}")
            raise PentestError(f"Physical access campaign creation failed: {str(e)}")
    
    def get_campaign_statistics(self, campaign_id: str) -> Dict[str, Any]:
        """
        Get detailed statistics for a campaign
        
        Args:
            campaign_id: Campaign identifier
            
        Returns:
            Campaign statistics and analytics
        """
        try:
            return self.stats_tracker.get_campaign_stats(campaign_id)
            
        except Exception as e:
            self.logger.error(f"Failed to get campaign statistics: {str(e)}")
            raise PentestError(f"Failed to get campaign statistics: {str(e)}")
    
    def stop_campaign(self, campaign_id: str) -> Dict[str, Any]:
        """
        Stop an active campaign
        
        Args:
            campaign_id: Campaign to stop
            
        Returns:
            Stop operation results
        """
        try:
            self.logger.info(f"Stopping campaign: {campaign_id}")
            
            # Update campaign status
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE campaigns 
                    SET status = 'stopped', completed_at = CURRENT_TIMESTAMP 
                    WHERE id = ?
                ''', (campaign_id,))
                conn.commit()
            
            # Get final statistics
            final_stats = self.get_campaign_statistics(campaign_id)
            
            stop_result = {
                'success': True,
                'campaign_id': campaign_id,
                'stopped_at': datetime.now().isoformat(),
                'final_statistics': final_stats
            }
            
            self.logger.info(f"Campaign stopped successfully: {campaign_id}")
            return stop_result
            
        except Exception as e:
            self.logger.error(f"Failed to stop campaign: {str(e)}")
            raise PentestError(f"Failed to stop campaign: {str(e)}")
    
    def _validate_campaign_config(self, config: Dict[str, Any]):
        """Validate campaign configuration"""
        required_fields = ['name', 'targets', 'template_type']
        
        for field in required_fields:
            if field not in config:
                raise PentestError(f"Missing required field: {field}")
        
        if not config['targets']:
            raise PentestError("At least one target is required")
        
        # Validate email addresses if email campaign
        if config.get('method', 'email') == 'email':
            for target in config['targets']:
                if not self._validate_email(target.get('email', '')):
                    raise PentestError(f"Invalid email address: {target.get('email', '')}")
    
    def _validate_email(self, email: str) -> bool:
        """Validate email address format"""
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None
    
    def _process_targets(self, targets: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Process and validate targets"""
        processed_targets = []
        
        for target in targets:
            processed_target = {
                'id': str(uuid.uuid4()),
                'email': target.get('email', ''),
                'first_name': target.get('first_name', ''),
                'last_name': target.get('last_name', ''),
                'position': target.get('position', ''),
                'department': target.get('department', ''),
                'phone': target.get('phone', ''),
                'status': 'pending'
            }
            processed_targets.append(processed_target)
        
        return processed_targets
    
    def _prepare_template(self, campaign_config: Dict[str, Any], campaign_dir: Path) -> Dict[str, Any]:
        """Prepare email template for campaign"""
        template_type = campaign_config.get('template_type', 'generic_phishing')
        
        # Get template from template manager
        template = self.template_manager.get_template(template_type)
        
        if not template:
            # Create basic template if not found
            template = self.template_manager.create_basic_template(template_type)
        
        # Customize template with campaign-specific data
        template = self._customize_template(template, campaign_config)
        
        # Save customized template
        template_file = campaign_dir / 'template.html'
        with open(template_file, 'w', encoding='utf-8') as f:
            f.write(template['html_content'])
        
        template['file_path'] = str(template_file)
        return template
    
    def _customize_template(self, template: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
        """Customize template with campaign-specific data"""
        customizations = config.get('customizations', {})
        
        # Replace placeholders in template
        html_content = template.get('html_content', '')
        
        # Common placeholders
        html_content = html_content.replace('{{COMPANY_NAME}}', customizations.get('company_name', 'Company'))
        html_content = html_content.replace('{{SENDER_NAME}}', customizations.get('sender_name', 'IT Department'))
        html_content = html_content.replace('{{URGENCY_LEVEL}}', customizations.get('urgency_level', 'High'))
        
        template['html_content'] = html_content
        return template
    
    def _setup_landing_page(self, campaign_config: Dict[str, Any], campaign_dir: Path) -> Dict[str, Any]:
        """Set up phishing landing page"""
        landing_page_config = campaign_config.get('landing_page', {})
        
        # Create simple landing page
        landing_page_html = self._generate_landing_page_html(landing_page_config)
        
        # Save landing page
        landing_page_file = campaign_dir / 'landing_page.html'
        with open(landing_page_file, 'w', encoding='utf-8') as f:
            f.write(landing_page_html)
        
        # Set up simple HTTP server (placeholder)
        landing_page_url = f"http://localhost:8080/campaigns/{campaign_config['campaign_id']}/landing"
        
        return {
            'url': landing_page_url,
            'file_path': str(landing_page_file),
            'type': landing_page_config.get('type', 'credential_harvest')
        }
    
    def _generate_landing_page_html(self, config: Dict[str, Any]) -> str:
        """Generate landing page HTML"""
        page_type = config.get('type', 'credential_harvest')
        
        if page_type == 'credential_harvest':
            return '''
            <!DOCTYPE html>
            <html>
            <head>
                <title>Login Required</title>
                <style>
                    body { font-family: Arial, sans-serif; padding: 50px; }
                    .container { max-width: 400px; margin: 0 auto; }
                    .form-group { margin-bottom: 15px; }
                    input { width: 100%; padding: 10px; margin: 5px 0; }
                    button { width: 100%; padding: 12px; background: #007cba; color: white; border: none; }
                </style>
            </head>
            <body>
                <div class="container">
                    <h2>Authentication Required</h2>
                    <form method="post" action="/submit">
                        <div class="form-group">
                            <label>Username:</label>
                            <input type="text" name="username" required>
                        </div>
                        <div class="form-group">
                            <label>Password:</label>
                            <input type="password" name="password" required>
                        </div>
                        <button type="submit">Login</button>
                    </form>
                </div>
            </body>
            </html>
            '''
        else:
            return '''
            <!DOCTYPE html>
            <html>
            <head>
                <title>Information Required</title>
            </head>
            <body>
                <h2>Please provide the requested information</h2>
                <p>This is a simulated phishing landing page.</p>
            </body>
            </html>
            '''
    
    def _create_campaign_record(self, config: Dict[str, Any], targets: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Create campaign record in database"""
        try:
            campaign_info = {
                'id': config['campaign_id'],
                'name': config['name'],
                'type': config.get('method', 'email'),
                'status': 'created',
                'target_count': len(targets)
            }
            
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Insert campaign
                cursor.execute('''
                    INSERT INTO campaigns (id, name, type, status, target_count)
                    VALUES (?, ?, ?, ?, ?)
                ''', (
                    campaign_info['id'],
                    campaign_info['name'],
                    campaign_info['type'],
                    campaign_info['status'],
                    campaign_info['target_count']
                ))
                
                # Insert targets
                for target in targets:
                    cursor.execute('''
                        INSERT INTO targets (id, campaign_id, email, first_name, last_name, position, department)
                        VALUES (?, ?, ?, ?, ?, ?, ?)
                    ''', (
                        target['id'],
                        config['campaign_id'],
                        target['email'],
                        target['first_name'],
                        target['last_name'],
                        target['position'],
                        target['department']
                    ))
                
                conn.commit()
            
            return campaign_info
            
        except Exception as e:
            self.logger.error(f"Failed to create campaign record: {str(e)}")
            raise PentestError(f"Failed to create campaign record: {str(e)}")
    
    def _launch_email_campaign(self, config: Dict[str, Any], targets: List[Dict[str, Any]], 
                              template: Dict[str, Any], campaign_dir: Path) -> Dict[str, Any]:
        """Launch email phishing campaign"""
        try:
            # Email configuration
            email_config = config.get('email_config', {})
            
            sent_count = 0
            failed_count = 0
            errors = []
            
            # Send emails to targets
            for target in targets:
                try:
                    email_result = self._send_phishing_email(target, template, email_config, config)
                    if email_result.get('success', False):
                        sent_count += 1
                        # Update target status
                        self._update_target_status(target['id'], 'sent')
                    else:
                        failed_count += 1
                        errors.append(f"Failed to send to {target['email']}: {email_result.get('error', 'Unknown error')}")
                        
                except Exception as e:
                    failed_count += 1
                    errors.append(f"Exception sending to {target['email']}: {str(e)}")
            
            # Update campaign status
            self._update_campaign_status(config['campaign_id'], 'active', sent_count)
            
            launch_result = {
                'success': sent_count > 0,
                'sent_count': sent_count,
                'failed_count': failed_count,
                'total_targets': len(targets),
                'success_rate': (sent_count / len(targets)) * 100 if targets else 0,
                'errors': errors[:10]  # Limit error list
            }
            
            return launch_result
            
        except Exception as e:
            self.logger.error(f"Email campaign launch failed: {str(e)}")
            return {'success': False, 'error': str(e)}
    
    def _send_phishing_email(self, target: Dict[str, Any], template: Dict[str, Any], 
                           email_config: Dict[str, Any], campaign_config: Dict[str, Any]) -> Dict[str, Any]:
        """Send individual phishing email (placeholder implementation)"""
        try:
            # In a real implementation, this would send actual emails
            # For safety, we'll just simulate the process
            
            self.logger.info(f"Simulating phishing email to {target['email']}")
            
            # Simulate email sending
            time.sleep(0.1)  # Simulate network delay
            
            return {
                'success': True,
                'target_email': target['email'],
                'sent_at': datetime.now().isoformat(),
                'message_id': str(uuid.uuid4()),
                'note': 'Email sending simulated for safety'
            }
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def _launch_sms_campaign(self, config: Dict[str, Any], targets: List[Dict[str, Any]], 
                           template: Dict[str, Any], campaign_dir: Path) -> Dict[str, Any]:
        """Launch SMS phishing campaign"""
        try:
            # SMS campaigns are simulated for safety
            self.logger.info("SMS campaign simulated for safety")
            
            return {
                'success': True,
                'sent_count': len(targets),
                'note': 'SMS campaign simulated - actual implementation requires SMS gateway'
            }
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def _generate_pretext_scripts(self, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate pretexting scripts for different scenarios"""
        scenarios = config.get('scenarios', ['tech_support', 'vendor_verification'])
        
        scripts = []
        for scenario in scenarios:
            script = {
                'scenario': scenario,
                'script_content': self._get_pretext_script_template(scenario),
                'talking_points': self._get_talking_points(scenario),
                'common_responses': self._get_common_responses(scenario)
            }
            scripts.append(script)
        
        return scripts
    
    def _get_pretext_script_template(self, scenario: str) -> str:
        """Get script template for specific scenario"""
        templates = {
            'tech_support': """
            Hi, this is [NAME] from IT Support. We've detected some unusual activity on your account 
            and need to verify your credentials to secure your account. Can you please confirm your username?
            """,
            'vendor_verification': """
            Hello, this is [NAME] from [COMPANY NAME], one of your vendors. We're updating our systems 
            and need to verify some information for continuity of service.
            """,
            'survey': """
            Hi, I'm [NAME] conducting a brief security awareness survey for your organization. 
            This will only take 2 minutes of your time.
            """
        }
        return templates.get(scenario, 'Generic pretext script template')
    
    def _get_talking_points(self, scenario: str) -> List[str]:
        """Get talking points for scenario"""
        points = {
            'tech_support': [
                "Mention urgent security issue",
                "Reference company systems",
                "Ask for credential verification",
                "Offer to help secure the account"
            ],
            'vendor_verification': [
                "Reference existing business relationship",
                "Mention system updates or changes",
                "Ask for contact information verification",
                "Provide fake reference numbers"
            ]
        }
        return points.get(scenario, ['Generic talking points'])
    
    def _get_common_responses(self, scenario: str) -> List[str]:
        """Get common responses to handle objections"""
        responses = {
            'tech_support': [
                "I understand your concern about security, that's exactly why I'm calling",
                "Let me transfer you to my supervisor if you prefer",
                "We can verify this through your company directory"
            ]
        }
        return responses.get(scenario, ['I understand your concern'])
    
    def _setup_call_tracking(self, campaign_id: str) -> Dict[str, Any]:
        """Set up call tracking for pretexting campaign"""
        return {
            'success': True,
            'tracking_id': campaign_id,
            'note': 'Call tracking setup simulated'
        }
    
    def _generate_physical_approaches(self, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate physical access approaches"""
        approaches = [
            {
                'name': 'Tailgating',
                'description': 'Follow authorized personnel through secure doors',
                'requirements': ['Professional attire', 'Confidence', 'Timing'],
                'success_factors': ['Busy entrance', 'Carrying items', 'Friendly demeanor']
            },
            {
                'name': 'Delivery Person',
                'description': 'Pose as delivery person requiring access',
                'requirements': ['Delivery uniform', 'Packages', 'Delivery documentation'],
                'success_factors': ['Expected delivery time', 'Professional appearance', 'Urgency']
            },
            {
                'name': 'Maintenance Worker',
                'description': 'Pose as maintenance or contractor',
                'requirements': ['Work uniform', 'Tools', 'Work orders'],
                'success_factors': ['Off-hours access', 'Authority appearance', 'Technical knowledge']
            }
        ]
        
        return approaches
    
    def _create_physical_documentation(self, config: Dict[str, Any], campaign_id: str) -> List[str]:
        """Create documentation for physical access campaign"""
        docs_dir = self.campaigns_dir / campaign_id / 'physical_docs'
        self.file_ops.ensure_directory(docs_dir)
        
        # Create various documentation templates
        documents = [
            'work_order_template.docx',
            'delivery_receipt_template.pdf',
            'visitor_badge_template.png',
            'contractor_agreement_template.docx'
        ]
        
        created_docs = []
        for doc in documents:
            doc_path = docs_dir / doc
            # Create placeholder documents
            with open(doc_path, 'w') as f:
                f.write(f"# {doc}\n\nPlaceholder document for physical access campaign")
            created_docs.append(str(doc_path))
        
        return created_docs
    
    def _setup_physical_tracking(self, campaign_id: str) -> Dict[str, Any]:
        """Set up tracking for physical access campaign"""
        return {
            'success': True,
            'tracking_methods': ['Photo documentation', 'Time logs', 'Access logs'],
            'note': 'Physical tracking setup simulated'
        }
    
    def _update_target_status(self, target_id: str, status: str):
        """Update target status in database"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE targets SET status = ?, sent_at = CURRENT_TIMESTAMP WHERE id = ?
                ''', (status, target_id))
                conn.commit()
        except Exception as e:
            self.logger.error(f"Failed to update target status: {str(e)}")
    
    def _update_campaign_status(self, campaign_id: str, status: str, sent_count: int = 0):
        """Update campaign status in database"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    UPDATE campaigns 
                    SET status = ?, sent_count = ?, started_at = CURRENT_TIMESTAMP 
                    WHERE id = ?
                ''', (status, sent_count, campaign_id))
                conn.commit()
        except Exception as e:
            self.logger.error(f"Failed to update campaign status: {str(e)}")
    
    def _start_campaign_monitoring(self, campaign_id: str):
        """Start monitoring campaign activity"""
        # This would typically start a background process to monitor clicks, opens, etc.
        self.logger.info(f"Campaign monitoring started for {campaign_id}")
    
    def _save_campaign_info(self, campaign_info: Dict[str, Any]):
        """Save campaign information to database"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO campaigns (id, name, type, status, target_count)
                    VALUES (?, ?, ?, ?, ?)
                ''', (
                    campaign_info['id'],
                    campaign_info['name'],
                    campaign_info['type'],
                    campaign_info['status'],
                    campaign_info['target_count']
                ))
                conn.commit()
        except Exception as e:
            self.logger.error(f"Failed to save campaign info: {str(e)}")


class TemplateManager:
    """Manage phishing and social engineering templates"""
    
    def __init__(self, templates_dir: Path):
        self.templates_dir = templates_dir
        self.logger = get_logger(__name__)
    
    def get_template(self, template_type: str) -> Optional[Dict[str, Any]]:
        """Get template by type"""
        template_file = self.templates_dir / f"{template_type}.html"
        
        if template_file.exists():
            try:
                with open(template_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                
                return {
                    'name': template_type,
                    'html_content': content,
                    'file_path': str(template_file)
                }
            except Exception as e:
                self.logger.error(f"Failed to load template {template_type}: {str(e)}")
        
        return None
    
    def create_basic_template(self, template_type: str) -> Dict[str, Any]:
        """Create basic template if none exists"""
        basic_templates = {
            'generic_phishing': '''
                <!DOCTYPE html>
                <html>
                <head><title>Security Alert</title></head>
                <body>
                    <h2>Security Alert - Action Required</h2>
                    <p>Dear {{FIRST_NAME}},</p>
                    <p>We have detected suspicious activity on your account.</p>
                    <p>Please click <a href="{{TRACKING_LINK}}">here</a> to secure your account.</p>
                    <p>Best regards,<br>{{SENDER_NAME}}</p>
                </body>
                </html>
            ''',
            'office365_phishing': '''
                <!DOCTYPE html>
                <html>
                <head><title>Microsoft Office 365</title></head>
                <body>
                    <h2>Office 365 Security Alert</h2>
                    <p>Your Office 365 account requires immediate attention.</p>
                    <p><a href="{{TRACKING_LINK}}">Verify Account</a></p>
                </body>
                </html>
            '''
        }
        
        content = basic_templates.get(template_type, basic_templates['generic_phishing'])
        
        return {
            'name': template_type,
            'html_content': content,
            'file_path': None
        }


class CampaignStatistics:
    """Track and analyze campaign statistics"""
    
    def __init__(self, db_path: Path):
        self.db_path = db_path
        self.logger = get_logger(__name__)
    
    def get_campaign_stats(self, campaign_id: str) -> Dict[str, Any]:
        """Get comprehensive campaign statistics"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # Get campaign info
                cursor.execute('SELECT * FROM campaigns WHERE id = ?', (campaign_id,))
                campaign = cursor.fetchone()
                
                if not campaign:
                    return {'error': 'Campaign not found'}
                
                # Get target statistics
                cursor.execute('''
                    SELECT 
                        COUNT(*) as total_targets,
                        SUM(CASE WHEN status = 'sent' THEN 1 ELSE 0 END) as sent_count,
                        SUM(CASE WHEN opened_at IS NOT NULL THEN 1 ELSE 0 END) as opened_count,
                        SUM(CASE WHEN clicked_at IS NOT NULL THEN 1 ELSE 0 END) as clicked_count,
                        SUM(CASE WHEN submitted_at IS NOT NULL THEN 1 ELSE 0 END) as submitted_count
                    FROM targets WHERE campaign_id = ?
                ''', (campaign_id,))
                
                stats = cursor.fetchone()
                
                # Calculate rates
                total_targets = stats[0] if stats[0] else 1
                
                return {
                    'campaign_id': campaign_id,
                    'campaign_name': campaign[1],
                    'campaign_type': campaign[2],
                    'status': campaign[3],
                    'total_targets': stats[0] or 0,
                    'sent_count': stats[1] or 0,
                    'opened_count': stats[2] or 0,
                    'clicked_count': stats[3] or 0,
                    'submitted_count': stats[4] or 0,
                    'open_rate': (stats[2] or 0) / total_targets * 100,
                    'click_rate': (stats[3] or 0) / total_targets * 100,
                    'submission_rate': (stats[4] or 0) / total_targets * 100,
                    'created_at': campaign[8],
                    'started_at': campaign[9],
                    'completed_at': campaign[10]
                }
                
        except Exception as e:
            self.logger.error(f"Failed to get campaign statistics: {str(e)}")
            return {'error': str(e)}


# Module-level functions for easy integration
def create_phishing_campaign(campaign_config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Create and launch phishing campaign
    
    Args:
        campaign_config: Campaign configuration
        
    Returns:
        Campaign results
    """
    engine = SocialEngineeringEngine()
    return engine.create_phishing_campaign(campaign_config)


def create_pretexting_campaign(pretext_config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Create pretexting campaign
    
    Args:
        pretext_config: Pretexting configuration
        
    Returns:
        Campaign results
    """
    engine = SocialEngineeringEngine()
    return engine.create_pretexting_campaign(pretext_config)


def get_campaign_statistics(campaign_id: str) -> Dict[str, Any]:
    """
    Get campaign statistics
    
    Args:
        campaign_id: Campaign identifier
        
    Returns:
        Campaign statistics
    """
    engine = SocialEngineeringEngine()
    return engine.get_campaign_statistics(campaign_id)